{"version":3,"file":"ash-vm.js","sources":["../lib/commands.js","../lib/vm.js","../lib/audio/gibberish.js","../lib/ext/random.js","../lib/ext/debug.js","../lib/ext/compatibility.js","../lib/index.js","../lib/utils.js","../lib/process.js"],"sourcesContent":["// # Commands\nimport { isArray, isString, last, wrap } from './utils'\n\n// **Error messages**\nexport const ERR_EXPECT_PATTERN = 'Expected a pattern, but found:'\nexport const ERR_EXPECT_STRING = 'Expected a string, but found:'\n\n// **Utilities**\n\n// A generic stack operation that pops one value and pushes on result\nconst op1 = fn => ({ stack }) => {\n  stack.push(fn(stack.pop()))\n}\n\n// A generic stack operation that pops two values and pushes one result\nconst op2 = fn => ({ stack }) => {\n  stack.push(fn(stack.pop(), stack.pop()))\n}\n\n// A commands object is a map from instrunction name to functions\nexport default {\n  // ## Arithmetic\n  // | Name | Description | Example |\n  // |------|-------------|---------|\n  // | **@+**, **@add** | Add two values | `[1, 2, \"@+\"]` |\n  // | **@-**, **@sub** | Subtract two values | `[2, 1, \"@-\"]` |\n  // | **@\\***, **@mul** | Multiply two values | `[2, 4, \"@*\"]` |\n  // | **@/**, **@div** | Divide two values | `[4, 2, \"@*\"]` |\n  // | **@%**, **@wrap** | Modulo for positive and negative numbers | `[4, -2, \"@%\"]` |\n  // | **@mod* | Standard modulo operation | `[4, 2, \"@mod\"]` |\n  // | **@neg* | The negative of a value | `[4, \"@neg\"]` |\n  // [1, 2, \"@+\"]\n  '@+': op2((b, a) => a + b),\n  // [1, 2, \"@add\"]\n  '@add': '@+',\n  // [2, 1, \"@-\"]\n  '@-': op2((b, a) => a - b),\n  // [2, 1, \"@sub\"]\n  '@sub': '@-',\n  '@*': op2((b, a) => a * b),\n  '@mul': '@*',\n  '@/': op2((b, a) => b === 0 ? 0 : a / b),\n  '@div': '@/',\n  '@%': op2((b, a) => b === 0 ? 0 : wrap(a, b)),\n  '@wrap': '@%',\n  '@mod': op2((b, a) => b === 0 ? 0 : a % b),\n  '@neg': op1(a => -a),\n\n  // ## Logic\n  // **cond**: Conditional execution\n  // `[true, \"@cond\", [<success pattern>], [<fail pattern>]]`\n  '@cond': ({ stack, operations }) => {\n    const test = stack.pop()\n    // this is the pattern to execute if the test passes\n    const success = operations.pop()\n    // the next pattern is the \"else\" part\n    if (test) {\n      // remove the \"else\" part\n      operations.pop()\n      operations.push(success)\n    }\n  },\n  '@>': op2((b, a) => a > b),\n  '@>=': op2((b, a) => a >= b),\n  '@<': op2((b, a) => a < b),\n  '@<=': op2((b, a) => a <= b),\n  '@==': op2((b, a) => a === b),\n  '@!=': op2((b, a) => a !== b),\n  '@!': op1(a => !a),\n  '@not': '@!',\n  '@&&': op2((b, a) => a && b),\n  '@and': '@&&',\n  '@||': op2((b, a) => a || b),\n  '@or': '@||',\n\n  // ## Processes\n\n  // Operation related to interact with the current process\n\n  // | Name | Description | Example |\n  // |------|-------------|---------|\n  // | **@** | Alias of @execute | `10,'dup','@'` |\n  // | **@let** | Assign a value to the local context | `10,'repetitions','@let'` |\n  // | **@set** | Assign a value to the global context | `10,'parts','@set'` |\n  // | **@get** | Push the value of a variable into the stack | `'repetitions','@get'` |\n  // | **@wait** | Wait an amount of time | `1,'@wait'` |\n  // | **@sync** | Wait until next beat | `'@sync'` |\n  // | **@get-rate** | Get the current rate | `'@get-rate'` |\n  // | **@set-rate** | Set the time rate (the speed of time) | `1.5, '@set-rate'` |\n\n  '@let': ({ stack, context }) => context.let(stack.pop(), stack.pop()),\n  '@set': ({ stack, context }) => context.set(stack.pop(), stack.pop()),\n  '@get': ({ stack, context }) => stack.push(context.get(stack.pop())),\n\n  '@wait': proc => proc.wait(Math.abs(Number(proc.stack.pop()))),\n  '@sync': proc => proc.wait(Math.floor(proc.time) + 1 - proc.time),\n\n  '@get-rate': (proc) => proc.stack.push(proc.rate),\n  '@set-rate': (proc) => {\n    const { stack } = proc\n    const rate = parseFloat(stack.pop(), 10)\n    if (rate > 0) proc.rate = rate\n  },\n\n  // ## Execute and repeat\n\n  // | Name | Description | Example |\n  // |------|-------------|---------|\n  // | **@dup** | Duplicate item (so you can use it twice) | `10,'@dup'` |\n  // | **@execute** | Execute an instruction | `10,'dup','@execute'` |\n  // | **@repeat** | Repeat | `4, \"@repeat\", [\"@kick\", 0.5, \"@wait\"]` |\n  // | **@forever** | Repeat forever | `\"@forever\", [\"@kick\", 0.5, \"@wait\"]` |\n  '@dup': ({ stack }) => stack.push(last(stack)),\n  '@execute': ({ operations, error }) => {\n    const instr = operations.pop()\n    if (isString(instr)) operations.push('@instr')\n    else error('@execute', ERR_EXPECT_STRING, instr)\n  },\n  '@': '@execute',\n  '@repeat': ({ stack, operations }) => {\n    const repetitions = stack.pop()\n    const pattern = last(operations)\n    if (!isArray(pattern)) throw Error(\"Can't repeat: \" + pattern)\n    for (let i = 1; i < repetitions; i++) {\n      operations.push(pattern)\n    }\n  },\n  '@forever': ({ operations }) => {\n    const pattern = last(operations)\n    if (!isArray(pattern)) throw Error(\"Can't forover: \" + pattern)\n    if (pattern.length) {\n      operations.push('@forever')\n      operations.push(pattern)\n    }\n  },\n\n  // ## Iteration and lists\n  // | Name | Description | Example |\n  // |------|-------------|---------|\n  // | **@iter** | Iterate a pattern | `[[\"@iter\", [0.3, 1]], \"amp\", \"@set\"]` |\n  '@iter': ({ operations, error }) => {\n    const pattern = operations.pop()\n    if (!isArray(pattern) || !pattern.length) {\n      error('@iter', ERR_EXPECT_PATTERN, pattern)\n    } else {\n      // Rotates the pattern and plays the first item only each time\n      // remove '1st' item, schedule, then push to back:\n      const first = pattern.splice(0, 1)\n      operations.push(first)\n      pattern.push(first)\n    }\n  },\n  '@reverse': ({ operations }) => {}\n}\n\n// Given a commands object, expand the aliases\nexport function expandAliases (commands) {\n  Object.keys(commands).forEach(name => {\n    const op = commands[name]\n    if (isString(op)) commands[name] = commands[op]\n  })\n  return commands\n}\n","// # VM\n\nimport { isArray, isString, isFn } from './utils'\nimport { Process } from './process'\nimport stdlib, {\n  expandAliases,\n  ERR_EXPECT_STRING,\n  ERR_EXPECT_PATTERN\n} from './commands'\n\nconst assign = Object.assign\n\n// The purpose of the VM is to run processes concurrently. It also\n// mantains an extensible object of commands (operations mapped to functions)\n// that allows to add operations to the vm\n\n// TODO: probably is better to have functions and object instead of classes\n// will change in the future.\nexport class VM {\n  constructor (initialContext) {\n    this.context = initialContext\n    this.procs = [] // the procs are inverse ordered by time\n    this.procsByName = {} // a map of names to procs\n    this.time = 0\n    this.commands = createCommands(this)\n    this.addCommands(stdlib)\n  }\n\n  // Run a program\n  run (program, sync = true) {\n    // if there are no processes, no need to sync\n    if (sync && this.procs.length) program = ['@sync', program]\n    this.fork(null, this.context, program)\n  }\n\n  // Add more commands\n  addCommands (commands) {\n    if (isFn(commands)) commands = commands(this)\n    if (commands) assign(this.commands, expandAliases(commands))\n  }\n\n  // Create a new process\n  fork (name, parent, program, delay = 0, rate) {\n    const time = this.time + delay\n    // if has parent and no rate, try to use it's rate\n    if (!rate && parent) rate = parent.rate\n    // if has parent try to use it's context\n    const context = parent ? parent.context || parent : undefined\n    // create the new process and insert into the process stack\n    const proc = new Process(program, context, time, rate)\n    insert(proc, this.procs)\n    // if has name, register it\n    if (name) this.procsByName[name] = proc\n    return proc\n  }\n\n  // run the vm for the given amount of time (Infinity if not specified)\n  resume (dur = Infinity, limit = 10000) {\n    const { procs } = this\n    if (procs.length === 0) return false\n    const time = this.time + dur\n    while (--limit > 0 && at(procs) < time) {\n      const proc = procs.pop()\n      if (proc.resume(this.commands, time)) {\n        // the proc has more operations, re-schedule\n        insert(proc, this.procs)\n      }\n    }\n    this.time = time\n    return procs.length > 0\n  }\n\n  stopAll () {\n    this.procs.length = 0\n  }\n\n  // The stop function can stop a proccess by name or by object\n  stop (proc) {\n    if (typeof proc === 'string') {\n      const name = proc\n      proc = this.procsByName[name]\n      this.procsByName[name] = null\n    }\n    remove(proc, this.procs)\n  }\n}\n\n// ## VM commands\n\n// | Name | Description | Example |\n// |------|-------------|---------|\n// | **@fork** | Fork | `@fork, [0.5, \"@wait\", \"@kick\"]` |\n// | **@spawn** | Spawn | `\"melody\", \"@spawn\", [0.5, \"@wait\", \"@kick\"]` |\n// | **@stop** | Stop current process | `@stop` |\n// | **@stop-all** | Stop all processes | `@stop-all` |\nfunction createCommands (vm) {\n  return {\n    '@loop': proc => {\n      const { operations, error } = proc\n      const pattern = operations.pop()\n      if (isArray(pattern)) vm.fork(null, proc, ['@forever', pattern])\n      else error('@loop', ERR_EXPECT_PATTERN, pattern)\n    },\n    '@fork': proc => {\n      const { operations, error } = proc\n      let pattern = operations.pop()\n\n      if (isArray(pattern)) {\n        vm.fork(null, proc, pattern)\n      } else {\n        error('@fork', ERR_EXPECT_PATTERN, pattern)\n      }\n    },\n    '@spawn': proc => {\n      const { stack, operations, error } = proc\n      const name = stack.pop()\n      let pattern = operations.pop()\n      if (!isString(name)) {\n        error('@spawn', ERR_EXPECT_STRING, name)\n      } else if (!isArray(pattern)) {\n        error('@spawn', ERR_EXPECT_PATTERN, pattern)\n      } else {\n        vm.stop(name)\n        vm.fork(name, proc, ['@forever', pattern])\n      }\n    },\n    '@stop-all': proc => vm.stopAll(),\n    '@stop': ({ stack }) => vm.stop(stack.pop())\n  }\n}\n\n// ## Internal VM functions\n\n// remove a process process\nfunction remove (proc, procs) {\n  let i = procs.length - 1\n  while (i >= 0 && procs[i] !== proc) {\n    i--\n  }\n  // if found, remove it\n  if (i !== -1) procs.splice(i, 1)\n}\n\n// insert a process into a stack ordered by time\n// (in fact, is inverse order because it's a stack)\nfunction insert (proc, procs) {\n  if (procs.length === 0) {\n    // no need to sort: just push it\n    procs.push(proc)\n  } else {\n    // procs are sorted on insertion\n    let i = procs.length - 1\n    let p = procs[i]\n    while (p && p.time <= proc.time) {\n      i--\n      p = procs[i]\n    }\n    procs.splice(i + 1, 0, proc)\n  }\n  return proc\n}\n\n// get time of the next process\nfunction at (procs) {\n  const len = procs.length\n  return len ? procs[len - 1].time : Infinity\n}\n","// # Gibberish audio audio\nimport { isDef } from '../utils'\n\nconst ERR_INST_MISSING = name => `Instrument \"${name}\" not found.`\n\n// Create an object with instrument definitions.\n// The instruments are created lazy\nconst instruments = Gibberish => ({\n  kick: {\n    params: ['amp', 'pitch', 'decay', 'tone'],\n    init: () => new Gibberish.Kick({ decay: 0.2 }).connect()\n  },\n  snare: {\n    params: ['amp', 'tune', 'cutoff', 'snappy'],\n    init: () => new Gibberish.Snare({ snappy: 1.5 }).connect()\n  },\n  hat: {\n    params: ['amp', 'pitch'],\n    init: () => new Gibberish.Hat({ amp: 1.5 }).connect()\n  },\n  conga: {\n    params: ['amp', 'pitch'],\n    init: () => new Gibberish.Conga({ amp: 0.25, freq: 400 }).connect()\n  },\n  clave: {\n    params: ['amp', 'pitch'],\n    init: () => new Gibberish.Clave({ amp: 1 }).connect()\n  },\n  tom: {\n    params: ['amp', 'pitch'],\n    init: () => new Gibberish.Tom({ amp: 0.25, freq: 400 }).connect()\n  },\n  clap: {\n    params: ['amp'],\n    init: () => new Gibberish.Clap({ amp: 0.5 }).connect()\n  },\n  cowbell: {\n    params: ['amp', 'pitch'],\n    init: () => new Gibberish.Cowbell({ amp: 0.5 }).connect()\n  },\n  pluck: {\n    params: ['freq', 'amp', 'blend', 'damping', 'velocity'],\n    init: () => new Gibberish.PolyKarplusStrong({ maxVoices: 32 }).connect(),\n    prepare: (inst, context) => {\n      const freq = context.get('freq')\n      if (freq > 0) {\n        inst.freq = freq\n        inst.damping = 1 - (-6) / Math.log(freq / Gibberish.sampleRate)\n      }\n      const amp = context.get('amp')\n      if (amp) inst.amp = amp * amp * 0.5\n      const blend = context.get('blend')\n      if (blend) inst.blend = blend\n    }\n  },\n  bass: {\n    params: ['freq', 'amp', 'resonance'],\n    init: () => new Gibberish.MonoSynth({\n      attack: 44,\n      decay: Gibberish.Time.beats(0.25),\n      filterMult: 0.25,\n      octave2: 0,\n      octave3: 0\n    }).connect()\n  }\n})\n\n// ## Audio commands\n\n// | Name | Description | Example |\n// |------|-------------|---------|\n// | **@get-bpm** | Get the global tempo value | `'@pick', [1.25, 1.5, 0.75], '@get-bpm', '@*', '@set-bpm'` |\n// | **@set-bpm** | Change the global tempo | `120, \"@set-bpm\"` |\n// | **@play-note** | Trigger a note with params | `{ inst: \"pluck\", amp: 0.5}, \"@note-params\"` |\n// | **@play** | Trigger a note | `\"@note\"` |\nconst initCommands = audio => ({\n  '@play': ({ context, error }) => {\n    const err = play(context, audio)\n    if (err) error('@play', err)\n  },\n  '@play-note': ({ stack, context, error }) => {\n    const props = stack.pop()\n    const err = play(context.child(props), audio)\n    if (err) error('@play-note', err)\n  },\n  '@get-bpm': ({ stack }) => stack.push(audio.bpm),\n  '@set-bpm': ({ stack }) => {\n    const bpm = parseFloat(stack.pop(), 10)\n    audio.bpm = bpm\n  }\n})\n\nexport default function init (Gibberish, options = {}) {\n  const audio = initAudioDriver(Gibberish, options)\n  audio.instruments = initInstruments(instruments(Gibberish))\n  audio.commands = initCommands(audio)\n  Gibberish.sequencers.push(sequencer(audio))\n\n  return function (vm) {\n    // Add the vm to the list of VMs\n    audio.vms.push(vm)\n    // Set the audio property to the audio driver\n    vm.audio = audio\n    return audio.commands\n  }\n}\n\n// Prepare the instruments object. Replace the params with prepare\nfunction initInstruments (instruments) {\n  Object.keys(instruments).forEach(name => {\n    const inst = instruments[name]\n    if (!inst.prepare) {\n      const params = inst.params || []\n      inst.prepare = (inst, context) => {\n        params.forEach(param => {\n          let value = context.get(param)\n          if (isDef(value)) {\n            inst[param] = value\n          }\n        })\n      }\n    }\n  })\n  return instruments\n}\n\nfunction sequencer (audio) {\n  const { vms, bpm2bpa } = audio\n  return {\n    tick () {\n      const len = audio.vms.length\n      if (len === 0) return\n      const dur = audio.bpm * bpm2bpa\n      for (let i = 0; i < len; i++) {\n        vms[i].resume(dur)\n      }\n    }\n  }\n}\n\n// Trigger an instrument\nconst play = (context, audio) => {\n  const { instruments } = audio\n  const instName = context.get('inst')\n  const instrument = instruments[instName]\n  if (!instrument) return ERR_INST_MISSING(instName)\n  if (!instrument.instance) instrument.instance = instrument.init()\n\n  const inst = instrument.instance\n  instrument.prepare(inst, context)\n  inst.freq ? inst.note(inst.freq) : inst.note()\n}\n\n// Init the audio driver\nfunction initAudioDriver (Gibberish, { bpm = 100 }) {\n  if (!Gibberish.context) Gibberish.init()\n  return {\n    Gibberish,\n    bpm: bpm,\n    sampleRate: Gibberish.context.sampleRate,\n    bpm2bpa: 1 / (60 * Gibberish.context.sampleRate),\n    vms: []\n  }\n}\n","// ## Randomness\nimport { isArray } from '../utils'\nconst { floor } = Math\n\n// | Name | Description | Example |\n// |------|-------------|---------|\n// | **@random** | Generate a random number between 0 and 1 | `[\"@random\", \"amp\", \"@set\"]` |\n// | **@rand** | Alias for @random | |\n// | **@srandom** | Generate a random number between -1 and 1 | `[\"@srandom\", \"phase\", \"@set\"]` |\n// | **@srand** | Alias for @srandom | |\n// | **@randi** | Generate a random integer between 0 and n | `[60, \"@randi\", \"midi\", \"@set\"]` |\n// | **@pick** | Pick a random element from a list | `[\"@pick\", [1, 2, 3, 4]]` |\n// | **@chance** | Probabilistic execution | `probability, \"@chance\", executed-if-true, executed-if-false` |\nexport default function random (random) {\n  // allow to use a custom random function\n  const rnd = random || Math.random\n  // a function that generates integer random from 0 to n\n  const irnd = n => floor(rnd() * n)\n\n  return {\n    '@random': ({ stack }) => stack.push(rnd()),\n    '@rand': '@random',\n    '@srandom': ({ stack }) => stack.push(rnd() * 2 - 1),\n    '@srand': '@srandom',\n    '@randi': ({ stack }) => stack.push(irnd(stack.pop())),\n    '@pick': proc => {\n      const { operations, error } = proc\n      const pattern = operations.pop()\n      if (!isArray(pattern)) {\n        operations.push(pattern)\n        error(\"Can't pick an element if is not an array\", pattern)\n      } else {\n        const i = irnd(pattern.length)\n        operations.push(pattern[i])\n      }\n    },\n    '@chance': ({ stack, operations }) => {\n      const prob = stack.pop()\n      const pattern = operations.pop()\n      if (rnd() < prob) {\n        // Skip item after\n        operations.pop()\n        // Push the pattern\n        operations.push(pattern)\n      }\n    }\n  }\n}\n","// # Debug operations\nimport { peek } from '../utils'\n\n// | Name | Description | Example |\n// |------|-------------|---------|\n// | **@print** | Print the last value of the stack | `10,\"@print\"` |\n// | **@log** | Log the name with the last value of the stack | `\"@random\", \"amp\", \"@log\"` |\nexport default function debug (log) {\n  log = log || console.log.bind(console)\n\n  return {\n    '@print': proc => {\n      const { stack } = proc\n      const last = stack.length ? peek(stack) : '<Empty Stack>'\n      log('@print', last, '(id, time)', proc.id, proc.time)\n    },\n    '@log': proc => {\n      const { stack } = proc\n      const name = stack.pop()\n      const last = stack.length ? peek(stack) : '<Empty Stack>'\n      log('@log', name, last, '(id, time)', proc.id, proc.time)\n    },\n    '@debug': proc => {\n      const { stack } = proc\n      log('@debug', stack, proc.id, proc.time)\n    }\n  }\n}\n","// # Compatibility plugin\n\n// This plugin adds language compatibility to the previous version\n\nconst inst = name => ({ operations }) => {\n  operations.push([{ inst: name }, '@play-note'])\n}\nconst instNote = (name, p1, p2) => ({ stack, operations }) => {\n  const props = { inst: name }\n  if (p2) props[p2] = stack.pop()\n  props[p1] = stack.pop()\n  operations.push([props, '@play-note'])\n}\n\nexport default function init () {\n  return {\n    '@pluck': inst('pluck'),\n    '@pluck-note': instNote('pluck', 'freq', 'amp'),\n    '@bass': inst('bass'),\n    '@bass-note': instNote('bass', 'freq', 'amp'),\n    '@hat': inst('hat'),\n    '@hat-note': instNote('hat', 'amp'),\n    '@kick': inst('kick'),\n    '@kick-note': instNote('kick', 'amp'),\n    '@snare': inst('snare'),\n    '@snare-note': instNote('snare', 'amp'),\n    '@conga': inst('conga'),\n    '@conga-note': instNote('conga', 'amp'),\n    '@clave': inst('clave'),\n    '@clave-note': instNote('clave', 'amp'),\n    '@tom': inst('tom'),\n    '@tom-note': instNote('tom', 'amp')\n  }\n}\n","// # Audio Scheduler Virtual Machine\nimport { VM } from './vm'\nimport gibberish from './audio/gibberish'\nimport random from './ext/random'\nimport debug from './ext/debug'\nimport compatibility from './ext/compatibility'\n\n// ## Architecture Overview\n\n// The main purpose of the virtual machine is to run processes concurrently.\n// It holds a `commands` object (that maps instruction names to functions)\n// and schedules a collection of `processes`. Each **process** has an values `stack`\n// and `operations` stack (to be executed).\n\n// ## API\n\n// the init function creates a vm controlled by Gibberish\nexport function init (Gibberish, ...plugins) {\n  // Create the virtual machine\n  const vm = new VM({ amp: 0.5, freq: 440 })\n  // Init the audio driver and use its commands\n  vm.addCommands(gibberish(Gibberish))\n  // Include all the command extensions\n  vm.addCommands(random())\n  vm.addCommands(debug())\n  vm.addCommands(compatibility())\n  // Add the plugins if any\n  plugins.forEach(cmds => vm.addCommands(cmds))\n\n  return vm\n}\n","// # TimeVM utilities\n\n// copy values from one or more sources to a target\n// see: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\nexport const assign = Object.assign\n\n// test if an object is an array\nexport const isArray = Array.isArray\n\n// test if  is a string\nexport const isString = x => typeof x === 'string'\n\n// test if  is a function\nexport const isFn = x => typeof x === 'function'\n\n// test if  is defined\nexport const isDef = x => typeof x !== 'undefined'\n\n// get last element from an array\nexport const last = a => a[a.length - 1]\n// take the next element of stack without remove it\nexport const peek = last\n\n// A modulo operation that handles negative n more appropriately\n// e.g. wrap(-1, 3) returns 2\n// see http://en.wikipedia.org/wiki/Modulo_operation\n// see also http://jsperf.com/modulo-for-negative-numbers\nexport const wrap = (a, b) => (a % b + b) % b\n","// # Process\n\nconst isCommand = o => typeof o === 'string' && o[0] === '@'\nconst isProgram = Array.isArray\nlet procId = 1\nconst ERR_INSTR_NOT_FOUND = 'Instruction not recognized.'\nconst ERR_LIMIT_REACHED = 'Limit reached. Probably an infinity loop.'\n\n// Processes are the principal computation unit. It departures from typical\n// processes in that it model the concept of time\nexport class Process {\n  constructor (program, context, time, rate) {\n    this.id = 'proc-' + procId++\n    // a stack of values\n    this.stack = []\n    // the operations are stored in a stack (in reverse order)\n    this.operations = program ? [program] : []\n    // the context is used to store variables with scope\n    this.context = new Context(context)\n    // the current time\n    this.time = typeof time === 'number' ? time : 0\n    // how fast time passes\n    this.rate = typeof rate === 'number' ? rate : 1\n    // bind error to allow destructuring in commands\n    this.error = this.error.bind(this)\n  }\n\n  // wait an amount of time\n  wait (time) {\n    this.time += this.rate * time\n  }\n\n  // The process is agnostic about the commands to be use\n  step (commands) {\n    const { operations } = this\n    if (operations.length) {\n      const instr = operations.pop()\n      if (instr === null || instr === undefined) {\n        // ignore\n      } else if (typeof instruction === 'function') {\n        // functions can be scheduled too\n        instr()\n      } else if (isProgram(instr)) {\n        // if it's program, and since the operations are stored into an stack,\n        // we need add to the program operations in reverse order\n        for (let i = instr.length - 1; i >= 0; i--) {\n          operations.push(instr[i])\n        }\n      } else if (isCommand(instr)) {\n        const cmd = commands[instr]\n        if (typeof cmd === 'function') cmd(this)\n        else this.error('', ERR_INSTR_NOT_FOUND, instr)\n      } else {\n        // if it's a value, push it into the stack\n        this.stack.push(instr)\n      }\n    }\n  }\n\n  // the `resume` function run all the operations until time is reached\n  resume (commands, time = Infinity, limit = 10000) {\n    const { operations } = this\n    while (--limit > 0 && this.time < time && operations.length) {\n      this.step(commands)\n    }\n    if (limit === 0) throw Error(ERR_LIMIT_REACHED)\n    return operations.length > 0\n  }\n\n  // an utility function to write errors\n  error (instr, msg, obj) {\n    console.error(instr, msg, obj, 'id', this.id, 'time', this.time)\n  }\n}\n\n// ## Context\n\n// A context is a hierarchical structure to store values with scope\nexport class Context {\n  constructor (parent) {\n    if (parent instanceof Context) this.parent = parent\n    else if (parent) this.local = Object.assign({}, parent)\n  }\n\n  // Create a child\n  child (local) {\n    const c = new Context(this)\n    c.local = Object.assign({}, local)\n    return c\n  }\n  // get a value from a context\n  get (id) {\n    let target = this\n    while (target.value(id) === undefined && target.parent) {\n      target = target.parent\n    }\n    return target.value(id)\n  }\n\n  // set a value from a context\n  set (id, value) {\n    let target = this\n    while (target.value(id) === undefined && target.parent) {\n      target = target.parent\n    }\n    target.let(id, value)\n  }\n  // get a value from the local scope of a context\n  value (id) {\n    return this.local ? this.local[id] : undefined\n  }\n\n  // set a value into the local scope of a context\n  let (id, value) {\n    if (!this.local) this.local = {}\n    this.local[id] = value\n  }\n}\n"],"names":["expandAliases","commands","keys","forEach","op","name","isString","createCommands","vm","operations","proc","error","pattern","pop","isArray","fork","ERR_EXPECT_PATTERN","stack","stop","ERR_EXPECT_STRING","stopAll","remove","procs","i","length","splice","insert","push","p","time","at","len","Infinity","init","Gibberish","options","audio","initAudioDriver","instruments","initInstruments","initCommands","sequencers","sequencer","vms","inst","prepare","params","context","value","get","param","isDef","bpm2bpa","dur","bpm","resume","sampleRate","random","rnd","Math","irnd","floor","n","prob","debug","log","console","bind","peek","id","instNote","VM","amp","freq","addCommands","gibberish","compatibility","plugins","cmds","Array","x","isFn","last","a","wrap","b","isCommand","o","isProgram","procId","Process","program","rate","Context","this","instr","undefined","instruction","cmd","limit","step","Error","msg","obj","parent","local","Object","assign","c","target","let","op1","fn","op2","test","success","set","wait","abs","Number","parseFloat","repetitions","first","initialContext","procsByName","stdlib","delay","ERR_INST_MISSING","Kick","decay","connect","Snare","snappy","Hat","Conga","Clave","Tom","Clap","Cowbell","PolyKarplusStrong","maxVoices","damping","blend","MonoSynth","Time","beats","err","play","props","child","instName","instrument","instance","note","p1","p2"],"mappings":"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"}
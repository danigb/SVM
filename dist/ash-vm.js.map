{"version":3,"file":"ash-vm.js","sources":["../src/scheduler.js","../src/commands.js","../src/stdlib/random.js","../src/stdlib/index.js","../src/audio/gibberish.js","../src/index.js","../src/context.js","../src/process.js","../src/events.js","../src/utils.js","../src/stdlib/core.js","../src/stdlib/errors.js","../src/stdlib/audio.js","../src/stdlib/iterables.js","../src/stdlib/execution.js","../src/stdlib/process.js","../src/stdlib/schedule.js","../src/stdlib/context.js","../src/stdlib/debug.js","../src/stdlib/utilities.js","../src/vm.js","../src/audio-driver.js"],"sourcesContent":["// # Scheduler\nimport Process from \"./process\"\nimport Events from \"./events\"\n\n// The purpose of the Scheduler is to run processes concurrently.\nexport default class Scheduler {\n  constructor (options = {}) {\n    this.procs = [] // the procs are inverse ordered by time\n    this.procsByName = {} // a map of names to procs\n    this.time = 0\n    this.events = new Events()\n    if (options.events) this.events.register(options.events)\n  }\n\n  // Create a new process\n  fork (name, parent, program, delay = 0, rate) {\n    const time = this.time + delay\n    // if has parent and no rate, try to use it\"s rate\n    if (!rate && parent) rate = parent.rate\n    // if has parent try to use it\"s context\n    const context = parent ? parent.context || parent : undefined\n    // create the new process and insert into the process stack\n    const proc = new Process(program, context, time, rate)\n    insert(proc, this.procs)\n    // if has name, register it\n    if (name) this.procsByName[name] = proc\n    this.events.emit(\"fork\", proc)\n    return proc\n  }\n\n  // run the vm for the given amount of time (Infinity if not specified)\n  resume (commands, dur = Infinity, limit = 10000) {\n    const { procs } = this\n    if (procs.length > 0) {\n      const nextTime = this.time + dur\n      while (--limit > 0 && at(procs) < nextTime) {\n        const proc = procs.pop()\n        if (proc.resume(commands, nextTime)) {\n          // the proc has more operations, re-schedule\n          insert(proc, this.procs)\n        } else {\n          this.events.emit(\"ended\", { proc, time: this.time })\n        }\n      }\n      this.time = nextTime\n    } else {\n      this.time += dur\n    }\n    return procs.length > 0\n  }\n\n  stopAll () {\n    this.procs.length = 0\n  }\n\n  // The stop function can stop a proccess by name or by object\n  stop (name) {\n    let proc\n    if (typeof proc === \"string\") {\n      proc = this.procsByName[name]\n      this.procsByName[name] = null\n    } else {\n      proc = name\n      name = null\n    }\n\n    this.events.emit(\"stop\", { proc })\n\n    remove(proc, this.procs)\n  }\n}\n\n// **~~private~~**\n\n// remove a process process\nfunction remove (proc, procs) {\n  let i = procs.length - 1\n  while (i >= 0 && procs[i] !== proc) {\n    i--\n  }\n  // if found, remove it\n  if (i !== -1) procs.splice(i, 1)\n  return i !== -1\n}\n\n// insert a process into a stack ordered by time\n// (in fact, is inverse order because it\"s a stack)\nfunction insert (proc, procs) {\n  if (procs.length === 0) {\n    // no need to sort: just push it\n    procs.push(proc)\n  } else {\n    // procs are sorted on insertion\n    let i = procs.length - 1\n    let p = procs[i]\n    while (p && p.time <= proc.time) {\n      i--\n      p = procs[i]\n    }\n    procs.splice(i + 1, 0, proc)\n  }\n  return proc\n}\n\n// get time of the next process\nfunction at (procs) {\n  const len = procs.length\n  return len ? procs[len - 1].time : Infinity\n}\n","// # Commands\nimport { isArray } from \"./utils\"\n// test if the given operation is an instruction name\nconst isCommand = o => typeof o === \"string\" && o[0] === \"@\"\n\n// The Commands resolves a `@command` string into a functions\nexport default class Commands {\n  constructor (commands = []) {\n    this.operators = []\n    this.add(commands)\n  }\n\n  // Add commands to this one\n  // commands can be functions or maps\n  add (commands) {\n    if (isArray(commands)) {\n      let len = commands.length\n      while (len--) this.add(commands[len])\n    } else {\n      this.operators.push(toOperator(commands))\n    }\n    return this\n  }\n\n  // Given a command, return its operation\n  resolve (command) {\n    const { operators } = this\n    let len = operators.length\n    while (len--) {\n      const compiled = operators[len](command)\n      if (compiled) return compiled\n    }\n  }\n}\n\n// Compile a program: convert all @commands into functions\n// This allows to:\n// 1. Detect syntax errors in an early stage\n// 2. Improve performance\nexport function compile (program, commands, strict = false) {\n  return program.map(instruction => {\n    if (isArray(instruction)) {\n      return compile(instruction, commands, strict)\n    } if (isCommand(instruction)) {\n      const fn = commands.resolve(instruction)\n      if (fn) return fn\n      else if (strict) throw Error(\"Command not found: \" + instruction)\n    } else {\n      return instruction\n    }\n  })\n}\n\n// #### ~~private~~\n\n// An operator is a function that given a @command, returns a compiled function\nfunction toOperator (obj) {\n  if (typeof obj === \"function\") return obj\n  else if (typeof obj === \"object\") return mapToOperator(obj)\n  else throw Error(\"Invalid operator: \" + obj)\n}\n\n// Convert a map into a function\nfunction mapToOperator (map) {\n  return function (cmd) {\n    const op = map[cmd]\n    if (typeof op === \"string\") return map[op]\n    else return op\n  }\n}\n","// ## Random\nimport { isArray } from \"../utils\"\nimport { ERR_EXPECT_PATTERN } from \"./errors\"\nconst { floor } = Math\n\n// A collection of commands related to randomness\n\n// #### Commands\nexport default function random ({ random } = {}) {\n  // allow to use a custom random function\n  const rnd = random || Math.random\n  // a function that generates integer random from 0 to n\n  const irnd = n => floor(rnd() * n)\n\n  const shuffle = a => {\n    var j, x, i\n    for (i = a.length; i; i--) {\n      j = floor(random() * i)\n      x = a[i - 1]\n      a[i - 1] = a[j]\n      a[j] = x\n    }\n  }\n\n  return {\n    // **@random**: Generate a random number between 0 and 1\n    // `[\"@random\", \"amp\", \"@set\"]`\n    \"@random\": ({ stack }) => stack.push(rnd()),\n\n    // **@rand**: Alias for @random\n    \"@rand\": \"@random\",\n\n    // **@srandom**: Generate a random number between -1 and 1\n    // `[\"@srandom\", \"phase\", \"@set\"]`\n    \"@srandom\": ({ stack }) => stack.push(rnd() * 2 - 1),\n\n    // **@srand**: Alias for @srandom\n    \"@srand\": \"@srandom\",\n\n    // **@randi**: Generate a random integer between 0 and n\n    // `[40, \"@randi\", 20, \"@+\", \"@mtof\", \"freq\", \"@set\"]`\n    \"@randi\": ({ stack }) => stack.push(irnd(stack.pop())),\n\n    // **@pick**: pick a random element from a list\n    // `[\"@list\", [1, 2, 3, 4], \"@pick\", \"amp\", \"@set\"]`\n    \"@pick\": ({ stack, error }) => {\n      const list = stack.pop()\n      if (!isArray(list)) {\n        error(\"Can't pick an element if is not an array\", list)\n      } else {\n        const i = irnd(list.length)\n        stack.push(list[i])\n      }\n    },\n\n    // **@chance* *: Probabilistic execution\n    // [probability, \"@chance\", executed-if-true, executed-if-false]\n    // `[0.5, \"@chance\", [440, \"freq\", \"@set\"], [\"@rand\", \"amp\", \"@set\"]]`\n    \"@chance\": ({ stack, operations }) => {\n      const prob = stack.pop()\n      const ifTrue = operations.pop()\n      if (rnd() < prob) {\n        // Skip the 'false branch'\n        operations.pop()\n        // Set the 'true branch' as the next operation\n        operations.push(ifTrue)\n      } else {\n        // The 'false branch' is currenty the next operation\n        // so there's no need to do anything\n      }\n    },\n\n    // **@shuffle**: Shuffle a list\n    // `[\"@list\", [1, 2, 3], \"@shuffle\", \"@iter\"]`\n    \"@shuffle\": ({ stack, error }) => {\n      const pattern = stack.pop()\n      if (!isArray(pattern)) error(\"@shuffle\", ERR_EXPECT_PATTERN, pattern)\n      else stack.push(shuffle(pattern))\n    }\n  }\n}\n","// # Standard library\nimport Commands from \"../commands\"\nimport core from \"./core\"\nimport audio from \"./audio\"\nimport iterables from \"./iterables\"\nimport execution from \"./execution\"\nimport process from \"./process\"\nimport schedule from \"./schedule\"\nimport context from \"./context\"\nimport random from \"./random\"\nimport debug from \"./debug\"\nimport utilities from \"./utilities\"\n\n// The standard lib include all the modules\nexport default function stdlib (driver, scheduler, options = {}) {\n  return new Commands([\n    core,\n    iterables,\n    execution,\n    process,\n    context,\n    audio(driver),\n    schedule(scheduler),\n    random(options),\n    debug(options),\n    utilities,\n  ])\n}\n","// # Gibberish Audio Driver\nimport AudioDriver from \"../audio-driver\"\n\n// This driver uses Gibberish both for scheduling and sounds\n\nexport default class GibberishDriver extends AudioDriver {\n  constructor (Gibberish, { bpm = 100 } = {}) {\n    if (!Gibberish.context) Gibberish.init()\n    super(bpm, Gibberish.context.sampleRate)\n    this.Gibberish = Gibberish\n    this.instruments = createInstruments(Gibberish)\n  }\n\n  // Start a VM\n  start (scheduler) {\n    super.start(scheduler)\n    // convert bmp to beats per audio sample\n    const bpm2bpa = 1 / (60 * this.sampleRate)\n    // tick is binded to this\n    const tick = () => {\n      scheduler.resume(this.bpm * bpm2bpa)\n    }\n    this.Gibberish.sequencers.push({ tick })\n  }\n}\n\n// # Instruments\n\n// Create a trigger function for a percussion instrument\nconst perc = (inst, gain) => (ctx) => {\n  inst.amp = gain * ctx.get(\"amp\")\n  inst.note()\n}\n\n// Create a trigger function for a tuned percussion instrument\nconst pitched = (inst, gain) => (ctx) => {\n  inst.amp = gain * ctx.get(\"amp\")\n  inst.pitch = ctx.get(\"freq\")\n  inst.note()\n}\n\n// Create the basic instruments using Gibberish\nfunction createInstruments (Gibberish) {\n  // The actual instruments\n  const kick = new Gibberish.Kick({ decay: 0.2 }).connect()\n  const snare = new Gibberish.Snare({ snappy: 1.5 }).connect()\n  const hat = new Gibberish.Hat({ amp: 1.5 }).connect()\n  const conga = new Gibberish.Conga({ amp: 0.25, freq: 400 }).connect()\n  const tom = new Gibberish.Tom({ amp: 0.25, freq: 400 }).connect()\n  const pluck = new Gibberish.PolyKarplusStrong({maxVoices: 32}).connect()\n  const bass = new Gibberish.MonoSynth({\n    attack: 44,\n    decay: Gibberish.Time.beats(0.25),\n    filterMult: 0.25,\n    octave2: 0,\n    octave3: 0\n  }).connect()\n  const sampleRate = Gibberish.sampleRate\n\n  // The instrument trigger functions\n  return {\n    kick: perc(kick, 0.5),\n    snare: perc(snare, 0.25),\n    hat: perc(hat, 1),\n    conga: pitched(conga, 0.25),\n    tom: pitched(tom, 0.25),\n    pluck: (ctx) => {\n      const amp = ctx.get(\"amp\")\n      const freq = ctx.get(\"freq\")\n      if (freq > 0) {\n        // this is not in any way accurate, just a hack to make @set-dur do something semi-meaningful\n        pluck.damping = 1 - (-6 / Math.log(freq / sampleRate))\n        // pluck by default seem too quiet:\n        pluck.note(freq, amp * amp * 2)\n      }\n    },\n    bass: (ctx) => {\n      const velocity = ctx.get(\"amp\")\n      const freq = ctx.get(\"freq\")\n      if (freq > 0) bass.note(freq, velocity)\n    }\n  }\n}\n","// # Audio Scheduler Virtual Machine\nimport VM from \"./vm\"\nimport GibDriver from \"./audio/gibberish\"\n// import waa from \"./audio/waa\"\n\n// ## Architecture overview\n\n// **Glossary**\n// - **Command**: a string that starts with `@` mapped to a function\n// - **Program**: a list of commands and values\n\n// **Classes**\n// - **Process**: execute programs (by inserting values into stack and executing the command function)\n// - **Scheduler**: run processes concurrently\n// - **Commands**: translate commands to functions\n// - **AudioDriver**: controls the scheduler. Create instruments.\n// - **VM**: holds all above and provide API functions\n\n// ## API\n// Create a VM with Gibberish audio driver\nexport function initGibberish (Gibberish, options) {\n  const driver = new GibDriver(Gibberish, options)\n  return new VM(driver, options)\n}\n\n// Create a VM with WAA audio driver\nexport function initWebAudio (context, options) {\n}\n","// # Context\n\n// A context is a hierarchical structure to store values with different\n// scopes. Every process has it's own context.\nexport default class Context {\n  // Every context has a parent. The parent can be another context\n  // or an object\n  constructor (parent) {\n    if (parent instanceof Context) this.parent = parent\n    else if (parent) this.local = Object.assign({}, parent)\n  }\n\n  // Create a child context with the given locals\n  child (local) {\n    const c = new Context(this)\n    if (local) c.local = Object.assign({}, local)\n    return c\n  }\n  // get a value from a context\n  get (id) {\n    let target = this\n    while (target.value(id) === undefined && target.parent) {\n      target = target.parent\n    }\n    return target.value(id)\n  }\n\n  // set a value from a context\n  set (id, value) {\n    let target = this\n    while (target.value(id) === undefined && target.parent) {\n      target = target.parent\n    }\n    target.let(id, value)\n  }\n\n  // get a value from the local scope of a context\n  value (id) {\n    return this.local ? this.local[id] : undefined\n  }\n\n  // set a value into the local scope of a context\n  let (id, value) {\n    if (!this.local) this.local = {}\n    this.local[id] = value\n  }\n}\n","// # Process\nimport Context from \"./context\"\n\n// #### Utilities\n// test if the given operation is an instruction name\nconst isCommand = o => typeof o === \"string\" && o[0] === \"@\"\n// test if the given operation is a program\nconst isProgram = Array.isArray\n// Give unique ids to process\nlet procId = 1\n\n// #### Error messages\n\n// The given instruction name is not in the commands object\nconst ERR_INSTR_NOT_FOUND = \"Instruction not recognized.\"\n// The max loop cycles tests\nconst ERR_LIMIT_REACHED = \"Limit reached. Probably an infinity loop.\"\n\n// ## Process\n\n// Processes are the principal computation unit. The main characteristic of\n// processes in this VM is that it models the concept of time\nexport default class Process {\n  constructor (program, context, time, rate) {\n    this.id = \"proc-\" + procId++\n    // a stack of values\n    this.stack = []\n    // the operations are also stored in a stack (reverse order)\n    this.operations = program ? [program] : []\n    // the context is used to store variables with scope\n    this.context = new Context(context)\n    // the current time\n    this.time = typeof time === \"number\" ? time : 0\n    // how fast time passes\n    this.rate = typeof rate === \"number\" ? rate : 1\n    // bind error to this, to allow destructuring it in commands\n    this.error = this.error.bind(this)\n  }\n\n  // wait an amount of time\n  wait (time) {\n    this.time += this.rate * time\n  }\n\n  // The process is agnostic about the commands to interpret\n  step (commands) {\n    const { operations } = this\n    if (operations.length) {\n      const instr = operations.pop()\n      if (instr === null || instr === undefined) {\n        // ignore\n      } else if (typeof instr === \"function\") {\n        instr(this)\n      } else if (isProgram(instr)) {\n        // if it\"s program, and since the operations are stored into an stack,\n        // we need add to the program operations in reverse order\n        for (let i = instr.length - 1; i >= 0; i--) {\n          operations.push(instr[i])\n        }\n      } else if (isCommand(instr)) {\n        const cmd = commands.resolve(instr)\n        if (typeof cmd === \"function\") cmd(this)\n        else this.error(\"step > \", ERR_INSTR_NOT_FOUND, instr)\n      } else {\n        // if it\"s a value, push it into the stack\n        this.stack.push(instr)\n      }\n    }\n  }\n\n  // the `resume` function run all the operations until time is reached\n  resume (commands, time = Infinity, limit = 10000) {\n    const { operations } = this\n    while (--limit > 0 && this.time < time && operations.length) {\n      this.step(commands)\n    }\n    if (limit === 0) throw Error(ERR_LIMIT_REACHED)\n    return operations.length > 0\n  }\n\n  // an utility function to write errors\n  error (instr, msg, obj) {\n    console.error(instr, msg, obj, \"id\", this.id, \"time\", this.time)\n  }\n}\n","\nconst get = (all, type) => all[type] || (all[type] = [])\n\nexport default class Events {\n  constructor () {\n    this.all = {}\n  }\n  register (events) {\n    Object.keys(events).forEach(type => this.on(type, events[type]))\n  }\n  on (type, handler) {\n    get(this.all, type).push(handler)\n  }\n  emit (type, event) {\n    get(this.all, type).map(handler => handler(event))\n    get(this.all, \"*\").map(handler => handler(type, event))\n  }\n}\n","// # Utilities\n\n// A collection of shared utility functions\n\n// copy values from one or more sources to a target\n// see: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\nexport const assign = Object.assign\n\n// test if an object is an array\nexport const isArray = Array.isArray\n\n// test if an object is a string\nexport const isString = x => typeof x === \"string\"\n\n// test if an object is a function\nexport const isFn = x => typeof x === \"function\"\n\n// test if an object is a number\nexport const isNum = x => typeof x === \"number\"\n\n// test if an object is defined\nexport const isDef = x => typeof x !== \"undefined\"\n\n// get last element from an array\nexport const last = a => a[a.length - 1]\n\n// get the next element of stack without remove it\nexport const peek = last\n","// # Core\n\n// **wrap**: A modulo operation that handles negative n more appropriately\n// e.g. wrap(-1, 3) returns 2\n// see http://en.wikipedia.org/wiki/Modulo_operation\n// see also http://jsperf.com/modulo-for-negative-numbers\nexport const wrap = (a, b) => (a % b + b) % b\n\n// **op1**: A generic stack operation that pops one value and pushes on result\nexport const op1 = fn => ({ stack }) => {\n  stack.push(fn(stack.pop()))\n}\n\n// **op2**: A generic stack operation that pops two values and pushes one result\nexport const op2 = fn => ({ stack }) => {\n  stack.push(fn(stack.pop(), stack.pop()))\n}\n\n// The core of stdlib commands. It include arithmetic, logic,\n// execution and repetition\n\nexport default {\n  // ## Arithmetic\n  // Arithmetic operation commands\n\n  // **@+**, **@add**: Add two values\n  // `[1, 2, \"@+\"]`\n  \"@+\": op2((b, a) => a + b),\n  \"@add\": \"@+\",\n\n  // **@-**, **@sub**: Subtract two values\n  // `[2, 1, \"@-\"]`\n  \"@-\": op2((b, a) => a - b),\n  \"@sub\": \"@-\",\n\n  // **@\\***, **@mul**: Multiply two values\n  // `[2, 4, \"@*\"]`\n  \"@*\": op2((b, a) => a * b),\n  \"@mul\": \"@*\",\n\n  // **@/**, **@div**: Divide two values\n  // `[4, 2, \"@/\"]`\n  \"@/\": op2((b, a) => b === 0 ? 0 : a / b),\n  \"@div\": \"@/\",\n\n  // **@%**, **@wrap**: Modulo for positive and negative numbers\n  // `[4, -2, \"@%\"]`\n  \"@%\": op2((b, a) => b === 0 ? 0 : wrap(a, b)),\n  \"@wrap\": \"@%\",\n\n  // **@mod**: Standard modulo operation\n  // `[4, 2, \"@mod\"]`\n  \"@mod\": op2((b, a) => b === 0 ? 0 : a % b),\n\n  // **@neg**: The negative of a value\n  // `[4, \"@neg\"]`\n  \"@neg\": op1(a => -a),\n\n  // ## Logic\n  // Logic commands, including conditional execution\n\n  // **@cond**: Conditional execution\n  // `[true, \"@cond\", [<success pattern>], [<fail pattern>]]`\n  \"@cond\": ({ stack, operations }) => {\n    const test = stack.pop()\n    // this is the pattern to execute if the test passes\n    const success = operations.pop()\n    // the next pattern is the \"else\" part\n    if (test) {\n      // remove the \"else\" part\n      operations.pop()\n      operations.push(success)\n    }\n  },\n\n  // **@>**: Greater than\n  \"@>\": op2((b, a) => a > b),\n\n  // **@>=**: Greater or equal than\n  \"@>=\": op2((b, a) => a >= b),\n\n  // **@<**: Less than\n  \"@<\": op2((b, a) => a < b),\n\n  // **@<=**: Less or equal than\n  \"@<=\": op2((b, a) => a <= b),\n\n  // **@==**: Is equal\n  \"@==\": op2((b, a) => a === b),\n\n  // **@!=**: Is not equal\n  \"@!=\": op2((b, a) => a !== b),\n  \"@!\": op1(a => !a),\n\n  // **@!**: Logic not\n  \"@not\": \"@!\",\n\n  // **@&&**, **@and**: Logic and\n  \"@&&\": op2((b, a) => a && b),\n  \"@and\": \"@&&\",\n\n  // **@||**, **@or**: Logic or\n  \"@||\": op2((b, a) => a || b),\n  \"@or\": \"@||\",\n}\n","// # Errors\n\n// A shared errors messages\nexport const ERR_EXPECT_PATTERN = \"Expected a pattern, but found:\"\nexport const ERR_EXPECT_LIST = \"Expected a iterable list, but found:\"\nexport const ERR_EXPECT_STRING = \"Expected a string, but found:\"\nexport const ERR_INST_MISSING = \"Instrument not found:\"\nexport const ERR_EXPECT_NUM = \"Expected a number, but found:\"\n","// # Audio\nimport { ERR_INST_MISSING } from \"./errors\"\n\n// Audio related commands\n\nexport default driver => ({\n  // **@play**: Trigger a note. It uses the context to select the appropiate\n  // voice and parameters\n  // `\"@play\"`\n  \"@play\": ({ context, error }) => {\n    const instName = context.get(\"voice\")\n    const instrument = driver.instruments[instName]\n    if (instrument) {\n      instrument(context)\n    } else {\n      error(\"@play\", ERR_INST_MISSING, instName)\n    }\n  },\n  // **@set-bpm**: Change the global tempo\n  // `120, \"@set-bpm\"`\n  \"@set-bpm\": ({ stack }) => {\n    const bpm = parseFloat(stack.pop(), 10)\n    if (bpm > 0) driver.bpm = bpm\n  },\n  \"@scale-tempo\": ({ stack }) => {\n    const factor = parseFloat(stack.pop(), 10)\n    if (factor) driver.bpm = driver.bpm * factor\n  }\n})\n","// ## Iterables\nimport { isArray, isNum } from \"../utils\"\nimport { ERR_EXPECT_LIST, ERR_EXPECT_NUM } from \"./errors\"\n\n// Commands to work with iterables\nexport default {\n  // **@list**: Store a list into the stack to allow other operations\n  // use or change the list\n  // `[\"@list\", [1, 2, 3]]`\n  \"@quote\": ({ stack, operations, error }) => {\n    const list = operations.pop()\n    if (!isArray(list)) error(\"@list\", ERR_EXPECT_LIST, list)\n    else stack.push(list)\n  },\n  \"@q\": \"@quote\",\n\n  //  **@iter**: Iterate a list\n  // `[\"@list\", [1, 2, 3], \"@iter\", \"amp\", \"@set\"]`\n  \"@iter\": ({ stack, error }) => {\n    const list = stack.pop()\n    if (!isArray(list)) {\n      error(\"@iter\", ERR_EXPECT_LIST, list)\n    } else {\n      // Add the next element into the stack\n      const next = list.shift()\n      stack.push(next)\n      // rotate (and mutate) the pattern\n      list.push(next)\n    }\n  },\n\n  //  **@reverse**: Reverse a list\n  // `[\"@list\", [1, 2, 3], \"@reverse\"]`\n  \"@reverse\": ({ stack, error }) => {\n    const list = stack.pop()\n    if (!isArray(list)) error(\"@reverse\", ERR_EXPECT_LIST, list)\n    else stack.push(list.slice().reverse())\n  },\n\n  //  **@rotate**: Rotate a pattern\n  // `[\"@list\", [1, 2, 3, 4], 2, \"@rotate\"]`\n  \"@rotate\": ({ stack, error }) => {\n    const rotations = stack.pop()\n    const list = stack.pop()\n\n    if (!isArray(list)) {\n      error(\"@rotate\", ERR_EXPECT_LIST, list)\n    } else if (!isNum(rotations)) {\n      error(\"@rotate\", ERR_EXPECT_NUM, rotations)\n    } else {\n      // ensure rot is valid between -args.length to +args.length\n      const rot = rotations % list.length\n      // FIXME: find a more performant way to do rotation\n      var copy = [].concat(list.slice(rot)).concat(list.slice(0, rot))\n      stack.push(copy)\n    }\n  },\n}\n","// # Execution\nimport { last, isString, isArray } from \"../utils\"\nimport { ERR_EXPECT_PATTERN, ERR_EXPECT_STRING } from \"./errors\"\n\n// Basic execution operations\nexport default {\n  //  **@dup**: Duplicate item (so you can use it twice)\n  // `10,\"@dup\"`\n  \"@dup\": ({ stack }) => stack.push(last(stack)),\n\n  //  **@execute**: Execute an instruction\n  // `10, 20, \"add\", \"@execute\"`\n  \"@execute\": ({ operations, error }) => {\n    const instr = operations.pop()\n    if (isString(instr)) operations.push(\"@\" + instr)\n    else error(\"@execute\", ERR_EXPECT_STRING, instr)\n  },\n  //  **@**: Alias of @execute\n  // `10,\"dup\",\"@\"`\n  \"@\": \"@execute\",\n\n  //  **@repeat**: Repeat\n  // `4, \"@repeat\", [\"@kick\", 0.5, \"@wait\"]`\n  \"@repeat\": ({ stack, operations, error }) => {\n    const repetitions = stack.pop()\n    const pattern = last(operations)\n    if (!isArray(pattern)) error(\"@repeat\", ERR_EXPECT_PATTERN, pattern)\n    else {\n      for (let i = 1; i < repetitions; i++) {\n        operations.push(pattern)\n      }\n    }\n  },\n\n  //  **@forever**: Repeat forever\n  // `\"@forever\", [\"@kick\", 0.5, \"@wait\"]`\n  \"@forever\": ({ operations, error }) => {\n    const pattern = last(operations)\n    if (isArray(pattern) && pattern.length) {\n      operations.push(\"@forever\")\n      operations.push(pattern)\n    } else error(\"@forever\", ERR_EXPECT_PATTERN, pattern)\n  },\n}\n","// # Process\nimport { isArray } from \"../utils\"\nimport { ERR_EXPECT_PATTERN } from \"./errors\"\n\n// Commands to control the current process\nexport default {\n  // **@wait**: Wait an amount of time (in beats)\n  // `1,\"@wait\"`\n  \"@wait\": proc => proc.wait(Math.abs(Number(proc.stack.pop()))),\n\n  // **@sync**: Wait until next beat\n  \"@sync\": proc => proc.wait(Math.floor(proc.time) + 1 - proc.time),\n\n  // **@scale-rate**: Change the current rate by a factor\n  // `[1.5, \"@scale-rate\"]`\n  \"@scale-rate\": proc => {\n    const factor = parseFloat(proc.stack.pop(), 10)\n    if (factor > 0) proc.rate *= factor\n  },\n\n  // **@with-rate**:\n  \"@with-rate\": ({ stack, operations, error }) => {\n    const factor = parseFloat(stack.pop(), 10)\n    const pattern = operations.pop()\n    if (!isArray(pattern)) error(\"@with-rate\", ERR_EXPECT_PATTERN, pattern)\n    operations.push([\n      factor,\n      \"@scale-rate\",\n      pattern,\n      1 / factor,\n      \"@scale-rate\"\n    ])\n  },\n\n}\n","// ## Schedule\nimport { isArray, isString } from \"../utils\"\nimport { ERR_EXPECT_PATTERN, ERR_EXPECT_STRING } from \"./errors\"\n\n// Commands related to process scheduling\nexport default (scheduler) => ({\n  // **@loop**: a special fork that repeats a pattern forever\n  // `['@loop', [...]]`\n  \"@loop\": proc => {\n    const { operations, error } = proc\n    const pattern = operations.pop()\n    if (isArray(pattern)) scheduler.fork(null, proc, [\"@forever\", pattern])\n    else error(\"@loop\", ERR_EXPECT_PATTERN, pattern)\n  },\n\n  // **fork**: start a new (child) process. The child process uses the context of\n  // the parent process\n  \"@fork\": proc => {\n    const { operations, error } = proc\n    let pattern = operations.pop()\n\n    if (isArray(pattern)) {\n      scheduler.fork(null, proc, pattern)\n    } else {\n      error(\"@fork\", ERR_EXPECT_PATTERN, pattern)\n    }\n  },\n\n  // **@spawn**: start a new process with a name. Replace the old process with the\n  // same name if any.\n  \"@spawn\": proc => {\n    const { stack, operations, error } = proc\n    const name = stack.pop()\n    let pattern = operations.pop()\n    if (!isString(name)) {\n      error(\"@spawn\", ERR_EXPECT_STRING, name)\n    } else if (!isArray(pattern)) {\n      error(\"@spawn\", ERR_EXPECT_PATTERN, pattern)\n    } else {\n      scheduler.stop(name)\n      scheduler.fork(name, proc, [\"@forever\", pattern])\n    }\n  },\n\n  // **@stop-all**: stop all processes\n  \"@stop-all\": proc => scheduler.stopAll(),\n\n  // **@stop**: stop the current process\n  \"@stop\": ({ stack }) => scheduler.stop(stack.pop())\n})\n","// # Context\n// Commands to use the context\n\n// **@let**: Assign a value to the local context\n// `[440, \"freq\", \"@let\"]`\nconst letFn = ({ stack, context }) => context.let(stack.pop(), stack.pop())\n\n// **@set**: Assign a value to the global context\n// `[0.8, \"amp\", \"@set\"]\nconst setFn = ({ stack, context }) => context.set(stack.pop(), stack.pop())\n\n// **@get**: Get a value from the context and push it into the stack\n// `[\"freq\", \"@get\", 2, \"@*\"]`\nconst getFn = ({ stack, context }) => stack.push(context.get(stack.pop()))\n\n// **@let-_name_**: Asign a value to the local context with the given _name_\n// `[440, \"@let-freq\"]\nconst letName = (name) => ({ stack, context }) => context.let(name, stack.pop())\n\n// **@set-_name_**: Asign a value to the global context with the given _name_\n// `[440, \"@set-freq\"]\nconst setName = (name) => ({ stack, context }) => context.set(name, stack.pop())\n\n// **@get-_name_**: Get the _name_ value from the context and push into the stack\n// `[\"@get-freq\", 2, \"@*\"]\nconst getName = (name) => ({ stack, context }) => stack.push(context.get(name))\n\nexport default (cmd) =>\n  cmd === \"@let\" ? letFn\n  : cmd === \"@set\" ? setFn\n  : cmd === \"@get\" ? getFn\n  : /^@let-.+/.exec(cmd) ? letName(cmd.slice(5))\n  : /^@set-.+/.exec(cmd) ? setName(cmd.slice(5))\n  : /^@get-.+/.exec(cmd) ? getName(cmd.slice(5))\n  : undefined\n","// # Debug operations\nimport { peek } from \"../utils\"\n\n// | Name | Description | Example |\n// |------|-------------|---------|\n// | **@print** | Print the last value of the stack | `10,\"@print\"` |\n// | **@log** | Log the name with the last value of the stack | `\"@random\", \"amp\", \"@log\"` |\nexport default ({ log }) => {\n  log = log || console.log.bind(console)\n\n  return {\n    \"@print\": proc => {\n      const { stack } = proc\n      const last = stack.length ? peek(stack) : \"<Empty Stack>\"\n      log(\"@print\", last, \"(id, time)\", proc.id, proc.time)\n    },\n    \"@log\": proc => {\n      const { stack } = proc\n      const name = stack.pop()\n      const last = stack.length ? peek(stack) : \"<Empty Stack>\"\n      log(\"@log\", name, last, \"(id, time)\", proc.id, proc.time)\n    },\n    \"@debug\": proc => {\n      const { stack } = proc\n      log(\"@debug\", stack, proc.id, proc.time)\n    }\n  }\n}\n","// # Utilities\n// Utility commands\n\nexport default {\n  // **@mtof**: midi to frequency\n  // [60, '@mtof']\n  \"@mtof\": ({ stack }) => {\n    const midi = stack.pop()\n    const freq = 440 * Math.pow(2, (+midi - 69) / 12)\n    stack.push(freq)\n  },\n\n  // **@linear**: convert a value between two linear scales\n  // [value, fromLow, fromHi, toLow, toHi, \"@linear\"]\n  \"@linear\": ({ stack }) => {\n    const ohi = stack.pop()\n    const olo = stack.pop()\n    const ihi = stack.pop()\n    const ilo = stack.pop()\n    const v = stack.pop()\n\n    if (ihi === ilo) {\n      stack.push(olo)\n    } else {\n      stack.push(olo + (ohi - olo) * ((v - ilo) / (ihi - ilo)))\n    }\n  },\n}\n","// # VM\nimport Scheduler from \"./scheduler\"\nimport stdlib from \"./stdlib\"\nimport { compile } from \"./commands\"\n\n// ## VM\nexport default class VM {\n  constructor (driver, options = {}) {\n    this.context = {}\n    this.driver = driver\n    this.scheduler = new Scheduler(options)\n    this.commands = stdlib(this.driver, this.scheduler, options)\n\n    if (options.commands) this.addCommands(options.commands)\n    if (this.driver) {\n      this.addToContext(this.driver.defaultContext())\n      this.addInstruments(this.driver.getInstruments())\n      this.driver.start(this)\n    }\n  }\n\n  addInstruments (instruments, params = []) {\n    this.driver.addInstruments(instruments)\n    const commands = Object.keys(instruments).reduce((commands, name) => {\n      commands[\"@\" + name] = ({ context }) => instruments[name](context)\n      return instruments\n    }, {})\n    this.commands.add(commands)\n  }\n\n  // Run a program\n  run (program, sync = true) {\n    const { scheduler } = this\n    // if there are no processes, no need to sync\n    if (sync && scheduler.procs.length) program = [\"@sync\", program]\n    // improve performance? I think so, but should benchmark\n    const compiled = compile(program, this.commands, true)\n    return scheduler.fork(null, this.context, compiled)\n  }\n\n  resume (dur, limit) {\n    const { scheduler, commands } = this\n    return scheduler.resume(commands, dur, limit)\n  }\n\n  addCommands (commands) {\n    this.commands.add(commands)\n    return this\n  }\n\n  // Add to the initial context\n  addToContext (context) {\n    Object.assign(this.context, context)\n    return this.context\n  }\n}\n","// # Audio Driver\n\n// The audio driver has two tasks:\n// 1. Control the time by calling `resume` on the VM\n// 2. Create and play instruments\n\nexport default class AudioDriver {\n  constructor (bpm, sampleRate) {\n    if (!bpm) throw Error(\"AudioDriver bpm is required\")\n    if (!sampleRate) throw Error(\"AudioDriver sampleRate is required\")\n    this.bpm = bpm\n    this.sampleRate = sampleRate\n    this.instruments = {}\n  }\n\n  addInstruments (instruments) {\n    Object.assign(this.instruments, instruments)\n    return this.instruments\n  }\n\n  getInstruments () {\n    return this.instruments\n  }\n\n  defaultContext () {\n    return { freq: 440, amp: 0.5 }\n  }\n\n  start (scheduler) {\n    if (this.scheduler) throw Error(\"Can't attach an audio driver twice\")\n    if (scheduler.audio) throw Error(\"The given scheduler has an audio driver already\")\n    this.scheduler = scheduler\n    scheduler.audio = this\n  }\n}\n"],"names":["remove","proc","procs","i","length","splice","insert","push","p","time","at","len","Infinity","compile","program","commands","strict","map","isArray","instruction","isCommand","fn","resolve","Error","toOperator","obj","mapToOperator","cmd","op","random","rnd","Math","irnd","floor","n","shuffle","j","x","a","stack","pop","error","list","operations","prob","ifTrue","pattern","ERR_EXPECT_PATTERN","stdlib","driver","scheduler","options","Commands","core","iterables","execution","process","context","audio","schedule","debug","utilities","createInstruments","Gibberish","kick","Kick","decay","connect","snare","Snare","snappy","hat","Hat","amp","conga","Conga","freq","tom","Tom","pluck","PolyKarplusStrong","maxVoices","bass","MonoSynth","Time","beats","sampleRate","perc","pitched","ctx","get","damping","log","note","velocity","initGibberish","VM","GibDriver","initWebAudio","Context","parent","this","local","Object","assign","c","id","target","undefined","value","let","o","isProgram","Array","procId","Process","rate","bind","instr","limit","step","msg","all","type","Events","events","keys","forEach","_this","on","handler","event","Scheduler","procsByName","register","name","delay","emit","dur","nextTime","resume","isString","isNum","last","peek","operators","add","command","compiled","wrap","b","op1","op2","test","success","ERR_EXPECT_LIST","instName","instrument","instruments","bpm","parseFloat","factor","next","shift","slice","reverse","rotations","rot","copy","concat","repetitions","wait","abs","Number","fork","stop","stopAll","letFn","setFn","set","getFn","letName","setName","getName","exec","console","midi","pow","ohi","olo","ihi","ilo","v","addCommands","addToContext","defaultContext","addInstruments","getInstruments","start","reduce","sync","AudioDriver","GibberishDriver","init","bpm2bpa","tick","_this2","sequencers","inst","gain","pitch"],"mappings":"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"}
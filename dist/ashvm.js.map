{"version":3,"file":"ashvm.js","sources":["../src/commands.js","../src/vm.js","../src/gibberish.js","../src/ext/random.js","../src/ext/debug.js","../src/index.js","../src/utils.js","../src/process.js"],"sourcesContent":["// # Commands\nimport { isArray, isString, last, wrap } from './utils'\n\n// **Error messages**\nexport const ERR_EXPECT_PATTERN = 'Expected a pattern, but found:'\nexport const ERR_EXPECT_STRING = 'Expected a string, but found:'\n\n// **Utilities**\n\n// A generic stack operation that pops one value and pushes on result\nconst op1 = fn => ({ stack }) => {\n  stack.push(fn(stack.pop()))\n}\n\n// A generic stack operation that pops two values and pushes one result\nconst op2 = fn => ({ stack }) => {\n  stack.push(fn(stack.pop(), stack.pop()))\n}\n\n// A commands object is a map from instrunction name to functions\nexport default {\n  // ## Arithmetic\n  // | Name | Description | Example |\n  // |------|-------------|---------|\n  // | **@+**, **@add** | Add two values | `[1, 2, \"@+\"]` |\n  // | **@-**, **@sub** | Subtract two values | `[2, 1, \"@-\"]` |\n  // | **@\\***, **@mul** | Multiply two values | `[2, 4, \"@*\"]` |\n  // | **@/**, **@div** | Divide two values | `[4, 2, \"@*\"]` |\n  // | **@%**, **@wrap** | Modulo for positive and negative numbers | `[4, -2, \"@%\"]` |\n  // | **@mod* | Standard modulo operation | `[4, 2, \"@mod\"]` |\n  // | **@neg* | The negative of a value | `[4, \"@neg\"]` |\n  // [1, 2, \"@+\"]\n  '@+': op2((b, a) => a + b),\n  // [1, 2, \"@add\"]\n  '@add': '@+',\n  // [2, 1, \"@-\"]\n  '@-': op2((b, a) => a - b),\n  // [2, 1, \"@sub\"]\n  '@sub': '@-',\n  '@*': op2((b, a) => a * b),\n  '@mul': '@*',\n  '@/': op2((b, a) => b === 0 ? 0 : a / b),\n  '@div': '@/',\n  '@%': op2((b, a) => b === 0 ? 0 : wrap(a, b)),\n  '@wrap': '@%',\n  '@mod': op2((b, a) => b === 0 ? 0 : a % b),\n  '@neg': op1(a => -a),\n\n  // ## Logic\n\n  '@cond': ({ stack, instructions }) => {\n    const test = stack.pop()\n    // this is the pattern to execute if the test passes\n    const success = instructions.pop()\n    // the next pattern is the \"else\" part\n    if (test) {\n      // remove the \"else\" part\n      instructions.pop()\n      instructions.push(success)\n    }\n  },\n  '@>': op2((b, a) => a > b),\n  '@>=': op2((b, a) => a >= b),\n  '@<': op2((b, a) => a < b),\n  '@<=': op2((b, a) => a <= b),\n  '@==': op2((b, a) => a === b),\n  '@!=': op2((b, a) => a !== b),\n  '@!': op1(a => !a),\n  '@not': '@!',\n  '@&&': op2((b, a) => a && b),\n  '@and': '@&&',\n  '@||': op2((b, a) => a || b),\n  '@or': '@||',\n\n  // ## Core\n\n  // This are the core operations: execute instructions, modify\n  // process time and context variables\n\n  // | Name | Description | Example |\n  // |------|-------------|---------|\n  // | **@** | Alias of @execute | `10,'dup','@'` |\n  // | **@let** | Assign a value to the local context | `10,'repetitions',@let` |\n  // | **@set** | Assign a value to the global context | `10,'parts',@set` |\n  // | **@get** | Push the value of a variable into the stack | `'repetitions',@get` |\n  // | **@wait** | Wait an amount of time | `1,@wait` |\n  // | **@sync** | Wait until next beat | `@sync` |\n\n  // ## Process\n\n  // Operation related to interact with the current process\n\n  '@let': ({ stack, context }) => context.let(stack.pop(), stack.pop()),\n  '@set': ({ stack, context }) => context.set(stack.pop(), stack.pop()),\n  '@get': ({ stack, context }) => stack.push(context.get(stack.pop())),\n\n  '@wait': proc => proc.wait(Math.abs(Number(proc.stack.pop()))),\n  '@sync': proc => proc.wait(Math.floor(proc.time) + 1 - proc.time),\n\n  // ## Execute and repeat\n\n  // | Name | Description | Example |\n  // |------|-------------|---------|\n  // | **@dup** | Duplicate item (so you can use it twice) | `10,@dup` |\n  // | **@execute** | Execute an instruction | `10,'dup','@execute'` |\n  // | **@repeat** | Repeat | `4, \"@repeat\", [\"@kick\", 0.5, \"@wait\"]` |\n  // | **@forever** | Repeat forever | `\"@forever\", [\"@kick\", 0.5, \"@wait\"]` |\n  '@dup': ({ stack }) => stack.push(last(stack)),\n  '@execute': ({ instructions, error }) => {\n    const instr = instructions.pop()\n    if (isString(instr)) instructions.push('@instr')\n    else error('@execute', ERR_EXPECT_STRING, instr)\n  },\n  '@': '@execute',\n  '@repeat': ({ stack, instructions }) => {\n    const repetitions = stack.pop()\n    const pattern = last(instructions)\n    if (!isArray(pattern)) throw Error(\"Can't repeat: \" + pattern)\n    for (let i = 1; i < repetitions; i++) {\n      instructions.push(pattern)\n    }\n  },\n  '@forever': ({ instructions }) => {\n    const pattern = last(instructions)\n    if (!isArray(pattern)) throw Error(\"Can't forover: \" + pattern)\n    if (pattern.length) {\n      instructions.push('@forever')\n      instructions.push(pattern)\n    }\n  },\n\n  // ## Iteration and lists\n  // | Name | Description | Example |\n  // |------|-------------|---------|\n  // | **@iter** | Iterate a pattern | `[[\"@iter\", [0.3, 1]], \"amp\", \"@set\"]` |\n  '@iter': ({ instructions, error }) => {\n    const pattern = instructions.pop()\n    if (!isArray(pattern) || !pattern.length) {\n      error('@iter', ERR_EXPECT_PATTERN, pattern)\n    } else {\n      // Rotates the pattern and plays the first item only each time\n      // remove '1st' item, schedule, then push to back:\n      const first = pattern.splice(0, 1)\n      instructions.push(first)\n      pattern.push(first)\n    }\n  }\n}\n\n// Given a commands object, expand the aliases\nexport function expandAliases (commands) {\n  Object.keys(commands).forEach(name => {\n    const op = commands[name]\n    if (isString(op)) commands[name] = commands[op]\n  })\n  return commands\n}\n","// # VM\n\nimport { isArray, isString } from './utils'\nimport { Process } from './process'\nimport stdlib, {\n  expandAliases,\n  ERR_EXPECT_STRING,\n  ERR_EXPECT_PATTERN\n} from './commands'\n\nconst assign = Object.assign\n\n// The purpose of the VM is to run processes concurrently. It also\n// mantains an extensible object of commands (instructions mapped to functions)\n// that allows to add instructions to the vm\n\n// TODO: probably is better to have functions and object instead of classes\n// will change in the future.\nexport class VM {\n  constructor (initialContext) {\n    this.context = initialContext\n    this.procs = [] // the procs are inverse ordered by time\n    this.procsByName = {} // a map of names to procs\n    this.time = 0\n    this.commands = createCommands(this)\n    this.addCommands(stdlib)\n  }\n\n  // Run a program\n  run (program, sync = true) {\n    this.fork(null, this.context, sync ? ['@sync', program] : program)\n  }\n\n  // Add more commands\n  addCommands (commands) {\n    assign(this.commands, expandAliases(commands))\n  }\n\n  // Create a new process\n  fork (name, parent, program, delay = 0, rate) {\n    const time = this.time + delay\n    // if has parent and no rate, try to use it's rate\n    if (!rate && parent) rate = parent.rate\n    // if has parent try to use it's context\n    const context = parent ? parent.context || parent : undefined\n    // create the new process and insert into the process stack\n    const proc = new Process(program, context, time, rate)\n    insert(proc, this.procs)\n    // if has name, register it\n    if (name) this.procsByName[name] = proc\n    return proc\n  }\n\n  // run the vm for the given amount of time (Infinity if not specified)\n  resume (dur = Infinity, limit = 10000) {\n    const { procs } = this\n    if (procs.length === 0) return false\n    const time = this.time + dur\n    while (--limit > 0 && at(procs) < time) {\n      const proc = procs.pop()\n      if (proc.resume(this.commands, time)) {\n        // the proc has more operations, re-schedule\n        insert(proc, this.procs)\n      }\n    }\n    this.time = time\n    return procs.length > 0\n  }\n\n  stopAll () {\n    this.procs.length = 0\n  }\n\n  // The stop function can stop a proccess by name or by object\n  stop (proc) {\n    if (typeof proc === 'string') {\n      const name = proc\n      proc = this.procsByName[name]\n      this.procsByName[name] = null\n    }\n    remove(proc, this.procs)\n  }\n}\n\n// ## VM commands\n\n// | Name | Description | Example |\n// |------|-------------|---------|\n// | **@fork** | Fork | `@fork, [0.5, \"@wait\", \"@kick\"]` |\n// | **@spawn** | Spawn | `\"melody\", \"@spawn\", [0.5, \"@wait\", \"@kick\"]` |\n// | **@stop** | Stop current process | `@stop` |\n// | **@stop-all** | Stop all processes | `@stop-all` |\nfunction createCommands (vm) {\n  return {\n    '@loop': proc => {\n      const { instructions, error } = proc\n      const pattern = instructions.pop()\n      if (isArray(pattern)) vm.fork(null, proc, ['@forever', pattern])\n      else error('@loop', ERR_EXPECT_PATTERN, pattern)\n    },\n    '@fork': proc => {\n      const { instructions, error } = proc\n      let pattern = instructions.pop()\n\n      if (isArray(pattern)) {\n        vm.fork(null, proc, pattern)\n      } else {\n        error('@fork', ERR_EXPECT_PATTERN, pattern)\n      }\n    },\n    '@spawn': proc => {\n      const { stack, instructions, error } = proc\n      const name = stack.pop()\n      let pattern = instructions.pop()\n      if (!isString(name)) {\n        error('@spawn', ERR_EXPECT_STRING, name)\n      } else if (!isArray(pattern)) {\n        error('@spawn', ERR_EXPECT_PATTERN, pattern)\n      } else {\n        vm.stop(name)\n        vm.fork(name, proc, ['@forever', pattern])\n      }\n    },\n    '@stop-all': proc => vm.stopAll(),\n    '@stop': ({ stack }) => vm.stop(stack.pop())\n  }\n}\n\n// ## Internal VM functions\n\n// remove a process process\nfunction remove (proc, procs) {\n  let i = procs.length - 1\n  while (i >= 0 && procs[i] !== proc) {\n    i--\n  }\n  // if found, remove it\n  if (i !== -1) procs.splice(i, 1)\n}\n\n// insert a process into a stack ordered by time\n// (in fact, is inverse order because it's a stack)\nfunction insert (proc, procs) {\n  if (procs.length === 0) {\n    // no need to sort: just push it\n    procs.push(proc)\n  } else {\n    // procs are sorted on insertion\n    let i = procs.length - 1\n    let p = procs[i]\n    while (p && p.time <= proc.time) {\n      i--\n      p = procs[i]\n    }\n    procs.splice(i + 1, 0, proc)\n  }\n  return proc\n}\n\n// get time of the next process\nfunction at (procs) {\n  const len = procs.length\n  return len ? procs[len - 1].time : Infinity\n}\n","/* global Gibberish */\nlet bpm = 100\nlet sampleRate = null\nlet bpm2bpa = null\nlet vms = []\nlet instruments = null\nlet commands = null\n\nexport function gibberish (Gibberish, vm) {\n  if (arguments.length === 1) return vm => gibberish(Gibberish, vm)\n  if (sampleRate === null) initAudio()\n\n  vms.push(vm)\n  vm.addCommands(commands)\n  return Gibberish\n}\n\nfunction initAudio () {\n  Gibberish.init()\n  sampleRate = Gibberish.context.sampleRate\n  bpm2bpa = 1 / (60 * sampleRate)\n  instruments = createInstruments(Gibberish, instConfig)\n  commands = createCommands(instruments, cmdConfig)\n  Gibberish.sequencers.push(sequencer)\n}\n\n// The Gibberish sequencer that controlls all\nconst sequencer = {\n  tick () {\n    const len = vms.length\n    if (len === 0) return\n    const dur = bpm * bpm2bpa\n    for (let i = 0; i < len; i++) {\n      vms[i].resume(dur)\n    }\n  }\n}\n\n// This is the instruments configuration\nconst instConfig = [\n  ['kick', 'Kick', { decay: 0.2 }],\n  ['snare', 'Snare', { snappy: 1.5 }],\n  ['hat', 'Hat', { amp: 1.5 }],\n  ['conga', 'Conga', { amp: 0.25, freq: 400 }],\n  ['tom', 'Tom', { amp: 0.25, freq: 400 }],\n  ['pluck', 'PolyKarplusStrong', { maxVoices: 32 }],\n  [\n    'bass',\n    'MonoSynth',\n    {\n      attack: 44,\n      decay: 0.25, // FIXME(danigb) -- it was: Gibberish.Time.beats(0.25),\n      filterMult: 0.25,\n      octave2: 0,\n      octave3: 0\n    }\n  ]\n]\n// Given a instruments configuration, create the Giberish instruments\nfunction createInstruments (G, config) {\n  return config.reduce(\n    (insts, [name, type, params]) => {\n      insts[name] = new G[type](params).connect()\n      return insts\n    },\n    {}\n  )\n}\n\n// ## Commands\n\n// A trigger function receives the instrument and the parameters\nconst tr1 = (inst, amp) => {\n  inst.amp = amp\n  inst.note()\n}\n// trigger an instrument with 2 params\nconst tr2 = (inst, amp, freq) => {\n  inst.amp = amp\n  inst.freq = freq\n  inst.note()\n}\n// the bass is only triggered if the frequency is positive\n// the bass is only triggered if the frequency is positive\nconst trBass = (bass, amp, freq) => {\n  if (freq > 0) bass.note(amp, freq)\n}\n// trigger the pluck requires adjust dump and compensate volume\nconst trPluck = (strings, amp, freq) => {\n  if (freq > 0) {\n    // This is not in any way accurate, just a hack to make @set-dur do something semi-meaningful\n    strings.damping = 1 - (-6) / Math.log(freq / sampleRate)\n    // Strings by default seem too quiet:\n    strings.note(freq, amp * amp * 2)\n  }\n}\n\n// ## Instrument commands\n\n// | Name | Description | Example |\n// |------|-------------|---------|\n// | **@pluck** | Trigger a string sound | `@pluck` |\n// | **@pluck-note** | Trigger a string sound passing parameters | `freq, amp, @pluck` |\n// | **@bass** | Trigger a bass sound | `@bass` |\n// | **@bass-note** | Trigger a bass sound passing parameters | `freq, amp, @bass` |\nconst cmdConfig = {\n  pluck: ['amp', 'freq', trPluck],\n  bass: ['amp', 'freq', trBass],\n  kick: ['amp', null, tr1],\n  snare: ['amp', null, tr1],\n  hat: ['amp', null, tr1],\n  conga: ['amp', 'freq', tr2],\n  tom: ['amp', 'freq', tr2]\n}\n\nfunction createCommands (instruments, config) {\n  return Object.keys(config).reduce((cmds, name) => {\n    const cmdConfig = config[name]\n    const inst = instruments[name]\n    cmds['@' + name] = fromScope(inst, cmdConfig)\n    cmds['@' + name + '-note'] = fromStack(inst, cmdConfig)\n    return cmds\n  }, {})\n}\n\n// Create an instrument command that get the parameters from context\n// example: `['@pluck']`\nfunction fromScope (inst, [name1, name2, trigger]) {\n  return ({ context }) => trigger(inst, context.get(name1), context.get(name2))\n}\n\n// Create an instrument command that get the parameters from the stack\n// example: `[0.2, 05, '@pluck-note']`\nfunction fromStack (inst, [name1, name2, trigger]) {\n  return ({ stack }) =>\n    trigger(inst, stack.pop(), name2 ? stack.pop() : undefined)\n}\n","// ## Randomness\nimport { isArray } from '../utils'\nconst { floor } = Math\n\n// | Name | Description | Example |\n// |------|-------------|---------|\n// | **@random** | Generate a random number between 0 and 1 | `[\"@random\", \"amp\", \"@set\"]` |\n// | **@rand** | Alias for @random | |\n// | **@srandom** | Generate a random number between -1 and 1 | `[\"@srandom\", \"phase\", \"@set\"]` |\n// | **@srand** | Alias for @srandom | |\n// | **@randi** | Generate a random integer between 0 and n | `[60, \"@randi\", \"midi\", \"@set\"]` |\n// | **@pick** | Pick a random element from a list | `[\"@pick\", [1, 2, 3, 4]]` |\n// | **@chance** | Probabilistic execution | `probability, \"@chance\", executed-if-true, executed-if-false` |\nexport default function random (random) {\n  // allow to use a custom random function\n  const rnd = random || Math.random\n  // a function that generates integer random from 0 to n\n  const irnd = n => floor(rnd() * n)\n\n  return {\n    '@random': ({ stack }) => stack.push(rnd()),\n    '@rand': '@random',\n    '@srandom': ({ stack }) => stack.push(rnd() * 2 - 1),\n    '@srand': '@srandom',\n    '@randi': ({ stack }) => stack.push(irnd(stack.pop())),\n    '@pick': proc => {\n      const { instructions, error } = proc\n      const pattern = instructions.pop()\n      if (!isArray(pattern)) {\n        instructions.push(pattern)\n        error(\"Can't pick an element if is not an array\", pattern)\n      } else {\n        const i = irnd(pattern.length)\n        instructions.push(pattern[i])\n      }\n    },\n    '@chance': ({ stack, instructions }) => {\n      const prob = stack.pop()\n      const pattern = instructions.pop()\n      if (rnd() < prob) {\n        // Skip item after\n        instructions.pop()\n        // Push the pattern\n        instructions.push(pattern)\n      }\n    }\n  }\n}\n","// # Debug operations\nimport { peek } from '../utils'\n\n// | Name | Description | Example |\n// |------|-------------|---------|\n// | **@print** | Print the last value of the stack | `10,\"@print\"` |\n// | **@log** | Log the name with the last value of the stack | `\"@random\", \"amp\", \"@log\"` |\nexport default function debug (log) {\n  log = log || console.log.bind(console)\n\n  return {\n    '@print': proc => {\n      const { stack } = proc\n      const last = stack.length ? peek(stack) : '<Empty Stack>'\n      log('@print', last, '(id, time)', proc.id, proc.time)\n    },\n    '@log': proc => {\n      const { stack } = proc\n      const name = stack.pop()\n      const last = stack.length ? peek(stack) : '<Empty Stack>'\n      log('@log', name, last, '(id, time)', proc.id, proc.time)\n    },\n    '@debug': proc => {\n      const { stack } = proc\n      log('@debug', stack, proc.id, proc.time)\n    }\n  }\n}\n","// # Audio Scheduler Virtual Machine\nimport { VM } from './vm'\nimport { gibberish } from './gibberish'\nimport random from './ext/random'\nimport debug from './ext/debug'\n\n// ## Architecture Overview\n\n// The main purpose of the virtual machine is to run processes concurrently.\n// It holds a `commands` object (that maps instruction names to functions)\n// and schedules a collection of `processes`. Each **process** has an values `stack`\n// and `operations` stack (to be executed).\n\n// ## API\n\n// the init function creates a vm controlled by Gibberish\nexport function init (Gibberish, ...plugins) {\n  // Create the virtual machine and setup commands\n  const vm = new VM({ amp: 0.5, freq: 440 })\n  vm.addCommands(random())\n  vm.addCommands(debug())\n  plugins.forEach(cmds => vm.addCommands(cmds))\n\n  // Init the audio driver\n  gibberish(Gibberish, vm)\n  return vm\n}\n","// # TimeVM utilities\n\n// test if an object is an array\nexport const isArray = Array.isArray\n\n// test if an object is a string\nexport const isString = o => typeof o === 'string'\n\n// get last element from an array\nexport const last = a => a[a.length - 1]\n// take the next element of stack without remove it\nexport const peek = last\n\n// A modulo operation that handles negative n more appropriately\n// e.g. wrap(-1, 3) returns 2\n// see http://en.wikipedia.org/wiki/Modulo_operation\n// see also http://jsperf.com/modulo-for-negative-numbers\nexport const wrap = (a, b) => (a % b + b) % b\n","// # Process\n\nconst isCommand = o => typeof o === 'string' && o[0] === '@'\nconst isProgram = Array.isArray\nlet procId = 1\nconst ERR_INSTR_NOT_FOUND = 'Instruction not recognized.'\nconst ERR_LIMIT_REACHED = 'Limit reached. Probably an infinity loop.'\n\n// Processes are the principal computation unit. It departures from typical\n// processes in that it model the concept of time\nexport class Process {\n  constructor (program, context, time, rate) {\n    this.id = 'proc-' + procId++\n    // a stack of values\n    this.stack = []\n    // the instructions are stored in a stack (in reverse order)\n    this.instructions = program ? [program] : []\n    // the context is used to store variables with scope\n    this.context = new Context(context)\n    // the current time\n    this.time = typeof time === 'number' ? time : 0\n    // how fast time passes\n    this.rate = typeof rate === 'number' ? rate : 1\n    // bind error to allow destructuring in commands\n    this.error = this.error.bind(this)\n  }\n\n  // wait an amount of time\n  wait (time) {\n    this.time += this.rate * time\n  }\n\n  // The process is agnostic about the commands to be use\n  step (commands) {\n    const { instructions } = this\n    if (instructions.length) {\n      const instr = instructions.pop()\n      if (instr === null || instr === undefined) {\n        // ignore\n      } else if (typeof instruction === 'function') {\n        // functions can be scheduled too\n        instr()\n      } else if (isProgram(instr)) {\n        // if it's program, and since the instructions are stored into an stack,\n        // we need add to the program instructions in reverse order\n        for (let i = instr.length - 1; i >= 0; i--) {\n          instructions.push(instr[i])\n        }\n      } else if (isCommand(instr)) {\n        const operation = commands[instr]\n        if (typeof operation === 'function') operation(this)\n        else this.error('', ERR_INSTR_NOT_FOUND, instr)\n      } else {\n        // if it's a value, push it into the stack\n        this.stack.push(instr)\n      }\n    }\n  }\n\n  // the `resume` function run all the instructions until time is reached\n  resume (commands, time = Infinity, limit = 10000) {\n    const { instructions } = this\n    while (--limit > 0 && this.time < time && instructions.length) {\n      this.step(commands)\n    }\n    if (limit === 0) this.error('Resume', ERR_LIMIT_REACHED)\n    return instructions.length > 0\n  }\n\n  // an utility function to write errors\n  error (instr, msg, obj) {\n    console.error(instr, msg, obj, 'id', this.id, 'time', this.time)\n  }\n}\n\n// ## Context\n\n// A context is a hierarchical structure to store values with scope\nexport class Context {\n  constructor (parent) {\n    if (parent instanceof Context) this.parent = parent\n    else if (parent) this.local = Object.assign({}, parent)\n  }\n  // get a value from a context\n  get (id) {\n    let target = this\n    while (target.value(id) === undefined && target.parent) {\n      target = target.parent\n    }\n    return target.value(id)\n  }\n\n  // set a value from a context\n  set (id, value) {\n    let target = this\n    while (target.value(id) === undefined && target.parent) {\n      target = target.parent\n    }\n    target.let(id, value)\n  }\n  // get a value from the local scope of a context\n  value (id) {\n    return this.local ? this.local[id] : undefined\n  }\n\n  // set a value into the local scope of a context\n  let (id, value) {\n    if (!this.local) this.local = {}\n    this.local[id] = value\n  }\n}\n"],"names":["expandAliases","commands","keys","forEach","op","name","isString","createCommands","vm","instructions","proc","error","pattern","pop","isArray","fork","ERR_EXPECT_PATTERN","stack","stop","ERR_EXPECT_STRING","stopAll","remove","procs","i","length","splice","insert","push","p","time","at","len","Infinity","gibberish","Gibberish","arguments","sampleRate","initAudio","addCommands","init","context","createInstruments","instConfig","instruments","cmdConfig","sequencers","sequencer","G","config","reduce","insts","type","params","connect","Object","cmds","inst","fromScope","fromStack","name1","name2","trigger","get","undefined","random","rnd","Math","irnd","floor","n","prob","debug","log","console","bind","peek","id","VM","amp","freq","plugins","Array","o","last","a","wrap","b","isCommand","isProgram","procId","Process","program","rate","Context","this","instr","instruction","operation","limit","step","msg","obj","parent","local","assign","target","value","let","op1","fn","op2","test","success","set","wait","abs","Number","repetitions","Error","first","initialContext","procsByName","stdlib","sync","delay","dur","resume","bpm2bpa","vms","decay","snappy","maxVoices","tr1","note","tr2","trBass","bass","trPluck","strings","damping"],"mappings":"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"}
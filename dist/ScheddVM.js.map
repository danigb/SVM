{"version":3,"file":"ScheddVM.js","sources":["../src/index.js"],"sourcesContent":["/* global Gibberish MIDI */\nconsole.log('ScheddVM init', Gibberish, MIDI)\n\nconst uid = (function () {\n  let id = 0\n  return function () {\n    id++\n    return 'uid' + id\n  }\n})();\n\n// ////////////////////////////////////////////////////////////////////////////////////////\n// Gibberish:\n// http://charlie-roberts.com/gibberish/\n// ////////////////////////////////////////////////////////////////////////////////////////\nMIDI.init()\nGibberish.init()\nGibberish.Time.export()\nGibberish.Binops.export()\n\nlet bpm = 100 // Somehow need to make this globally modifiable\nconst sr = Gibberish.context.sampleRate\nconst bpm2bpa = 1 / (60 * sr) // Multiplier to convert bpm to beats per audio sample\n\nconst external = {\n  linked: false,\n  t: 0\n}\n\nconst kick = new Gibberish.Kick({decay: 0.2}).connect()\nconst snare = new Gibberish.Snare({snappy: 1.5}).connect()\nconst hat = new Gibberish.Hat({amp: 1.5}).connect()\nconst conga = new Gibberish.Conga({amp: 0.25, freq: 400}).connect()\nconst tom = new Gibberish.Tom({amp: 0.25, freq: 400}).connect()\nconst strings = new Gibberish.PolyKarplusStrong({maxVoices: 32}).connect()\nconst bass = new Gibberish.MonoSynth({\n  attack: 44,\n  decay: Gibberish.Time.beats(0.25),\n  filterMult: 0.25,\n  octave2: 0,\n  octave3: 0\n}).connect()\n\n// ////////////////////////////////////////////////////////////////////////////////////////\n/*\n  Pattern sequencer\n\n  interprets a list of events, like a byte code but with pauses\n\n  Important to distinguish between operations and simple lists.\n  [a, b, c] can means perform a, b, c in sequence\n  or it can be perform a(b,c), e.g. note(60, 100)\n  we could make the former explicit by [\"seq\", a, b, c] but it would be nice not to have to\n  we might be able to infer seq or expr by context? E.g. the root of a score must always be seq.\n  or just make instructions have special names, e.g. \"@pluck\"\n\n  any argument can be another bytecode to interpret\n  [note, a, [b, c], d]; in this case [b, c] must be an expression, right?\n  Important to distinguish [note a b c] from [note [a b] c]... can't just flatten arrays\n\n  -- simple numeric arguments, for note N N N, loop N, rotate N, etc.\n  (loop (rnd 1 4) pattern)\n  (loop (rnd 1 (rnd 1 4)) pattern)\n  (loop (add 3 (rnd 1 4)) pattern)\n  (note (pick 60 40 30))\n  (note (alt 60 50 40))\n  (note (chance 0.5 60)) makes sense only if there is a contextual freq-state to default to\n  + filters\n\n  shuffle, reverse, rotate return lists, don't make sense here. unless we give it semantics.\n  loop, fork, rate, wait don't make sense because no return, and temporal semantics don't make sense in an expression. They only make sense in an event sequence.\n  every N?\n\n  list/pattern arguments, for loop P, rotate/reverse/shuffle/alt P, pick P, rate P, fork P...\n  add: could apply to all elements in the P, but that might not make sense\n\n  fun example:\n\n  ((alt (pick seq)) (A B C)) The trick is that the operator itself is dynamically chosen. Could lead to patterns like ABCAABCBABCAABCCABCCABCBACBAABCBABCB ETC.\n\n  Challenge: some things need to be calculated before applying the operation,\n  while some things need to wait for the operation to know whether/how to calculate\n\n  E.g. (add a b) needs a & b to be evaluated first, but (chance 0.5 a) has to determine the chance first before evaluating a. This is essentially the $vau special form argument; or put another way, the difference between function calls and other control flow types.\n\n  Each operator already knows whether an argument should be evaluated first.\n  E.g. encountering (@add a b) on the queue, one could requeue as (a b @add-values) to ensure a & b are evaluated first. Then the question is how to map the values of a & b to @add-values, e.g. via a simple value stack. That makes it a stack-based machine, also like a concat language...\n    4 wait\n    dur amp freq note, ... path osc, etc.\n    1 2 add, etc.\n\n  Whereas encountering (@pick a b) we can do the pick immediately, as this only modifies the queue, pushing either a or b onto it. This is more like a macro language.\n    alt A B\n    pick list,\n    loop A, fork A,\n    reverse A, shuffle A, rotate A => A (but also modifies A in-place)\n\n  That's how 'wait pick (2, 3)' becomes 'wait 2' or 'wait 3': the pick(2, 3) is pushed on the stack first, then evaluated to get 2 or 3, then this needs to move to a stack, then be used (popped) by the @wait.\n\n  Some instructions may generate both forms:\n\n    N chance A\n    N rate A  (eval the rate argument and apply only around the pattern A) => set-rate A unset-rate\n    N loop A (iterations arg will be evaluated once then counted down) => A N-1 loop A\n    N rotate A => A rotate A'\n\n    N after A (add A only after N visits)\n      has to modify the (N after A) whole to decrement N. Only when N == 0 will A be added.\n    N every A like above, but needs to re-add N every A when A is run.\n      not sure if this is even possible... though maybe (alt (nop, nop, nop, A)) works.\n\n  Can stuff like this work? I.e. reverse A 50% of the time:\n\n  ((0.1 chance reverse) A)\n  -> 0.1 | chance reverse A\n  -> | reverse A        or       | A\n\n  -- definitely need parens:\n  loop ((0.1 chance (pick (reverse shuffle))) A)\n  can produce any of:\n  -> | reverse A\n  -> | shuffle A\n  -> | A\n\n  -- but without parens, it's pretty ambiguous:\n  loop 0.1 chance pick reverse shuffle A\n\n  In a way, maybe what we need is a conditional transform; a bit like a filter.\n  Things like reverse/shuffle/rotate are not often likely to be desired on every loop.\n  Conditions could be e.g. periodic, stochastic, or more complex\n  In any case, the notion of a conditional transform implies that the 'else' is the untransformed pattern\n  i.e. pattern plays unchanged.\n  So, we may have a sequence of \"(transform-if (0.5 prob) rotate (transform reverse patt))\"\n\n  Really, when would you use rotate etc. without some condition?\n  So, why not call them rotate-if?\n\n  cond reverse-if patt => patt or patt'\n  can't chain though:\n  cond reverse-if cond shuffle-if patt Fails, because we can't pull patt for the reverse-if.\n\n  This could all be a ton easier if we allowed users to name patterns...\n  Maybe that's something we can support if there's a uid() function available to the parser actions...\n\n  ----------------------\n\n  Each active sequencer is a PQ\n  Each PQ can contain several Q's of instructions (this allows polyrhythm)\n  PQ's are stored in named slots for easy replacement/removal\n\n  CONSIDER USING A BIGNUM LIBRARY TO MEASURE TIME\n*/\n// ////////////////////////////////////////////////////////////////////////////////////////\n\nconst ScheddVM = {}\nexport default ScheddVM\n\nconst sequencers = {}\nlet spawns = {}\n\n// Exported:\nScheddVM.seq = {}\n\n// Dictionary of active sequencers.\nScheddVM.sequencers = {}\n\n// Dictionary of actively spawned loops.\nScheddVM.spawns = {}\n\n// This is where the externally triggered events are buffered to synchronize them to beats\nconst cq = {\n  t: 0,\n  beat: -1,\n  cmds: [] // These get fired at the next beat\n}\n\ncq.tick = function (t) {\n  if (!external.linked) {\n    this.resume(this.t + bpm * bpm2bpa)\n  }\n}\n\ncq.resume = function (t) {\n  const t0 = Math.floor(t)\n  if (t0 > this.beat) {\n    this.beat = t0\n\n    // Flush commands:\n    while (this.cmds.length) {\n      const cmd = this.cmds.shift()\n      cmd()\n    }\n  }\n  this.t = t\n  return this\n}\n\nGibberish.sequencers.push(cq)\n\n// Clear all sequencers (e.g. STOP button) -- immediate\nScheddVM.seq.clear = function () {\n  for (let k in sequencers) {\n    sequencers[k].disconnect()\n    delete sequencers[k]\n  }\n  spawns = {}\n\n  if (MIDI) {\n    MIDI.send([0x7B, 0], 0)\n  }\n}\n\n// Triggered by the onclick of an html element\n// grabs the innertext and plays it\n// e.g. <a href=\"#\" onclick=\"seq.play_element_text(this)\">[\"@pluck\"]</a>\nScheddVM.seq.play_element_value = function (element) {\n  // Play element's text:\n  ScheddVM.seq.define(uid(), JSON.parse(element.value))\n}\n\n// Triggered by the onclick of an html element\n// grabs the innertext and plays it\n// e.g. <a href=\"#\" onclick=\"seq.play_element_text(this)\">[\"@pluck\"]</a>\nScheddVM.seq.play_element_text = function (element) {\n  // Play element's text:\n  ScheddVM.seq.define(uid(), JSON.parse(element.innerText))\n  // Stop the click from selecting the text:\n  if (document.selection && document.selection.empty) {\n    document.selection.empty()\n  } else if (ScheddVM.getSelection) {\n    const sel = ScheddVM.getSelection()\n    sel.removeAllRanges()\n  }\n}\n\n// Define a sequencer.\n// if name didn't exist, create a new one.\n// if name already exists, replace score. If no score, terminate the sequencer.\nScheddVM.seq.define = function (name, score) {\n  // Sync this:\n  cq.cmds.push(() => {\n    if (!typeof name === 'string') {\n      console.log('error: missing sequence name')\n      return\n    }\n    if (!Array.isArray(score)) {\n      console.log('error: missing score data')\n      return\n    }\n    // Create it:\n    return new PQ(score, name).connect()\n  })\n}\n\n// Terminate a named sequencer.\nScheddVM.seq.stop = function (name) {\n  if (!typeof name == 'string') {\n    console.log('error: missing sequence name')\n    return\n  }\n  const _seq = sequencers[name]\n  if (_seq !== undefined) {\n    _seq.disconnect()\n  }\n}\n\nScheddVM.seq.external_resume = function () {\n  const t1 = external.t + bpm * bpm2bpa\n  cq.resume(t1)\n  for (let k in sequencers) {\n    sequencers[k].resume(t1)\n  }\n}\n\n// We could also call this an agent, or player, or scheduler, etc.\n// it can contain multiple command queues (type Q), and executes them in an interleaved way\n// to ensure proper timing -- a bit like coroutines.\nfunction PQ (score, name) {\n  this.t = external.t\n  this.heap = [] // The list of active command queues (next to resume is at the top)\n  this.name = name || 'default'\n  this.context = {\n    freq: 440,\n    amp: 1\n  }\n\n  if (score) {\n    this.fork(score, this.t, this)\n  }\n\n  // Replace?\n  const s = sequencers[this.name]\n  if (s !== undefined) {\n    // Remove sequencer:\n    s.disconnect()\n  }\n  sequencers[this.name] = this // Auto-connect()?\n\n  // console.log('creating sequencer', this.name);\n}\n\nPQ.prototype.connect = function () {\n  if (Gibberish.sequencers.indexOf(this) === -1) {\n    Gibberish.sequencers.push(this)\n  }\n  Gibberish.dirty(this)\n  return this\n}\n\nPQ.prototype.disconnect = function () {\n  const idx = Gibberish.sequencers.indexOf(this)\n  if (idx >= 0) {\n    Gibberish.sequencers.splice(idx, 1)\n  }\n  delete sequencers[this.name]\n\n  // Console.log('stopping sequencer', this.name);\n\n  return this\n}\n\n// How to play the pq in a sample callback:\nPQ.prototype.tick = function () {\n  if (!external.linked) {\n    this.resume(this.t + bpm * bpm2bpa)\n  }\n}\n\nPQ.prototype.fork = function (score, t, parentQ) {\n  const q = new Q(score, t, this.name, parentQ)\n  this.push(q)\n}\n\n// PQ is always sorted on insertion\nPQ.prototype.push = function (q) {\n  // Q.pq = this; // add a back reference (needed?)\n  if (this.empty()) {\n    this.heap.push(q)\n  } else {\n    // Top item:\n    let i = this.heap.length\n    let p = this.heap[i - 1]\n    // Keep shifting it back to find the right location\n    while (p && p.t <= q.t) {\n      i--\n      p = this.heap[i - 1]\n    }\n    // Insert:\n    this.heap.splice(i, 0, q)\n\n    // For (var i=0; i<this.heap.length; i++) console.log(\"pq\", i, this.heap[i]);\n  }\n  return this\n}\n\n// True if no Q's scheduled\nPQ.prototype.empty = function () {\n  return this.heap.length === 0\n}\n\n// Get the time of the next item:\nPQ.prototype.at = function () {\n  if (!this.empty()) {\n    return this.heap[this.heap.length - 1].t\n  }\n}\n\nlet runaway_limit = 10000\n\n// How to play the pq in a sample callback:\nPQ.prototype.resume = function (t) {\n  runaway_limit = 10000 // Prevent infinite loops\n  while (!this.empty() && t >= this.at() && --runaway_limit > 0) {\n    // Resume a queue:\n    // console.log(\"PQ.tick\", this.t, this.at());\n    const q = this.heap.pop()\n    // Console.log(\"PQ.tick\", q, this.t, q.at);\n    if (q.resume(t)) {\n      this.push(q) // Re-schedule it\n    }\n  }\n  if (runaway_limit <= 0) {\n    console.error('PQ resume unbounded loop detected')\n    this.disconnect()\n  }\n  this.t = t\n  return this\n}\n\nfunction Q (score, t, pq, parentQ) {\n  this.t = t || 0\n  this.pq = pq\n  this.rate = 1\n  this.todo = []\n  this.stack = []\n  this.parentQ = parentQ\n  if (parentQ) {\n    this.context = {}\n  } else {\n    this.context = {\n      freq: 440,\n      amp: 1\n    }\n  }\n  this.debug = false\n  if (score) {\n    this.push(score)\n  }\n}\n\nQ.prototype.get = function (name) {\n  let q = this\n  let val = q.context[name]\n  while (val == undefined && q.parentQ) {\n    q = q.parentQ\n    val = q.context[name]\n  }\n  return val\n}\n\nQ.prototype.push = function (v) {\n  this.todo.push(v)\n}\n\n// In each instruction handler,\n// we can push to the todo queue\n// and push to and pop from the stack\nQ.prototype.step = function () {\n  if (this.debug) {\n    console.log('\\tstack:', JSON.stringify(this.stack))\n    console.log('\\tqueue:', JSON.stringify(this.todo))\n  }\n  if (this.todo.length) {\n    const item = this.todo.pop()\n    if (item == null || item == undefined) {\n      // ignore\n    } else if (Array.isArray(item)) {\n      for (i = item.length - 1; i >= 0; i--) {\n        this.todo.push(item[i])\n      }\n    } else if (typeof item === 'string' && item.charAt(0) == '@') {\n      const op = item\n      // Console.log(op);\n\n      // special cases:\n\n      if (op.substring(0, 4) == '@ws-') {\n        var n = Number(op.substring(4))\n        var args = this.stack.splice(this.stack.length - n, n)\n        // Console.log(\"ws\", args);\n        var msg = args.join(' ')\n        ws_send(this.t + ' ' + msg)\n        return\n      } else if (op.substring(0, 4) == '@gb-') {\n        var n = Number(op.substring(4))\n        var args = this.stack.splice(this.stack.length - n, n)\n        // Console.log(\"ws\", args);\n        var msg = args.join(' ')\n        ws_send(msg)\n        return\n      } else if (op.substring(0, 5) == '@let-') {\n        // Let is always local:\n        var name = op.substring(5)\n        this.context[name] = this.stack.pop()\n        return\n      } else if (op.substring(0, 5) == '@set-') {\n        var name = op.substring(5)\n        var value = this.stack.pop()\n        // Look up the hierarchy to find the context that has this var\n        // if not found, use the uppermost\n        // easy route: if we are the uppermost, just set directly\n        if (!this.parentQ) {\n          this.context[name] = value\n          return\n        }\n\n        // Else we are child, so the @set might be directed here or upper:\n        let q = this\n        let ctx\n        while (q) {\n          ctx = q.context\n          if (q.context[name] != undefined) {\n          break\n        }\n          // Keep moving up:\n          q = q.parentQ\n        }\n\n        ctx[name] = value\n        return\n      } else if (op.substring(0, 5) == '@get-') {\n        var name = op.substring(5)\n        this.stack.push(this.get(name))\n        return\n      }\n\n      switch (op) {\n        case '@dup':\n          // Duplicate whatever is on the stack\n          this.stack.push(this.stack[this.stack.length - 1])\n          break\n\n        case '@bpm':\n          // Set bpm:\n          var t1 = this.stack.pop()\n          t1 = t1 == undefined ? 100 : Math.abs(Number(t1))\n          t1 = t1 == t1 ? t1 : 100\n          bpm = t1\n          break\n\n        case '@wait':\n          // TODO: verify stack top is a valid number...\n          // pop wait time off the stack:\n          var t1 = this.stack.pop()\n          t1 = t1 == undefined ? 1 : Math.abs(Number(t1))\n          t1 = t1 == t1 ? t1 : 0\n          this.t += t1 * this.rate\n          // Push back to pq:\n          // if (this.pq) this.pq.push(this);\n          // console.log(\"\\tq.t =\", this.t);\n          break\n\n        case '@set-rate':\n          var a1 = this.stack.pop()\n          if (a1 !== undefined && typeof a1 === 'number' && a1 > 0) {\n            this.rate = a1\n            /*\n          TODO: later, push/pop rate around a pattern\n          } else if (item.length > 2) {\n            // schedule a pop back to the original rate:\n            this.push([\"@rate\", this.rate]);\n            // schedule rest:\n            this.push(item.slice(2));\n            // adjust rate (i.e. like glPushMatrix, glMultMatrix...)\n            this.rate /= a1;\n          }\n          */\n          } else {\n            console.error('missing or invalid argument to @rate')\n          }\n          break\n\n        case '@with-rate':\n          var a1 = this.stack.pop()\n          if (a1 !== undefined && typeof a1 === 'number' && a1 > 0) {\n            var patt = this.todo.pop()\n            if (!Array.isArray(patt)) {\n              console.error('with-rate body must be a pattern (an array)')\n              break\n            }\n            // Schedule a pop back to the original rate:\n            this.push(['@set-rate', this.rate])\n            // Schedule pattern:\n            this.push(patt)\n            // Change rate first:\n            this.rate /= a1 // Or make absolute?\n            /*\n          TODO: later, push/pop rate around a pattern\n          } else if (item.length > 2) {\n            // schedule a pop back to the original rate:\n            this.push([\"@rate\", this.rate]);\n            // schedule rest:\n            this.push(item.slice(2));\n            // adjust rate (i.e. like glPushMatrix, glMultMatrix...)\n            this.rate /= a1;\n          }\n          */\n          } else {\n            console.error('missing or invalid argument to @rate')\n          }\n          break\n\n        case '@spawn':\n          // Find the name:\n          var name = this.stack.pop()\n          // Find the score:\n          var patt = this.todo.pop()\n          if (typeof name !== 'string' && typeof name !== 'number') {\n            console.error('spawn name must be a string or number')\n            break\n          }\n          if (!Array.isArray(patt)) {\n            console.error('spawn body must be a pattern (an array)')\n            break\n          }\n          // Find parent PQ:\n          var s = sequencers[this.pq]\n          if (s == undefined) {\n            console.error('can\\'t spawn, can\\'t find sequencer', this.pq)\n            break\n          }\n\n          // Does it already exist?\n          var loop = spawns[name]\n          if (loop == undefined) {\n            // Console.log(\"create new\", name);\n            // create it:\n            loop = ['@forever', patt]\n            spawns[name] = loop\n            // Fork it:\n            s.fork(loop, this.t, this)\n          } else {\n            // Console.log(\"replace\", name, loop);\n            // nothing yet\n            const dst = loop[1]\n            dst.length = 0\n            dst.push.apply(dst, patt)\n            // Console.log(\"replace\", name, loop);\n          }\n\n          // Do it:\n          // seq.define(name, [\"@loop\", patt]);\n          break\n\n        case '@stop':\n          // Find the name:\n          var name = this.stack.pop()\n          // Does it already exist?\n          var loop = spawns[name]\n          if (loop !== undefined) {\n            console.log('stop', name)\n            // Nothing yet\n            loop[1].length = 0\n            loop.length = 0\n            delete spawns[name]\n            // Loop.push.apply(loop);\n          }\n          break\n\n        case '@fork':\n          // Find the score:\n          var patt = this.todo.pop()\n          // Argument *must* be a pattern\n          if (!Array.isArray(patt)) {\n            console.error('loop body must be a pattern (an array)')\n            break\n          }\n          // Find parent PQ:\n          var s = sequencers[this.pq]\n          if (s) {\n            s.fork(patt, this.t, this)\n          } else {\n            console.error(\n              'can\\'t fork without a scheduler, couldn\\'t find scheduler',\n              this.pq\n            )\n          }\n          break\n\n        case '@loop':\n          // Find the score:\n          var patt = this.todo.pop()\n          // Argument *must* be a pattern\n          if (!Array.isArray(patt)) {\n            console.error('loop body must be a pattern (an array)')\n            break\n          }\n          // This.todo.push([\"@fork\", [\"@loop\", patt]]);\n          // find parent PQ:\n          var s = sequencers[this.pq]\n          if (s) {\n            s.fork(['@forever', patt], this.t, this)\n          } else {\n            console.error(\n              'can\\'t fork without a scheduler, couldn\\'t find scheduler',\n              this.pq\n            )\n          }\n\n          break\n\n        case '@forever':\n          // Infinite loop\n          var patt = this.todo[this.todo.length - 1]\n          // Argument *must* be a pattern\n          if (!Array.isArray(patt)) {\n            console.error('loop body must be a pattern (an array)')\n            break\n          }\n          if (patt.length) {\n            // Push instruction again (the loop flow)\n            this.todo.push(item)\n            // Push content of instruction (the loop body)\n            this.todo.push(patt)\n          }\n          break\n\n        case '@repeat':\n          var rpts = this.stack.pop()\n          // TODO: verify number, integer, >= 0, < 10000 etc.\n          var patt = this.todo[this.todo.length - 1]\n          // Patt *must* be a pattern\n          if (!Array.isArray(patt)) {\n            console.error('loop body must be a pattern (an array)')\n            break\n          }\n\n          for (i = 1; i < rpts; i++) {\n            this.todo.push(patt)\n          }\n          break\n\n        case '@print':\n          // TODO: handle item.argc > 1\n          console.log('PRINT!', this.stack.pop())\n          break\n\n        case '@pick':\n          // Pick a random element to enqueue:\n          if (Array.isArray(this.todo[this.todo.length - 1])) {\n            const list = this.todo.pop()\n            var i = random(list.length)\n            if (i >= 0) {\n              this.todo.push(list[i])\n            }\n          } else {\n            console.error(\n              'pick requires a list (array) argument to select from'\n            )\n          }\n          break\n\n        case '@iter':\n          var patt = this.todo.pop()\n          if (Array.isArray(patt) && patt.length) {\n            // Rotates the pattern and plays the first item only each time\n            // remove '1st' item, schedule, then push to back:\n            const first = patt.splice(0, 1)\n            this.todo.push(first)\n            patt.push(first)\n          } else {\n            console.error('rotate instruction requires a pattern (array)')\n            break\n          }\n          break\n\n        case '@chance':\n          var prob = this.stack.pop()\n          var pt = this.todo.pop()\n          if (random() < prob) {\n            // Skip item after\n            this.todo.pop()\n            // Push the pt:\n            this.todo.push(pt)\n          }\n          break\n\n        case '@reverse':\n          // Schedule the argument, then reverse it:\n          // TODO: is this the right order? or reverse then schedule?\n          if (!Array.isArray(this.todo[this.todo.length - 1])) {\n            console.error('reverse instruction requires a pattern (array)')\n            break\n          }\n\n          // Get the pattern:\n          var arg = this.todo.pop()\n          // Case pre: arg.reverse(); // reverse the pattern in-place\n          // schedule a shallow copy:\n          this.todo.push(arg.slice())\n          // Case post:\n          arg.reverse() // Reverse the pattern in-place\n\n          break\n\n        case '@shuffle':\n          // Schedule the argument, then reverse it:\n          // TODO: is this the right order? or reverse then schedule?\n          if (!Array.isArray(this.todo[this.todo.length - 1])) {\n            console.error('shuffle instruction requires a pattern (array)')\n            break\n          }\n\n          // Get the pattern:\n          var patt = this.todo.pop()\n          // Case pre: array_shuffle(patt); // reverse the pattern in-place\n          // schedule a shallow copy:\n          this.todo.push(patt.slice())\n          // Case post:\n          // transform the pattern in-place\n          array_shuffle(patt)\n\n          break\n\n        case '@rotate':\n          var patt = this.todo.pop()\n          var rot = this.stack.pop()\n          if (Array.isArray(patt) && patt.length) {\n            // Ensure rot is valid between -args.length to +args.length\n            rot %= patt.length\n\n            var copy = patt.splice(0)\n            // Rotate in-place\n            patt.push.apply(patt, copy.slice(rot))\n            patt.push.apply(patt, copy.slice(0, rot))\n            // Schedule a shallow copy:\n            this.todo.push(copy)\n          } else {\n            console.error('rotate instruction requires a pattern (array)')\n            break\n          }\n          break\n\n        case '@pre-rotate':\n          var patt = this.todo.pop()\n          var rot = this.stack.pop()\n          if (Array.isArray(patt) && patt.length) {\n            // Ensure rot is valid between -args.length to +args.length\n            rot %= patt.length\n            var copy = patt.splice(0)\n            // Rotate in-place\n            patt.push.apply(patt, copy.slice(rot))\n            patt.push.apply(patt, copy.slice(0, rot))\n\n            this.todo.push(patt)\n          } else {\n            console.error('rotate instruction requires a pattern (array)')\n            break\n          }\n          break\n\n        case '@':\n        case '@execute':\n          var instr = this.stack.pop()\n          if (typeof instr !== 'string') {\n            console.error('execute instruction did not evaluate to a string')\n            break\n          }\n          this.todo.push('@' + instr)\n          break\n\n        case '@cond':\n          var test = this.stack.pop()\n          var pt = this.todo.pop()\n          if (test) {\n            // Skip item after\n            this.todo.pop()\n            // Push the pt:\n            this.todo.push(pt)\n          }\n          break\n\n        case '@random':\n        case '@rand':\n          this.stack.push(Math.random())\n          break\n\n        case '@srandom':\n        case '@srand':\n          this.stack.push(Math.random() * 2 - 1)\n          break\n\n        case '@randi':\n          var n = this.stack.pop()\n          this.stack.push(random(n))\n          break\n\n        case '@+':\n        case '@add':\n          var b = this.stack.pop()\n          var a = this.stack.pop()\n          this.stack.push(a + b)\n          break\n\n        case '@-':\n        case '@sub':\n          var b = this.stack.pop()\n          var a = this.stack.pop()\n          this.stack.push(a - b)\n          break\n\n        case '@*':\n        case '@mul':\n          var b = this.stack.pop()\n          var a = this.stack.pop()\n          this.stack.push(a * b)\n          break\n\n        case '@/':\n        case '@div':\n          var b = this.stack.pop()\n          var a = this.stack.pop()\n          if (b == 0) {\n            this.stack.push(0)\n          }    else {\n            this.stack.push(a / b)\n          }\n          break\n\n        case '@%':\n        case '@wrap':\n          var b = this.stack.pop()\n          var a = this.stack.pop()\n          if (b == 0) {\n            this.stack.push(0)\n          }    else {\n            this.stack.push(wrap(a, b))\n          }\n          break\n\n        case '@mod':\n          var b = this.stack.pop()\n          var a = this.stack.pop()\n          if (b == 0) {\n            this.stack.push(0)\n          }    else {\n            this.stack.push(a % b)\n          }\n          break\n\n        case '@neg':\n          var a = this.stack.pop()\n          this.stack.push(-a)\n          break\n\n        // Conditionals\n        // should they return 1 and 0 instead of bools?\n        case '@>':\n          var b = this.stack.pop()\n          var a = this.stack.pop()\n          this.stack.push(a > b)\n          break\n        case '@>=':\n          var b = this.stack.pop()\n          var a = this.stack.pop()\n          this.stack.push(a >= b)\n          break\n        case '@<':\n          var b = this.stack.pop()\n          var a = this.stack.pop()\n          this.stack.push(a < b)\n          break\n        case '@<=':\n          var b = this.stack.pop()\n          var a = this.stack.pop()\n          this.stack.push(a <= b)\n          break\n        case '@==':\n          var b = this.stack.pop()\n          var a = this.stack.pop()\n          this.stack.push(a == b)\n          break\n        case '@!=':\n          var b = this.stack.pop()\n          var a = this.stack.pop()\n          this.stack.push(a != b)\n          break\n        case '@!':\n        case '@not':\n          var a = this.stack.pop()\n          this.stack.push(!a)\n          break\n        case '@&&':\n        case '@and':\n          var b = this.stack.pop()\n          var a = this.stack.pop()\n          this.stack.push(a && b)\n          break\n        case '@||':\n        case '@or':\n          var b = this.stack.pop()\n          var a = this.stack.pop()\n          this.stack.push(a || b)\n          break\n\n        // V ilo ihi olo ohi @map\n        case '@map':\n          var ohi = this.stack.pop()\n          var olo = this.stack.pop()\n          var ihi = this.stack.pop()\n          var ilo = this.stack.pop()\n          var v = this.stack.pop()\n\n          if (ihi == ilo) {\n            this.stack.push(olo)\n          } else {\n            this.stack.push(olo + (ohi - olo) * ((v - ilo) / (ihi - ilo)))\n          }\n          break\n\n        // MIDI\n        /*\n      MIDI note            | ```pitch, velocity, channel, duration, @note```\nMIDI note on          | ```pitch, velocity, channel, @note-on```\nMIDI note off          | ```pitch, velocity, channel, @note-off```\nMIDI controller          | ```controller, value, channel, @cc```\nSend n arguments over websocket  | ```arg1, arg2..., \"@ws-n\"```\n\n*/\n\n        // [pitch, velocity, channel, \"@note-on\"]\n        case '@note-on': {\n          var chan = Number(this.stack.pop())\n          var vel = Number(this.stack.pop())\n          var pitch = Number(this.stack.pop())\n\n          // Send noteon pitch vel chan\n          if (MIDI) {\n            MIDI.send([0x90 + chan, pitch, vel], 0)\n          }\n        }\n          break\n\n        // [pitch, velocity, channel, \"@note-off\"]\n        case '@note-off': {\n          var chan = Number(this.stack.pop())\n          var vel = Number(this.stack.pop())\n          var pitch = Number(this.stack.pop())\n\n          // Send noteoff pitch vel chan\n          if (MIDI) {\n            MIDI.send([0x80 + chan, pitch, vel], 0)\n          }\n        }\n          break\n\n        // [pitch, velocity, channel, duration, \"@note\"]\n        case '@note': {\n          const dur = Number(this.stack.pop())\n          var chan = Number(this.stack.pop())\n          var vel = Number(this.stack.pop())\n          var pitch = Number(this.stack.pop())\n\n          // Send noteon pitch vel chan\n          if (MIDI) {\n            MIDI.send([0x90 + chan, pitch, vel], 0)\n\n            // Schedule noteoff later:\n            var s = sequencers[this.pq]\n            if (s == undefined) {\n              break\n            }\n            s.fork(\n              [pitch, 0, chan, '@note-off'],\n              this.t + dur * this.rate,\n              this\n            )\n          }\n        }\n          break\n\n        // [controller, value, channel, \"@cc\"]\n        case '@cc': {\n          var chan = Number(this.stack.pop())\n          var value = Number(this.stack.pop())\n          const controller = Number(this.stack.pop())\n\n          // Send cc controller value chan\n          if (MIDI) {\n            MIDI.send([0xB0 + chan, controller, value], 0)\n          }\n        }\n          break\n\n        // Built-in sounds\n\n        case '@pluck':\n          var amp = this.get('amp')\n          var freq = this.get('freq')\n\n          if (freq <= 0) {\n            break\n          }\n          // This is not in any way accurate, just a hack to make @set-dur do something semi-meaningful\n          strings.damping = 1 - -6 / Math.log(freq / sr)\n          // Strings by default seem too quiet:\n          strings.note(freq, amp * amp * 2)\n          break\n\n        // [amp, freq, \"@pluck\"]\n        case '@pluck-note':\n          var amp = this.stack.pop()\n          var freq = this.stack.pop()\n\n          if (freq <= 0) {\n            break\n          }\n          // This is not in any way accurate, just a hack to make @set-dur do something semi-meaningful\n          strings.damping = 1 - -6 / Math.log(freq / sr)\n          // Strings by default seem too quiet:\n          strings.note(freq, amp * amp * 2)\n          break\n\n        case '@bass':\n          var velocity = this.get('amp')\n          var freq = this.get('freq')\n\n          if (freq <= 0) {\n            break\n          }\n          bass.note(freq, velocity)\n\n          break\n        case '@bass-note':\n          var velocity = this.stack.pop()\n          var freq = this.stack.pop()\n\n          if (freq <= 0) {\n            break\n          }\n          bass.note(freq, velocity)\n\n          break\n        case '@kick-note':\n          kick.amp = 0.5 * this.stack.pop() // Pitch, decay, tone, amp\n          kick.note()\n          break\n        case '@snare-note':\n          snare.amp = 0.25 * this.stack.pop() // Cutoff:1000, decay:11025, tune:0, snappy:.5, amp:1\n          snare.note()\n          break\n        case '@hat-note':\n          hat.amp = this.stack.pop()\n          hat.note() // Amp: 1, pitch: 325, bpfFreq:7000, bpfRez:2, hpfFreq:.975, hpfRez:0, decay:3500, decay2:3000\n          break\n        case '@conga-note':\n          conga.amp = 0.25 * this.stack.pop()\n          conga.pitch = this.stack.pop()\n          conga.note() // Amp: 1, pitch: 325, bpfFreq:7000, bpfRez:2, hpfFreq:.975, hpfRez:0, decay:3500, decay2:3000\n          break\n        case '@tom-note':\n          tom.amp = 0.25 * this.stack.pop()\n          tom.pitch = this.stack.pop()\n          tom.note() // Amp: 1, pitch: 325, bpfFreq:7000, bpfRez:2, hpfFreq:.975, hpfRez:0, decay:3500, decay2:3000\n          break\n\n        case '@kick':\n          kick.amp = 0.5 * this.get('amp') // Pitch, decay, tone, amp\n          kick.note()\n          break\n        case '@snare':\n          snare.amp = 0.25 * this.get('amp') // Cutoff:1000, decay:11025, tune:0, snappy:.5, amp:1\n          snare.note()\n          break\n        case '@hat':\n          hat.amp = this.get('amp')\n          hat.note() // Amp: 1, pitch: 325, bpfFreq:7000, bpfRez:2, hpfFreq:.975, hpfRez:0, decay:3500, decay2:3000\n          break\n\n        case '@conga':\n          conga.amp = this.get('amp') * 0.25\n          conga.pitch = this.get('freq')\n          conga.note()\n          break\n        case '@tom':\n          tom.amp = this.get('amp') * 0.25\n          tom.pitch = this.get('freq')\n          tom.note()\n          break\n\n        case '@time':\n          this.stack.push(this.t)\n          break\n        case '@rate':\n          this.stack.push(this.rate)\n          break\n\n        default:\n          console.error('unknown instruction operator:', op)\n\n      }\n    } else {\n      this.stack.push(item)\n    }\n  } else {\n    return true\n  }\n}\n\nQ.prototype.resume = function (t) {\n  while (--runaway_limit > 0 && this.todo.length && this.t < t) {\n    this.step()\n  }\n  return this.todo.length > 0 // Returns false if Q has no more events\n}\n\nQ.prototype.flush = function () {\n  while (--runaway_limit > 0 && this.todo.length) {\n    this.step()\n  }\n  if (runaway_limit == 0) {\n    console.error('Q flush unbounded loop detected')\n  }\n}\n\nGibberish.getSeq = function () {\n  return ScheddVM.seq\n}\n// ////////////////////////////////////////////////////////////////////////////////////////\n// BUILDERS\n// ////////////////////////////////////////////////////////////////////////////////////////\n\nfunction define (name, patt) {\n  // Create a new sequence:\n  // will call seq_define(name, score)\n  return [name, '@spawn', patt]\n}\n\nfunction wait (n) {\n  if (n != undefined) {\n    n = 1\n  }\n  return [n, '@wait']\n}\nfunction loop (p, n) {\n  if (n != undefined) {\n    return [n, '@repeat', p]\n  }\n  return ['@loop', p]\n}\nfunction print (msg) {\n  return [msg, '@print']\n}\nfunction reverse (p) {\n  return ['@reverse', p]\n}\nfunction shuffle (p) {\n  return ['@shuffle', p]\n} // Shuffle\nfunction rotate (p, n) {\n  return [n != undefined ? n : 1, '@rotate', p]\n}\nfunction chance (f, pt, pf) {\n  return [f, '@chance', pt, pf]\n}\nfunction cond (f, pt, pf) {\n  return [f, '@cond', pt, pf]\n}\nfunction sub (a, b) {\n  return [a, b, '@sub']\n}\nfunction pick (l) {\n  return ['@pick', l]\n}\nfunction alt (l) {\n  return ['@iter', l]\n}\nfunction execute (l, args) {\n  if (args != undefined) {\n    return [l, '@execute', args]\n  }\n  return [l, '@execute']\n}\n\n// Just a convenience\n// every(3, p) actually creates cond(alt([0,0,1]),p)\n// neat eh?\nfunction every (n, p) {\n  // TODO assert n must be integer\n  const l = []\n  for (let i = 0; i < n - 1; i++)    {\n    l.push(0)\n  }\n  l.push(1)\n  return cond(alt(l), p)\n}\n\n// ////////////////////////////////////////////////////////////////////////////////////////\n// // TEST:\n// ////////////////////////////////////////////////////////////////////////////////////////\n\n/*\nscore = loop([\n  //[reverse([print(\"A\"), chance( 1, print(sub(3, 2)) )])],\n\n    //chance(0.5, execute([2, \"rotate\"])), // will sometimes transform the pattern that follows:\n    //every(3, execute(\"shuffle\")),\n    cond(alt([0, 0, 1]), execute([1, \"pre-rotate\"])),\n    [print(\"A\"), print(\"B\"), print(\"C\")],\n    rotate([print(\"x\"), print(\"y\"), print(\"z\"), print(\"_\")], alt([1, -2])),\n    chance(0.5, print(\"BOOOO\")),\n    //cond(alt([0,1,0]), print(\"YES\"), print(\"NO\")),\n    [\"@iter\",[0,1,0]],\"@cond\",[\"YES\",\"@print\"],[\"NO\",\"@print\"],\n    \"@iter\", [440, 550, 660], \"@freq\",\n    \"@pluck\",\n\n  print(\"___________\")\n];\n*/\n\n/*\nscore = [\"@loop\", 4, [\n  //[\"@chance\", 0.5, [\"@print\", [\"@binexpr\", \"sub\", [\"@pick\", 3, 4], 2]]],\n  [\"@reverse\", [\n    [\"@print\", \"A\"],\n    [\"@print\", \"B\"],\n  ]],\n  [\"@print\", \"---------\"],\n]]\n*/\n\n/*\n\nvar score = loop([\n  //loop([print(1), print(2)])\n  //[\"@loop\",[[1,\"@print\"],[2,\"@print\"]]]\n  //loop([print(1), print(2)], 3)\n  //[3,\"@repeat\",[[1,\"@print\"],[2,\"@print\"]]]\n  chance(0.4, print(\"X\")), wait(), print(\"Y\")\n],10);\n\nvar q = new Q(score);\n//q.debug = true;\n\nvar pq = new PQ(score);\n//pq.push(q);\n\npq.resume(5);\npq.connect();\n\nconsole.log(JSON.stringify(pq));\n*/\n\n/*\n  Question -- what happens when we trigger stuff?\n\n  Case 0: any bit of code should be able to spawn a *named* player, so that this can later be stopped/replaced. [name \"@spawn\" patt] => seq_define(name, patt)\n\n  Case 1: just grabbed a random bit of text and triggered it. It should run independently.\n\n  Case 2: run any bit of code, it should replace everything? Like replacing the 'default' player. Maybe, or maybe just have a key combo for 'stop everything first, then run this'?\n\n  Case 3: have named patterns, which don't play by default (but can be used by other processes). Then have named players, that can use them.\n*/\n"],"names":["PQ","score","name","t","external","heap","context","fork","this","s","sequencers","undefined","disconnect","Q","pq","parentQ","rate","todo","stack","debug","push","console","log","Gibberish","MIDI","uid","id","init","Time","export","Binops","bpm","sr","sampleRate","bpm2bpa","kick","Kick","decay","connect","snare","Snare","snappy","hat","Hat","amp","conga","Conga","freq","tom","Tom","strings","PolyKarplusStrong","maxVoices","bass","MonoSynth","beats","ScheddVM","spawns","seq","cq","tick","linked","resume","t0","Math","floor","beat","cmds","length","cmd","shift","clear","k","send","play_element_value","element","define","JSON","parse","value","play_element_text","innerText","document","selection","empty","getSelection","sel","removeAllRanges","Array","isArray","stop","_seq","external_resume","t1","prototype","indexOf","dirty","idx","splice","q","i","p","at","runaway_limit","pop","error","get","val","v","step","stringify","item","charAt","op","substring","n","Number","args","msg","join","ctx","abs","a1","patt","loop","dst","apply","rpts","list","random","first","prob","pt","arg","slice","reverse","rot","copy","instr","test","b","a","wrap","ohi","olo","ihi","ilo","chan","vel","pitch","dur","controller","damping","note","velocity","flush","getSeq"],"mappings":"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"}
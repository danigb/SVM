{"version":3,"file":"ScheddVM.js","sources":["../src/operator.js","../src/audio.js","../src/scope.js","../src/process.js","../src/scheduler.js","../src/commands.js"],"sourcesContent":["// ## The Operator\n\n// An operator uses a collection of commands to execute an instruction\n// The process uses the operator to run its operations\nexport class Operator {\n  constructor (...libraries) {\n    this.commands = {}\n    libraries.forEach(lib => add(this.commands, lib))\n  }\n\n  // Create a new operator with the given commands\n  use (library) {\n    return new Operator(this.commands, library)\n  }\n\n  execute (op, process) {\n    const fn = this.commands[op]\n    if (!fn) throw Error('Operation not valid: ' + op)\n    return fn(process)\n  }\n}\n\n// (private) Add libraries to a library\nfunction add (dest, src) {\n  Object.keys(src).forEach(key => {\n    let fn = src[key]\n    // if is not a function, should be an alias\n    while (typeof fn !== 'function') fn = src[fn]\n    if (!fn) throw Error('The given key is not an operator: ' + key)\n    // add the function to the destination library\n    dest[key] = fn\n  })\n}\n\nimport * as cmds from './commands'\n// The default operator includes all commands\nexport const defaultOperator = new Operator(\n  cmds.process,\n  cmds.schedule,\n  cmds.repeat,\n  cmds.debug\n)\n","import { Scheduler } from './scheduler'\nimport { defaultOperator } from './operator'\n\nlet sampleRate = null\nlet bpm2time = null\nlet instrumentCmds = null\n\n// The audio is initialized the first time an Audio object is created\nfunction initAudio (Gibberish) {\n  // prevent multiple initializations\n  if (sampleRate === null) {\n    Gibberish.init()\n    sampleRate = Gibberish.context.sampleRate\n    bpm2time = 1 / (60 * sampleRate)\n    const inst = initInstruments(Gibberish, instConfig)\n    instrumentCmds = createCommands(inst, cmdConfig)\n  }\n}\n\nexport class Audio {\n  constructor (Gibberish, bpm = 100) {\n    initAudio(Gibberish)\n    this.schedulers = []\n    this.commands = []\n    this.bpm = bpm\n    Gibberish.sequencers.push(this)\n  }\n  tick (t) {\n    while (this.commands.length > 0) {\n      const cmd = this.commands.shift()\n      cmd()\n    }\n    const len = this.schedulers.length\n    const duration = this.bpm * bpm2time\n    for (let i = 0; i < len; i++) {\n      this.schedulers[i].tick(duration)\n    }\n  }\n  start (program, operator = defaultOperator) {\n    const withInstruments = operator.use(instrumentCmds)\n    const s = new Scheduler(withInstruments)\n    s.run(program)\n    this.schedulers.push(s)\n    return s\n  }\n}\n\n// This is the instruments configuration\nconst instConfig = {\n  'Kick': { decay: 0.2 },\n  'Snare': {snappy: 1.5},\n  'Hat': {amp: 1.5},\n  'Conga': {amp: 0.25, freq: 400},\n  'Tom': {amp: 0.25, freq: 400},\n  'PolyKarplusStrong': {maxVoices: 32},\n  'MonoSynth': {\n    attack: 44,\n    decay: 0.25, // FIXME(danigb) -- it was: Gibberish.Time.beats(0.25),\n    filterMult: 0.25,\n    octave2: 0,\n    octave3: 0\n  }\n}\n\n// **Trigger functions**\n\n// A trigger function receives the instrument and the parameters\nconst tr1 = (inst, p) => inst.note(p)\n// trigger an instrument with 2 params\nconst tr2 = (inst, p1, p2) => inst.note(p1, p2)\n// the bass is only triggered if the frequency is positive\n// the bass is only triggered if the frequency is positive\nconst trBass = (bass, amp, freq) => {\n  if (freq > 0) bass.note(amp, freq)\n}\n// trigger the pluck requires adjust dump and compensate volume\nconst trPluck = (strings, amp, freq, sampleRate) => {\n  if (freq > 0) {\n    // This is not in any way accurate, just a hack to make @set-dur do something semi-meaningful\n    strings.damping = 1 - -6 / Math.log(freq / sampleRate)\n    // Strings by default seem too quiet:\n    strings.note(freq, amp * amp * 2)\n  }\n}\n\n// ## Instrument commands\n\n// | Name | Description | Example |\n// |------|-------------|---------|\n// | **@pluck** | Trigger a string sound | `@pluck` |\n// | **@pluck-note** | Trigger a string sound passing parameters | `freq, amp, @pluck` |\n// | **@bass** | Trigger a bass sound | `@bass` |\n// | **@bass-note** | Trigger a bass sound passing parameters | `freq, amp, @bass` |\nconst cmdConfig = {\n  'pluck': ['Pluck', 'amp', 'freq', trPluck],\n  'bass': ['Bass', 'amp', 'freq', trBass],\n  'kick': ['Kick', 'amp', null, tr1],\n  'snare': ['Snare', 'amp', null, tr1],\n  'hat': ['Hat', 'amp', null, tr1],\n  'conga': ['Conga', 'amp', 'freq', tr2],\n  'tom': ['Tom', 'amp', 'freq', tr2]\n}\n\n// Given a instruments configuration, create the Giberish instruments\nfunction initInstruments (Gibberish, config) {\n  return Object.keys(config).reduce((instruments, name) => {\n    // Create the instrument with the given configuration and connect\n    const inst = new Gibberish[name](config[name]).connect()\n    instruments[name] = inst\n    return instruments\n  }, {})\n}\n\nfunction createCommands (instruments, config) {\n  return Object.keys(config).reduce((cmds, name) => {\n    const cmdConfig = config[name]\n    const inst = instruments[cmdConfig[0]]\n    cmds['@' + name] = fromScope(inst, cmdConfig)\n    cmds['@' + name + '-note'] = fromStack(inst, cmdConfig)\n    return cmds\n  }, {})\n}\n\n// Create an instrument command that get the parameters from scope\n// example: `['@pluck']`\nfunction fromScope (inst, [_, name1, name2, trigger]) {\n  return ({ scope }) => trigger(inst, scope.get(name1), scope.get(name2))\n}\n\n// Create an instrument command that get the parameters from the stack\n// example: `[0.2, 05, '@pluck-note']`\nfunction fromStack (inst, [_, name1, name2, trigger]) {\n  return ({ stack }) => trigger(inst, stack.pop(), name2 ? stack.pop() : undefined)\n}\n","// ## The scope\n\nexport class Scope {\n  // Create a scope\n  constructor (parent) {\n    this.parent = parent\n    this.data = undefined\n  }\n  // set a key in the local scope\n  let (key, value) {\n    if (!this.data) this.data = {}\n    this.data[key] = value\n  }\n  // test if a key is in the local scope\n  ownsKey (key) {\n    return this.data && this.data[key] !== undefined\n  }\n  // get a key from all the scope hierarchy\n  get (key) {\n    let target = this\n    while (target && !target.ownsKey(key)) target = target.parent\n    return target && target.data ? target.data[key] : undefined\n  }\n  // set a key in al the scope hierarchy\n  // it sets the first key found or the root scope\n  set (key, value) {\n    let target = this\n    while (!target.ownsKey(key) && target.parent) target = target.parent\n    target.let(key, value)\n  }\n}\n","// # The processing unit\nimport { Scope } from './scope'\n\nconst isArray = Array.isArray\nconst isOperation = (obj) => typeof obj === 'string' && obj[0] === '@'\n\n// # Process\n\n// The basic element is the Process\n// The processing unit has a stack and a queue of operations\n// But it departures from other other stack machines in that\n// it has time related information: the time of the\n// proceessing unit and the rate at the time flows.\nexport class Process {\n  // Normally the process are created by the scheduler\n  constructor (scope, program, time, rate) {\n    this.scope = new Scope(scope)\n    this.stack = []\n    this.operations = []\n    this.time = time || 0\n    this.rate = rate || 1\n    if (program) this.operations.push(program)\n  }\n\n  // wait an amount of time\n  wait (time) {\n    this.time += this.rate * time\n  }\n\n  // Run a single operation\n  step (operator) {\n    const { operations } = this\n    // has operations?\n    if (operations.length) {\n      const op = operations.pop()\n      if (op === null || op === undefined) {\n        // ignore\n      } else if (isArray(op)) {\n        // if it's an array, add to the operations in reverse order\n        for (let i = op.length - 1; i >= 0; i--) operations.push(op[i])\n      } else if (isOperation(op)) {\n        // execute the operation\n        operator.execute(op, this)\n      } else {\n        // if it's a value, push it into the stack\n        this.stack.push(op)\n      }\n    }\n  }\n\n  // run the proccess until a time or finised its operations\n  // (or reach a limit in order to prevent infinite loops)\n  resume (operator, time = Infinity, limit = 1000) {\n    while (--limit > 0 && this.time < time && this.operations.length) {\n      this.step(operator)\n    }\n    if (limit === 0) throw Error('Run limit reached. Probably an infinite loop.')\n    return this.operations.length > 0\n  }\n}\n","import { Scope } from './scope'\nimport { Process } from './process'\n\n// The scheduler is capable of run several processes at the same time\nexport class Scheduler {\n  constructor (operator, name = 'default') {\n    this.name = name\n    this.nextId = 0\n    this.scope = new Scope()\n    this.operator = operator\n    // procs are stored inverse ordered by time\n    // where the next element (smaller time) is always the last\n    this.procs = []\n    this.time = 0\n  }\n\n  tick (length) {\n    this.resume(this.time + length)\n  }\n\n  // will run the processes interleaved until the given time\n  resume (time = Infinity, limit = 1000) {\n    const { procs } = this\n    while (--limit > 0 && this.at() < time) {\n      const proc = procs.pop()\n      if (proc.resume(this.operator, time)) {\n        // the proc has more operations, re-schedule\n        this.schedule(proc)\n      }\n    }\n    this.time = time\n  }\n\n  // return the time of the next proc\n  at () {\n    const len = this.procs.length\n    return len ? this.procs[len - 1].time : Infinity\n  }\n\n  // this creates a new process with the given program\n  run (program, time) {\n    return this.schedule(new Process(this.scope, program, time, 1))\n  }\n  // create a child process with the given program\n  fork (parent, program, delay = 0) {\n    return this.schedule(new Process(parent.scope, program, parent.time + delay, 1))\n  }\n  // schedule a process\n  schedule (process) {\n    // Add the scheduler to the process\n    process.scheduler = this\n    if (!process.id) process.id = this.name + '-' + this.nextId++\n\n    if (this.procs.length === 0) {\n      // no need to sort: just push it\n      this.procs.push(process)\n    } else {\n      // procs are sorted on insertion\n      let i = this.procs.length - 1\n      let p = this.procs[i]\n      while (p && p.time <= process.time) {\n        i--\n        p = this.procs[i]\n      }\n      this.procs.splice(i + 1, 0, process)\n    }\n    return process\n  }\n}\n","// # Commands\nconst isArray = Array.isArray\n\n// Commands are functions that receives a `process` object and performs an operation\n\n// ## Basic commands\n\n// This are the core operations: execute instructions, modify\n// process time and scope variables\n\n// | Name | Description | Example |\n// |------|-------------|---------|\n// | **@dup** | Duplicate item (so you can use it twice) | `10,@dup` |\n// | **@execute** | Execute an instruction | `10,'dup','@execute'` |\n// | **@** | Alias of @execute | `10,'dup','@'` |\n// | **@let** | Assign a value to the local scope | `10,'repetitions',@let` |\n// | **@set** | Assign a value to the global scope | `10,'parts',@set` |\n// | **@get** | Push the value of a variable into the stack | `'repetitions',@get` |\n// | **@wait** | Wait an amount of time | `1,@wait` |\nexport const process = {\n  '@dup': ({ stack }) => stack.push(stack.pop(stack.length - 1)),\n  '@execute': ({ stack }) => {\n    const instr = stack.pop()\n    if (typeof instr !== 'string') throw Error('Trying to execute something that is not a string: ' + instr)\n    stack.push('@' + instr)\n  },\n  '@': '@execute',\n\n  '@let': ({ stack, scope }) => scope.let(stack.pop(), stack.pop()),\n  '@set': ({ stack, scope }) => scope.set(stack.pop(), stack.pop()),\n  '@get': ({ stack, scope }) => stack.push(scope.get(stack.pop())),\n\n  '@wait': (process) => process.wait(Math.abs(Number(process.stack.pop())))\n}\n\n// ## Schedule commands\n\n// | Name | Description | Example |\n// |------|-------------|---------|\n// | **@fork** | Fork | `@fork, [0.5, '@wait', '@kick']` |\nexport const schedule = {\n  '@fork': (proc) => {\n    const { operations, scheduler } = proc\n    const pattern = operations.pop()\n\n    if (!scheduler) throw Error(\"Fork error - Can't fork a process without scheduler.\")\n    if (!isArray(pattern)) throw Error('Fork error - not valid pattern: ' + pattern)\n    scheduler.fork(proc, pattern)\n  }\n}\n\n// ## Repeat and loop\n\n// | Name | Description | Example |\n// |------|-------------|---------|\n// | **@repeat** | Repeat a pattern | `4, @repeat, ['@kick', 0.5, '@wait']` |\nexport const repeat = {\n  '@repeat': ({ stack, operations }) => {\n    const repetitions = stack.pop()\n    const pattern = operations[operations.length - 1]\n    if (!isArray(pattern)) throw Error(\"Can't repeat: \" + pattern)\n    for (let i = 1; i < repetitions; i++) {\n      operations.push(pattern)\n    }\n  }\n}\n\n// ## Debug operations\n\n// | Name | Description | Example |\n// |------|-------------|---------|\n// | **@print** | Print the last value of the stack | `10,@print` |\nexport const debug = {\n  '@print': (proc) => {\n    const stack = proc.stack\n    const last = stack.length ? stack.pop() : '<Empty Stack>'\n    console.log('@print', last, '(id, time)', proc.id, proc.time)\n  }\n}\n"],"names":["add","dest","src","keys","forEach","fn","key","Error","initAudio","Gibberish","sampleRate","init","context","createCommands","initInstruments","instConfig","cmdConfig","config","Object","reduce","instruments","name","inst","connect","cmds","fromScope","fromStack","name1","name2","trigger","scope","get","stack","pop","undefined","Scope","parent","data","value","this","target","ownsKey","let","isArray","Array","isOperation","obj","Process","program","time","rate","operations","push","operator","length","op","i","execute","Infinity","limit","step","Scheduler","nextId","procs","resume","at","proc","schedule","len","delay","process","scheduler","id","p","splice","instr","set","wait","Math","abs","Number","pattern","fork","repeat","repetitions","debug","last","log","Operator","commands","libraries","_this","lib","library","defaultOperator","bpm2time","instrumentCmds","Audio","bpm","schedulers","sequencers","t","shift","duration","tick","withInstruments","use","s","run","decay","snappy","amp","freq","maxVoices","tr1","note","tr2","p1","p2","trBass","bass","trPluck","strings","damping"],"mappings":"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"}
{"version":3,"file":"ash-vm.js","sources":["../../src/process.js","../../src/vm.js","../../src/audio/gibberish.js","../../src/audio/waa.js","../../src/cmds/random.js","../../src/cmds/debug.js","../../src/cmds/compatibility.js","../../src/index.js","../../src/utils.js","../../src/context.js","../../src/audio/driver.js","../../src/cmds/stdlib.js","../../src/cmds/list.js"],"sourcesContent":["// # Process\nimport Context from \"./context\"\n\n// #### Utilities\n// defer a function\nfunction defer (fn, data) { setTimeout(() => { fn(data) }, 0) }\n// test if the given operation is an instruction name\nconst isCommand = o => typeof o === \"string\" && o[0] === \"@\"\n// test if the given operation is a program\nconst isProgram = Array.isArray\n// Give unique ids to process\nlet procId = 1\n\n// #### Error messages\n\n// The given instruction name is not in the commands object\nconst ERR_INSTR_NOT_FOUND = \"Instruction not recognized.\"\n// The max loop cycles tests\nconst ERR_LIMIT_REACHED = \"Limit reached. Probably an infinity loop.\"\n\n// ## Process\n\n// Processes are the principal computation unit. The main characteristic of\n// processes in this VM is that it models the concept of time\nexport class Process {\n  constructor (program, context, time, rate) {\n    this.id = \"proc-\" + procId++\n    // a stack of values\n    this.stack = []\n    // the operations are also stored in a stack (reverse order)\n    this.operations = program ? [program] : []\n    // the context is used to store variables with scope\n    this.context = new Context(context)\n    // the current time\n    this.time = typeof time === \"number\" ? time : 0\n    // how fast time passes\n    this.rate = typeof rate === \"number\" ? rate : 1\n    // bind error to this, to allow destructuring it in commands\n    this.error = this.error.bind(this)\n  }\n\n  // wait an amount of time\n  wait (time) {\n    this.time += this.rate * time\n  }\n\n  // The process is agnostic about the commands to be use\n  step (commands) {\n    const { operations } = this\n    if (operations.length) {\n      const instr = operations.pop()\n      if (instr === null || instr === undefined) {\n        // ignore\n      } else if (typeof instr === \"function\") {\n        // it runs the functions but outside the loop\n        defer(instr, this)\n      } else if (isProgram(instr)) {\n        // if it\"s program, and since the operations are stored into an stack,\n        // we need add to the program operations in reverse order\n        for (let i = instr.length - 1; i >= 0; i--) {\n          operations.push(instr[i])\n        }\n      } else if (isCommand(instr)) {\n        const cmd = commands[instr]\n        if (typeof cmd === \"function\") cmd(this)\n        else this.error(\"step > \", ERR_INSTR_NOT_FOUND, instr)\n      } else {\n        // if it\"s a value, push it into the stack\n        this.stack.push(instr)\n      }\n    }\n  }\n\n  // the `resume` function run all the operations until time is reached\n  resume (commands, time = Infinity, limit = 10000) {\n    const { operations } = this\n    while (--limit > 0 && this.time < time && operations.length) {\n      this.step(commands)\n    }\n    if (limit === 0) throw Error(ERR_LIMIT_REACHED)\n    return operations.length > 0\n  }\n\n  // an utility function to write errors\n  error (instr, msg, obj) {\n    console.error(instr, msg, obj, \"id\", this.id, \"time\", this.time)\n  }\n}\n","// # VM\n\nimport { isArray, isString, isFn } from \"./utils\"\nimport { Process } from \"./process\"\n\n// **Error messages**\nexport const ERR_EXPECT_PATTERN = \"Expected a pattern, but found:\"\nexport const ERR_EXPECT_STRING = \"Expected a string, but found:\"\n\nconst assign = Object.assign\n\n// The purpose of the VM is to run processes concurrently. It also\n// mantains an extensible object of commands (operations mapped to functions)\n// that allows to add operations to the vm\n\n// TODO: probably is better to have functions and object instead of classes\n// will change in the future.\nexport class VM {\n  constructor (options = {}) {\n    this.context = Object.assign({}, options.context)\n    this.procs = [] // the procs are inverse ordered by time\n    this.procsByName = {} // a map of names to procs\n    this.time = 0\n    this.commands = createCommands(this)\n    this.onfork = options.onfork\n    this.onstop = options.onstop\n    this.onended = options.onended\n  }\n\n  // Run a program\n  run (program, sync = true) {\n    // if there are no processes, no need to sync\n    if (sync && this.procs.length) program = [\"@sync\", program]\n    return this.fork(null, this.context, program)\n  }\n\n  // Add to the initial context\n  addContext (context) {\n    Object.assign(this.context, context)\n    return this.context\n  }\n\n  // Add more commands\n  addCommands (commands) {\n    if (isFn(commands)) commands = commands(this)\n    if (commands) assign(this.commands, expandAliases(commands))\n  }\n\n  // Create a new process\n  fork (name, parent, program, delay = 0, rate) {\n    const time = this.time + delay\n    // if has parent and no rate, try to use it\"s rate\n    if (!rate && parent) rate = parent.rate\n    // if has parent try to use it\"s context\n    const context = parent ? parent.context || parent : undefined\n    // create the new process and insert into the process stack\n    const proc = new Process(program, context, time, rate)\n    insert(proc, this.procs)\n    // if has name, register it\n    if (name) this.procsByName[name] = proc\n    if (this.onfork) this.onfork({ proc, name, parent, program, delay, rate })\n    return proc\n  }\n\n  // run the vm for the given amount of time (Infinity if not specified)\n  resume (dur = Infinity, limit = 10000) {\n    const { procs } = this\n    if (procs.length > 0) {\n      const nextTime = this.time + dur\n      while (--limit > 0 && at(procs) < nextTime) {\n        const proc = procs.pop()\n        if (proc.resume(this.commands, nextTime)) {\n          // the proc has more operations, re-schedule\n          insert(proc, this.procs)\n        } else {\n          if (this.onended) this.onended({ proc, time: this.time })\n        }\n      }\n      this.time = nextTime\n    } else {\n      this.time += dur\n    }\n    return procs.length > 0\n  }\n\n  stopAll () {\n    this.procs.length = 0\n  }\n\n  // The stop function can stop a proccess by name or by object\n  stop (name) {\n    let proc\n    if (typeof proc === \"string\") {\n      proc = this.procsByName[name]\n      this.procsByName[name] = null\n    } else {\n      proc = name\n      name = null\n    }\n    if (this.onstop) this.onstop({ name, proc })\n\n    remove(proc, this.procs)\n  }\n}\n\n// ## VM commands\n\n// | Name | Description | Example |\n// |------|-------------|---------|\n// | **@fork** | Fork | `@fork, [0.5, \"@wait\", \"@kick\"]` |\n// | **@spawn** | Spawn | `\"melody\", \"@spawn\", [0.5, \"@wait\", \"@kick\"]` |\n// | **@stop** | Stop current process | `@stop` |\n// | **@stop-all** | Stop all processes | `@stop-all` |\nfunction createCommands (vm) {\n  return {\n    \"@loop\": proc => {\n      const { operations, error } = proc\n      const pattern = operations.pop()\n      if (isArray(pattern)) vm.fork(null, proc, [\"@forever\", pattern])\n      else error(\"@loop\", ERR_EXPECT_PATTERN, pattern)\n    },\n    \"@fork\": proc => {\n      const { operations, error } = proc\n      let pattern = operations.pop()\n\n      if (isArray(pattern)) {\n        vm.fork(null, proc, pattern)\n      } else {\n        error(\"@fork\", ERR_EXPECT_PATTERN, pattern)\n      }\n    },\n    \"@spawn\": proc => {\n      const { stack, operations, error } = proc\n      const name = stack.pop()\n      let pattern = operations.pop()\n      if (!isString(name)) {\n        error(\"@spawn\", ERR_EXPECT_STRING, name)\n      } else if (!isArray(pattern)) {\n        error(\"@spawn\", ERR_EXPECT_PATTERN, pattern)\n      } else {\n        vm.stop(name)\n        vm.fork(name, proc, [\"@forever\", pattern])\n      }\n    },\n    \"@stop-all\": proc => vm.stopAll(),\n    \"@stop\": ({ stack }) => vm.stop(stack.pop())\n  }\n}\n\n// ## Internal VM functions\n\n// remove a process process\nfunction remove (proc, procs) {\n  let i = procs.length - 1\n  while (i >= 0 && procs[i] !== proc) {\n    i--\n  }\n  // if found, remove it\n  if (i !== -1) procs.splice(i, 1)\n  return i !== -1\n}\n\n// insert a process into a stack ordered by time\n// (in fact, is inverse order because it\"s a stack)\nfunction insert (proc, procs) {\n  if (procs.length === 0) {\n    // no need to sort: just push it\n    procs.push(proc)\n  } else {\n    // procs are sorted on insertion\n    let i = procs.length - 1\n    let p = procs[i]\n    while (p && p.time <= proc.time) {\n      i--\n      p = procs[i]\n    }\n    procs.splice(i + 1, 0, proc)\n  }\n  return proc\n}\n\n// get time of the next process\nfunction at (procs) {\n  const len = procs.length\n  return len ? procs[len - 1].time : Infinity\n}\n\n// Given a commands object, expand the aliases\nfunction expandAliases (commands) {\n  Object.keys(commands).forEach(name => {\n    const op = commands[name]\n    if (isString(op)) commands[name] = commands[op]\n  })\n  return commands\n}\n","// # Gibberish Audio Driver\nimport { AudioDriver } from \"./driver\"\n\n// This driver uses Gibberish both for scheduling and sounds\n\n/**\n * Create a VM plugin to add the audio driver\n * @return {Function} a VM plugin\n */\nexport default function init (Gibberish, options = {}) {\n  if (!Gibberish.context) Gibberish.init()\n  const audio = new GibberishDriver(Gibberish, options.bpm || 120)\n  audio.addInstruments(createInstruments(Gibberish))\n  return audio\n}\n\nclass GibberishDriver extends AudioDriver {\n  constructor (Gibberish, bpm) {\n    super(bpm, Gibberish.context.sampleRate)\n    this.Gibberish = Gibberish\n  }\n\n  // Start a VM\n  start (vm) {\n    super.start(vm)\n    // convert bmp to beats per audio sample\n    const bpm2bpa = 1 / (60 * this.sampleRate)\n    // tick is binded to this\n    this.tick = () => vm.resume(this.bpm * bpm2bpa)\n    this.Gibberish.sequencers.push({ tick: this.tick })\n  }\n}\n\n// # Instruments\n\n// Create a trigger function for a percussion instrument\nconst perc = (inst, gain) => (ctx) => {\n  inst.amp = gain * ctx.get(\"amp\")\n  inst.note()\n}\n\n// Create a trigger function for a tuned percussion instrument\nconst pitched = (inst, gain) => (ctx) => {\n  inst.amp = gain * ctx.get(\"amp\")\n  inst.pitch = ctx.get(\"freq\")\n  inst.note()\n}\n\n// Create the basic instruments using Gibberish\nfunction createInstruments (Gibberish) {\n  // The actual instruments\n  const kick = new Gibberish.Kick({ decay: 0.2 }).connect()\n  const snare = new Gibberish.Snare({ snappy: 1.5 }).connect()\n  const hat = new Gibberish.Hat({ amp: 1.5 }).connect()\n  const conga = new Gibberish.Conga({ amp: 0.25, freq: 400 }).connect()\n  const tom = new Gibberish.Tom({ amp: 0.25, freq: 400 }).connect()\n  const pluck = new Gibberish.PolyKarplusStrong({maxVoices: 32}).connect()\n  const bass = new Gibberish.MonoSynth({\n    attack: 44,\n    decay: Gibberish.Time.beats(0.25),\n    filterMult: 0.25,\n    octave2: 0,\n    octave3: 0\n  }).connect()\n  const sampleRate = Gibberish.sampleRate\n\n  // The instrument trigger functions\n  return {\n    kick: perc(kick, 0.5),\n    snare: perc(snare, 0.25),\n    hat: perc(hat, 1),\n    conga: pitched(conga, 0.25),\n    tom: pitched(tom, 0.25),\n    pluck: (ctx) => {\n      const amp = ctx.get(\"amp\")\n      const freq = ctx.get(\"freq\")\n      if (freq > 0) {\n        // this is not in any way accurate, just a hack to make @set-dur do something semi-meaningful\n        pluck.damping = 1 - (-6 / Math.log(freq / sampleRate))\n        // pluck by default seem too quiet:\n        pluck.note(freq, amp * amp * 2)\n      }\n    },\n    bass: (ctx) => {\n      const velocity = ctx.get(\"amp\")\n      const freq = ctx.get(\"freq\")\n      if (freq > 0) bass.note(freq, velocity)\n    }\n  }\n}\n","// # Web Audio API Audio Driver\n/* global AudioContext */\nimport { AudioDriver, ERR_INST_MISSING } from \"./driver\"\n\nconst timeToBeats = (time, bpm) => time * bpm / 60\nconst beatsToTime = (beats, bpm) => beats * 60 / bpm\n\nexport default function init (context, options = {}) {\n  context = context || new AudioContext()\n  const audio = new WebAudioDriver(context, options.bpm || 120)\n  audio.addInstruments(createInstruments(context))\n  return audio\n}\n\n// ## Audio driver\nclass WebAudioDriver extends AudioDriver {\n  constructor (audioContext, bpm) {\n    super(bpm, audioContext.sampleRate)\n    this.ac = audioContext\n\n    // override the **@play** command to provide `when` paramter to trigger\n    this.commands[\"@play\"] = ({ time, context, error }) => {\n      const when = beatsToTime(time, this.bpm) + this.zero\n      const inst = context.get(\"voice\")\n      const trigger = this.instruments[inst]\n      if (!trigger) error(\"@play\", ERR_INST_MISSING(inst))\n      else trigger(context, when)\n    }\n  }\n\n  start (vm) {\n    super.start(vm)\n    const step = 0.1\n    this.zero = this.ac.currentTime\n    clock(this.ac, (time) => {\n      vm.resume(timeToBeats(step, this.bpm))\n    }, step)\n  }\n}\n\n// ## Scheduling\nfunction clock (ac, callback, time) {\n  const lookAhead = time || 0.1\n  const updateInterval = lookAhead / 3\n  let next = ac.currentTime + lookAhead\n  const tick = () => {\n    if (ac.currentTime + lookAhead >= next) {\n      callback(next)\n      next += lookAhead\n    }\n  }\n  tick()\n  return setInterval(tick, updateInterval)\n}\n\n// ## Instruments\n\n// The Web Audio API driver comes with a very simple sound generator\n// (mostly for testing)\nfunction synth (ac, time, freq, amp, decay) {\n  const osc = ac.createOscillator()\n  osc.frequency.value = freq || 200\n  osc.amp = ac.createGain()\n  osc.amp.gain.value = 0\n  osc.connect(osc.amp)\n  osc.amp.connect(ac.destination)\n  osc.start(time)\n  osc.amp.gain.setValueAtTime(0, time)\n  osc.amp.gain.linearRampToValueAtTime(amp * 0.5, time + 0.01)\n  osc.amp.gain.linearRampToValueAtTime(0, time + decay)\n  osc.stop(time + decay + 0.1)\n  return osc\n}\n\n// Create instruments\nconst createInstruments = (ac) => ({\n  kick: (ctx, time) => synth(ac, time, 100, 1, 0.2),\n  snare: (ctx, time) => synth(ac, time, 476, 0.6, 0.2),\n  hat: (ctx, time) => synth(ac, time, 4000, 0.2, 0.1),\n  conga: (ctx, time) => synth(ac, time, 4000, 0.2, 0.1),\n  tom: (ctx, time) => synth(ac, time, 200, 0.4, 0.4),\n  pluck: (ctx, time) => synth(ac, time, ctx.get(\"freq\"), ctx.get(\"amp\"), 0.5),\n  bass: (ctx, time) => synth(ac, time, 0.5 * ctx.get(\"freq\"), ctx.get(\"amp\"), 0.5),\n})\n","// ## Random\nimport { isArray } from \"../utils\"\nimport { ERR_EXPECT_PATTERN } from \"../vm\"\nconst { floor } = Math\n\n// A collection of commands related to randomness\n\n// #### Commands\nexport default function random ({ random } = {}) {\n  // allow to use a custom random function\n  const rnd = random || Math.random\n  // a function that generates integer random from 0 to n\n  const irnd = n => floor(rnd() * n)\n\n  const shuffle = a => {\n    var j, x, i\n    for (i = a.length; i; i--) {\n      j = floor(random() * i)\n      x = a[i - 1]\n      a[i - 1] = a[j]\n      a[j] = x\n    }\n  }\n\n  return {\n    // **@random**: Generate a random number between 0 and 1\n    // `[\"@random\", \"amp\", \"@set\"]`\n    \"@random\": ({ stack }) => stack.push(rnd()),\n\n    // **@rand**: Alias for @random\n    \"@rand\": \"@random\",\n\n    // **@srandom**: Generate a random number between -1 and 1\n    // `[\"@srandom\", \"phase\", \"@set\"]`\n    \"@srandom\": ({ stack }) => stack.push(rnd() * 2 - 1),\n\n    // **@srand**: Alias for @srandom\n    \"@srand\": \"@srandom\",\n\n    // **@randi**: Generate a random integer between 0 and n\n    // `[40, \"@randi\", 20, \"@+\", \"@mtof\", \"freq\", \"@set\"]`\n    \"@randi\": ({ stack }) => stack.push(irnd(stack.pop())),\n\n    // **@pick**: pick a random element from a list\n    // `[\"@list\", [1, 2, 3, 4], \"@pick\", \"amp\", \"@set\"]`\n    \"@pick\": ({ stack, error }) => {\n      const list = stack.pop()\n      if (!isArray(list)) {\n        error(\"Can't pick an element if is not an array\", list)\n      } else {\n        const i = irnd(list.length)\n        stack.push(list[i])\n      }\n    },\n\n    // **@chance* *: Probabilistic execution\n    // [probability, \"@chance\", executed-if-true, executed-if-false]\n    // `[0.5, \"@chance\", [440, \"freq\", \"@set\"], [\"@rand\", \"amp\", \"@set\"]]`\n    \"@chance\": ({ stack, operations }) => {\n      const prob = stack.pop()\n      const ifTrue = operations.pop()\n      if (rnd() < prob) {\n        // Skip the 'false branch'\n        operations.pop()\n        // Set the 'true branch' as the next operation\n        operations.push(ifTrue)\n      } else {\n        // The 'false branch' is currenty the next operation\n        // so there's no need to do anything\n      }\n    },\n\n    // **@shuffle**: Shuffle a list\n    // `[\"@list\", [1, 2, 3], \"@shuffle\", \"@iter\"]`\n    \"@shuffle\": ({ stack, error }) => {\n      const pattern = stack.pop()\n      if (!isArray(pattern)) error(\"@shuffle\", ERR_EXPECT_PATTERN, pattern)\n      else stack.push(shuffle(pattern))\n    }\n  }\n}\n","// # Debug operations\nimport { peek } from \"../utils\"\n\n// | Name | Description | Example |\n// |------|-------------|---------|\n// | **@print** | Print the last value of the stack | `10,\"@print\"` |\n// | **@log** | Log the name with the last value of the stack | `\"@random\", \"amp\", \"@log\"` |\nexport default function debug ({ log } = {}) {\n  log = log || console.log.bind(console)\n\n  return {\n    \"@print\": proc => {\n      const { stack } = proc\n      const last = stack.length ? peek(stack) : \"<Empty Stack>\"\n      log(\"@print\", last, \"(id, time)\", proc.id, proc.time)\n    },\n    \"@log\": proc => {\n      const { stack } = proc\n      const name = stack.pop()\n      const last = stack.length ? peek(stack) : \"<Empty Stack>\"\n      log(\"@log\", name, last, \"(id, time)\", proc.id, proc.time)\n    },\n    \"@debug\": proc => {\n      const { stack } = proc\n      log(\"@debug\", stack, proc.id, proc.time)\n    }\n  }\n}\n","// # Compatibility plugin\n\nimport { isArray } from \"../utils\"\nimport { ERR_EXPECT_PATTERN } from \"../vm\"\n\n// This plugin adds language compatibility to the previous version\n\n// Given an instrument name, returns a command that play that instrument\nconst voice = name => ({ operations }) => {\n  operations.push([name, \"voice\", \"@let\", \"@play\"])\n}\nconst voiceNote = (name, p1, p2) => ({ stack, operations }) => {\n  operations.push(p2\n    ? [stack.pop(), p2, \"@let\", stack.pop(), p1, \"@let\",\n      name, \"voice\", \"@let\", \"@play\"]\n    : [stack.pop(), p1, \"@let\",\n      name, \"voice\", \"@let\", \"@play\"])\n}\n\nexport default function init () {\n  return {\n    // get and set for freq and amp\n    \"@set-freq\": ({ context, stack }) => context.set(\"freq\", stack.pop()),\n    \"@set-amp\": ({ context, stack }) => context.set(\"amp\", stack.pop()),\n    \"@get-freq\": ({ stack, context }) => stack.push(context.get(\"freq\")),\n    \"@get-amp\": ({ stack, context }) => stack.push(context.get(\"amp\")),\n\n    // I think reverse is not very useful in this context\n    // because: [\"@iter\", [\"@reverse\", [1, 2, 3]]] doesn\"t work, for example\n    \"@reverse\": ({ operations, error }) => {\n      const pattern = operations.pop()\n      if (!isArray(pattern)) error(\"@reverse\", ERR_EXPECT_PATTERN, pattern)\n      else operations.push(pattern.slice().reverse())\n    },\n    // I think @map is not a good name\n    \"@map\": \"@linear\",\n\n    // Instrument names\n    \"@pluck\": voice(\"pluck\"),\n    \"@pluck-note\": voiceNote(\"pluck\", \"freq\", \"amp\"),\n    \"@bass\": voice(\"bass\"),\n    \"@bass-note\": voiceNote(\"bass\", \"freq\", \"amp\"),\n    \"@hat\": voice(\"hat\"),\n    \"@hat-note\": voiceNote(\"hat\", \"amp\"),\n    \"@kick\": voice(\"kick\"),\n    \"@kick-note\": voiceNote(\"kick\", \"amp\"),\n    \"@snare\": voice(\"snare\"),\n    \"@snare-note\": voiceNote(\"snare\", \"amp\"),\n    \"@conga\": voice(\"conga\"),\n    \"@conga-note\": voiceNote(\"conga\", \"amp\"),\n    \"@clave\": voice(\"clave\"),\n    \"@clave-note\": voiceNote(\"clave\", \"amp\"),\n    \"@tom\": voice(\"tom\"),\n    \"@tom-note\": voiceNote(\"tom\", \"amp\"),\n  }\n}\n","// # Audio Scheduler Virtual Machine\nimport { VM } from \"./vm\"\nimport gibberish from \"./audio/gibberish\"\nimport waa from \"./audio/waa\"\nimport stdlib from \"./cmds/stdlib\"\nimport random from \"./cmds/random\"\nimport list from \"./cmds/list\"\nimport debug from \"./cmds/debug\"\nimport compatibility from \"./cmds/compatibility\"\n\n// ## Architecture Overview\n\n// The main purpose of the virtual machine is to run processes concurrently.\n// It holds a `commands` object (that maps instruction names to functions)\n// and schedules a collection of `processes`. Each **process** has an values `stack`\n// and `operations` stack (to be executed).\n\n// ## API\nexport function initGibberish (Gibberish, options) {\n  return init(gibberish, Gibberish, options)\n}\n\nexport function initWebAudio (context, options) {\n  return init(waa, context, options)\n}\n\n// the init function creates a vm controlled by Gibberish\nexport function init (driver, audio, options = {}) {\n  const { plugins } = options\n  // Create the virtual machine\n  const vm = new VM(options)\n  // Install the audio driver\n  driver(audio, options).start(vm)\n\n  // Include all the commands\n  vm.addCommands(stdlib)\n  vm.addCommands(list)\n  vm.addCommands(random(options))\n  vm.addCommands(debug(options))\n  vm.addCommands(compatibility(options))\n  // Add the plugins if any\n  if (plugins) plugins.forEach(cmds => vm.addCommands(cmds))\n\n  return vm\n}\n","// # Utilities\n\n// A collection of shared utility functions\n\n// copy values from one or more sources to a target\n// see: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\nexport const assign = Object.assign\n\n// test if an object is an array\nexport const isArray = Array.isArray\n\n// test if an object is a string\nexport const isString = x => typeof x === \"string\"\n\n// test if an object is a function\nexport const isFn = x => typeof x === \"function\"\n\n// test if an object is a number\nexport const isNum = x => typeof x === \"number\"\n\n// test if an object is defined\nexport const isDef = x => typeof x !== \"undefined\"\n\n// get last element from an array\nexport const last = a => a[a.length - 1]\n\n// get the next element of stack without remove it\nexport const peek = last\n","// # Context\n\n// A context is a hierarchical structure to store values with different\n// scopes. Every process has it's own context.\nexport default class Context {\n  // Every context has a parent. The parent can be another context\n  // or an object\n  constructor (parent) {\n    if (parent instanceof Context) this.parent = parent\n    else if (parent) this.local = Object.assign({}, parent)\n  }\n\n  // Create a child context with the given locals\n  child (local) {\n    const c = new Context(this)\n    if (local) c.local = Object.assign({}, local)\n    return c\n  }\n  // get a value from a context\n  get (id) {\n    let target = this\n    while (target.value(id) === undefined && target.parent) {\n      target = target.parent\n    }\n    return target.value(id)\n  }\n\n  // set a value from a context\n  set (id, value) {\n    let target = this\n    while (target.value(id) === undefined && target.parent) {\n      target = target.parent\n    }\n    target.let(id, value)\n  }\n\n  // get a value from the local scope of a context\n  value (id) {\n    return this.local ? this.local[id] : undefined\n  }\n\n  // set a value into the local scope of a context\n  let (id, value) {\n    if (!this.local) this.local = {}\n    this.local[id] = value\n  }\n}\n","// # Audio Driver\n\nexport const ERR_INST_MISSING = name => `Instrument \"${name}\" not found.`\n\n// The audio driver has two tasks:\n// 1. Control the time by calling `resume` on the VM\n// 2. Create and play instruments\n\nexport class AudioDriver {\n  constructor (bpm, sampleRate) {\n    if (!bpm) throw Error(\"AudioDriver bpm is required\")\n    if (!sampleRate) throw Error(\"AudioDriver sampleRate is required\")\n    this.bpm = bpm\n    this.sampleRate = sampleRate\n    this.instruments = {}\n    this.commands = initCommands(this)\n  }\n\n  addInstruments (instruments) {\n    Object.assign(this.instruments, instruments)\n    return this.instruments\n  }\n\n  start (vm) {\n    if (this.vm) throw Error(\"Can't attach the same audio driver to different VM\")\n    if (vm.audio) throw Error(\"The given VM has an audio driver already\")\n    this.vm = vm\n    vm.audio = this\n    vm.addContext({ freq: 440, amp: 0.5 })\n    vm.addCommands(this.commands)\n    // make `addInstruments` accessible\n    vm.addInstruments = this.addInstruments.bind(this)\n  }\n}\n\n// ## Audio driver commands\n\nconst initCommands = driver => ({\n  // **@play**: Trigger a note. It uses the context to select the appropiate\n  // voice and parameters\n  // `\"@play\"`\n  \"@play\": ({ context, error }) => {\n    const instName = context.get(\"voice\")\n    const instrument = driver.instruments[instName]\n    if (instrument) {\n      instrument(context)\n    } else {\n      error(ERR_INST_MISSING(instName))\n    }\n  },\n  // **@set-bpm**: Change the global tempo\n  // `120, \"@set-bpm\"`\n  \"@set-bpm\": ({ stack }) => {\n    const bpm = parseFloat(stack.pop(), 10)\n    if (bpm > 0) driver.bpm = bpm\n  },\n  \"@scale-tempo\": ({ stack }) => {\n    const factor = parseFloat(stack.pop(), 10)\n    if (factor) driver.bpm = driver.bpm * factor\n  }\n})\n","// # Standard library\nimport { isArray, isString, last } from \"../utils\"\nimport { ERR_EXPECT_PATTERN, ERR_EXPECT_STRING } from \"../vm\"\n\n// The standard library include basic (arithmetic, logic, etc.) commands\n\n// **wrap**\n// A modulo operation that handles negative n more appropriately\n// e.g. wrap(-1, 3) returns 2\n// see http://en.wikipedia.org/wiki/Modulo_operation\n// see also http://jsperf.com/modulo-for-negative-numbers\nconst wrap = (a, b) => (a % b + b) % b\n\n// **op1**\n// A generic stack operation that pops one value and pushes on result\nconst op1 = fn => ({ stack }) => {\n  stack.push(fn(stack.pop()))\n}\n\n// **op2**\n// A generic stack operation that pops two values and pushes one result\nconst op2 = fn => ({ stack }) => {\n  stack.push(fn(stack.pop(), stack.pop()))\n}\n\n// ## Commands\n// A commands object is a map from instrunction name to functions\nexport default {\n  // **@list**: Store a list into the stack to allow other operations\n  // use or change the list\n  // `[\"@list\", [1, 2, 3]]`\n  \"@quote\": ({ stack, operations, error }) => {\n    const list = operations.pop()\n    if (!isArray(list)) error(\"@list\", ERR_EXPECT_PATTERN, list)\n    else stack.push(list)\n  },\n  \"@q\": \"@quote\",\n\n  // ### Arithmetic\n\n  // **@+**, **@add**: Add two values\n  // `[1, 2, \"@+\"]`\n  \"@+\": op2((b, a) => a + b),\n  \"@add\": \"@+\",\n\n  // **@-**, **@sub**: Subtract two values\n  // `[2, 1, \"@-\"]`\n  \"@-\": op2((b, a) => a - b),\n  \"@sub\": \"@-\",\n\n  // **@\\***, **@mul**: Multiply two values\n  // `[2, 4, \"@*\"]`\n  \"@*\": op2((b, a) => a * b),\n  \"@mul\": \"@*\",\n\n  // **@/**, **@div**: Divide two values\n  // `[4, 2, \"@/\"]`\n  \"@/\": op2((b, a) => b === 0 ? 0 : a / b),\n  \"@div\": \"@/\",\n\n  // **@%**, **@wrap**: Modulo for positive and negative numbers\n  // `[4, -2, \"@%\"]`\n  \"@%\": op2((b, a) => b === 0 ? 0 : wrap(a, b)),\n  \"@wrap\": \"@%\",\n\n  // **@mod**: Standard modulo operation\n  // `[4, 2, \"@mod\"]`\n  \"@mod\": op2((b, a) => b === 0 ? 0 : a % b),\n\n  // **@neg**: The negative of a value\n  // `[4, \"@neg\"]`\n  \"@neg\": op1(a => -a),\n\n  // ### Logic\n\n  // **@cond**: Conditional execution\n  // `[true, \"@cond\", [<success pattern>], [<fail pattern>]]`\n  \"@cond\": ({ stack, operations }) => {\n    const test = stack.pop()\n    // this is the pattern to execute if the test passes\n    const success = operations.pop()\n    // the next pattern is the \"else\" part\n    if (test) {\n      // remove the \"else\" part\n      operations.pop()\n      operations.push(success)\n    }\n  },\n\n  // **@>**: Greater than\n  \"@>\": op2((b, a) => a > b),\n  // **@>=**: Greater or equal than\n  \"@>=\": op2((b, a) => a >= b),\n  // **@<**: Less than\n  \"@<\": op2((b, a) => a < b),\n  // **@<=**: Less or equal than\n  \"@<=\": op2((b, a) => a <= b),\n  // **@==**: Is equal\n  \"@==\": op2((b, a) => a === b),\n  // **@!=**: Is not equal\n  \"@!=\": op2((b, a) => a !== b),\n  \"@!\": op1(a => !a),\n  // **@!**: Logic not\n  \"@not\": \"@!\",\n  // **@&&**, **@and**: Logic and\n  \"@&&\": op2((b, a) => a && b),\n  \"@and\": \"@&&\",\n  // **@||**, **@or**: Logic or\n  \"@||\": op2((b, a) => a || b),\n  \"@or\": \"@||\",\n\n  // ### Processes\n\n  // Operations related to interact with the current process\n\n  // **@let**: Assign a value to the local context\n  // `440,\"freq\",\"@let\"` |\n  \"@let\": ({ stack, context }) => context.let(stack.pop(), stack.pop()),\n\n  // **@set**: Assign a value to the global context\n  \"@set\": ({ stack, context }) => context.set(stack.pop(), stack.pop()),\n\n  // **@get**: Push the value of a variable into the stack\n  \"@get\": ({ stack, context }) => stack.push(context.get(stack.pop())),\n\n  // **@wait**: Wait an amount of time (in beats)\n  // `1,\"@wait\"`\n  \"@wait\": proc => proc.wait(Math.abs(Number(proc.stack.pop()))),\n\n  // **@sync**: Wait until next beat\n  \"@sync\": proc => proc.wait(Math.floor(proc.time) + 1 - proc.time),\n\n  // **@scale-rate**: Change the current rate by a factor\n  // `1.5, \"@scale-rate\"`\n  \"@scale-rate\": proc => {\n    const factor = parseFloat(proc.stack.pop(), 10)\n    if (factor > 0) proc.rate *= factor\n  },\n  \"@with-rate\": ({ stack, operations, error }) => {\n    const factor = parseFloat(stack.pop(), 10)\n    const pattern = operations.pop()\n    if (!isArray(pattern)) error(\"@with-rate\", ERR_EXPECT_PATTERN, pattern)\n    operations.push([\n      factor,\n      \"@scale-rate\",\n      pattern,\n      1 / factor,\n      \"@scale-rate\"\n    ])\n  },\n\n  // ### Execute and repeat\n\n  //  **@dup**: Duplicate item (so you can use it twice)\n  // `10,\"@dup\"`\n  \"@dup\": ({ stack }) => stack.push(last(stack)),\n\n  //  **@execute**: Execute an instruction\n  // `10,\"dup\",\"@execute\"`\n  \"@execute\": ({ operations, error }) => {\n    const instr = operations.pop()\n    if (isString(instr)) operations.push(\"@instr\")\n    else error(\"@execute\", ERR_EXPECT_STRING, instr)\n  },\n  //  **@**: Alias of @execute\n  // `10,\"dup\",\"@\"`\n  \"@\": \"@execute\",\n\n  //  **@repeat**: Repeat\n  // `4, \"@repeat\", [\"@kick\", 0.5, \"@wait\"]`\n  \"@repeat\": ({ stack, operations, error }) => {\n    const repetitions = stack.pop()\n    const pattern = last(operations)\n    if (!isArray(pattern)) error(\"@repeat\", ERR_EXPECT_PATTERN, pattern)\n    else {\n      for (let i = 1; i < repetitions; i++) {\n        operations.push(pattern)\n      }\n    }\n  },\n\n  //  **@forever**: Repeat forever\n  // `\"@forever\", [\"@kick\", 0.5, \"@wait\"]`\n  \"@forever\": ({ operations, error }) => {\n    const pattern = last(operations)\n    if (isArray(pattern) && pattern.length) {\n      operations.push(\"@forever\")\n      operations.push(pattern)\n    } else error(\"@forever\", ERR_EXPECT_PATTERN, pattern)\n  },\n\n  // ### Utilities\n\n  // **@mtof**: midi to frequency\n  // [60, '@mtof']\n  \"@mtof\": ({ stack }) => {\n    const midi = stack.pop()\n    const freq = 440 * Math.pow(2, (+midi - 69) / 12)\n    stack.push(freq)\n  },\n\n  // **@linear**: convert a value between two linear scales\n  // [value, fromLow, fromHi, toLow, toHi, \"@linear\"]\n  \"@linear\": ({ stack }) => {\n    const ohi = stack.pop()\n    const olo = stack.pop()\n    const ihi = stack.pop()\n    const ilo = stack.pop()\n    const v = stack.pop()\n\n    if (ihi === ilo) {\n      stack.push(olo)\n    } else {\n      stack.push(olo + (ohi - olo) * ((v - ilo) / (ihi - ilo)))\n    }\n  }\n}\n","// # List\nimport { isArray, isNum } from \"../utils\"\n\n// A collection of commands to work with lists\n\n// #### Error messages\nconst ERR_EXPECT_LIST = \"A list was expected, but found:\"\nconst ERR_EXPECT_NUM = \"A number was expected, but found:\"\n\n// #### Commands\nexport default {\n  //  **@iter**: Iterate a list\n  // `[\"@list\", [1, 2, 3], \"@iter\", \"amp\", \"@set\"]`\n  \"@iter\": ({ stack, operations, error }) => {\n    const list = stack.pop()\n    if (!isArray(list)) {\n      error(\"@iter\", ERR_EXPECT_LIST, list)\n    } else {\n      // Add the next element into the stack\n      const next = list.shift()\n      stack.push(next)\n      // rotate (and mutate) the pattern\n      list.push(next)\n    }\n  },\n\n  //  **@reverse**: Reverse a list\n  // `[\"@list\", [1, 2, 3], \"@reverse\"]`\n  \"@reverse\": ({ stack, error }) => {\n    const list = stack.pop()\n    if (!isArray(list)) error(\"@reverse\", ERR_EXPECT_LIST, list)\n    else stack.push(list.slice().reverse())\n  },\n\n  //  **@rotate**: Rotate a pattern\n  // `[\"@list\", [1, 2, 3, 4], 2, \"@rotate\"]`\n  \"@rotate\": ({ stack, error }) => {\n    const rotations = stack.pop()\n    const list = stack.pop()\n\n    if (!isArray(list)) {\n      error(\"@rotate\", ERR_EXPECT_LIST, list)\n    } else if (!isNum(rotations)) {\n      error(\"@rotate\", ERR_EXPECT_NUM, rotations)\n    } else {\n      // ensure rot is valid between -args.length to +args.length\n      const rot = rotations % list.length\n      // FIXME: find a more performant way to do rotation\n      var copy = [].concat(list.slice(rot)).concat(list.slice(0, rot))\n      stack.push(copy)\n    }\n  },\n}\n"],"names":["defer","fn","data","createCommands","vm","operations","proc","error","pattern","pop","isArray","fork","ERR_EXPECT_PATTERN","stack","name","isString","stop","ERR_EXPECT_STRING","stopAll","remove","procs","i","length","splice","insert","push","p","time","at","len","Infinity","expandAliases","commands","keys","forEach","op","init","Gibberish","options","context","audio","GibberishDriver","bpm","addInstruments","createInstruments","kick","Kick","decay","connect","snare","Snare","snappy","hat","Hat","amp","conga","Conga","freq","tom","Tom","pluck","PolyKarplusStrong","maxVoices","bass","MonoSynth","Time","beats","sampleRate","perc","pitched","ctx","get","damping","Math","log","note","velocity","AudioContext","WebAudioDriver","clock","ac","callback","lookAhead","updateInterval","next","currentTime","tick","setInterval","synth","osc","createOscillator","frequency","value","createGain","gain","destination","start","setValueAtTime","linearRampToValueAtTime","random","rnd","irnd","floor","n","shuffle","j","x","a","list","prob","ifTrue","debug","console","bind","peek","id","set","slice","reverse","voice","voiceNote","initGibberish","gibberish","initWebAudio","waa","driver","plugins","VM","addCommands","stdlib","compatibility","cmds","Array","isFn","isNum","last","Context","parent","this","local","Object","assign","c","target","undefined","let","isCommand","o","isProgram","procId","Process","program","rate","instr","cmd","limit","step","Error","msg","obj","procsByName","onfork","onstop","onended","delay","dur","nextTime","resume","ERR_INST_MISSING","AudioDriver","instruments","initCommands","addContext","instName","instrument","parseFloat","factor","bpm2bpa","_this2","sequencers","inst","pitch","timeToBeats","beatsToTime","audioContext","when","_this","zero","trigger","wrap","b","op1","op2","test","success","wait","abs","Number","repetitions","midi","pow","ohi","olo","ihi","ilo","v","ERR_EXPECT_LIST","shift","rotations","rot","copy","concat","p1","p2"],"mappings":"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"}
{"version":3,"file":"ash-vm.js","sources":["../src/process.js","../src/vm.js","../src/audio/gibberish.js","../src/audio/waa.js","../src/ext/random.js","../src/ext/debug.js","../src/ext/compatibility.js","../src/index.js","../src/utils.js","../src/context.js","../src/audio/driver.js","../src/ext/stdlib.js"],"sourcesContent":["// # Process\nimport Context from \"./context\"\n\n// #### Utilities\n// defer a function\nfunction defer (fn, data) { setTimeout(() => { fn(data) }, 0) }\n// test if the given operation is an instruction name\nconst isCommand = o => typeof o === \"string\" && o[0] === \"@\"\n// test if the given operation is a program\nconst isProgram = Array.isArray\n// Give unique ids to process\nlet procId = 1\n\n// #### Error messages\n\n// The given instruction name is not in the commands object\nconst ERR_INSTR_NOT_FOUND = \"Instruction not recognized.\"\n// The max loop cycles tests\nconst ERR_LIMIT_REACHED = \"Limit reached. Probably an infinity loop.\"\n\n// ## Process\n\n// Processes are the principal computation unit. It departures from typical\n// processes in that it model the concept of time\nexport class Process {\n  constructor (program, context, time, rate) {\n    this.id = \"proc-\" + procId++\n    // a stack of values\n    this.stack = []\n    // the operations are stored in a stack (in reverse order)\n    this.operations = program ? [program] : []\n    // the context is used to store variables with scope\n    this.context = new Context(context)\n    // the current time\n    this.time = typeof time === \"number\" ? time : 0\n    // how fast time passes\n    this.rate = typeof rate === \"number\" ? rate : 1\n    // bind error to allow destructuring in commands\n    this.error = this.error.bind(this)\n  }\n\n  // wait an amount of time\n  wait (time) {\n    this.time += this.rate * time\n  }\n\n  // The process is agnostic about the commands to be use\n  step (commands) {\n    const { operations } = this\n    if (operations.length) {\n      const instr = operations.pop()\n      if (instr === null || instr === undefined) {\n        // ignore\n      } else if (typeof instr === \"function\") {\n        // it runs the functions but outside the loop\n        defer(instr, this.time)\n      } else if (isProgram(instr)) {\n        // if it\"s program, and since the operations are stored into an stack,\n        // we need add to the program operations in reverse order\n        for (let i = instr.length - 1; i >= 0; i--) {\n          operations.push(instr[i])\n        }\n      } else if (isCommand(instr)) {\n        const cmd = commands[instr]\n        if (typeof cmd === \"function\") cmd(this)\n        else this.error(\"step > \", ERR_INSTR_NOT_FOUND, instr)\n      } else {\n        // if it\"s a value, push it into the stack\n        this.stack.push(instr)\n      }\n    }\n  }\n\n  // the `resume` function run all the operations until time is reached\n  resume (commands, time = Infinity, limit = 10000) {\n    const { operations } = this\n    while (--limit > 0 && this.time < time && operations.length) {\n      this.step(commands)\n    }\n    if (limit === 0) throw Error(ERR_LIMIT_REACHED)\n    return operations.length > 0\n  }\n\n  // an utility function to write errors\n  error (instr, msg, obj) {\n    console.error(instr, msg, obj, \"id\", this.id, \"time\", this.time)\n  }\n}\n","// # VM\n\nimport { isArray, isString, isFn } from \"./utils\"\nimport { Process } from \"./process\"\n\n// **Error messages**\nexport const ERR_EXPECT_PATTERN = \"Expected a pattern, but found:\"\nexport const ERR_EXPECT_STRING = \"Expected a string, but found:\"\n\nconst assign = Object.assign\n\n// The purpose of the VM is to run processes concurrently. It also\n// mantains an extensible object of commands (operations mapped to functions)\n// that allows to add operations to the vm\n\n// TODO: probably is better to have functions and object instead of classes\n// will change in the future.\nexport class VM {\n  constructor (options = {}) {\n    this.context = Object.assign({}, options.context)\n    this.procs = [] // the procs are inverse ordered by time\n    this.procsByName = {} // a map of names to procs\n    this.time = 0\n    this.commands = createCommands(this)\n    this.onfork = options.onfork\n    this.onstop = options.onstop\n    this.onended = options.onended\n  }\n\n  // Run a program\n  run (program, sync = true) {\n    // if there are no processes, no need to sync\n    if (sync && this.procs.length) program = [\"@sync\", program]\n    return this.fork(null, this.context, program)\n  }\n\n  // Add to the initial context\n  addContext (context) {\n    Object.assign(this.context, context)\n    return this.context\n  }\n\n  // Add more commands\n  addCommands (commands) {\n    if (isFn(commands)) commands = commands(this)\n    if (commands) assign(this.commands, expandAliases(commands))\n  }\n\n  // Create a new process\n  fork (name, parent, program, delay = 0, rate) {\n    const time = this.time + delay\n    // if has parent and no rate, try to use it\"s rate\n    if (!rate && parent) rate = parent.rate\n    // if has parent try to use it\"s context\n    const context = parent ? parent.context || parent : undefined\n    // create the new process and insert into the process stack\n    const proc = new Process(program, context, time, rate)\n    insert(proc, this.procs)\n    // if has name, register it\n    if (name) this.procsByName[name] = proc\n    if (this.onfork) this.onfork({ proc, name, parent, program, delay, rate })\n    return proc\n  }\n\n  // run the vm for the given amount of time (Infinity if not specified)\n  resume (dur = Infinity, limit = 10000) {\n    const { procs } = this\n    if (procs.length > 0) {\n      const nextTime = this.time + dur\n      while (--limit > 0 && at(procs) < nextTime) {\n        const proc = procs.pop()\n        if (proc.resume(this.commands, nextTime)) {\n          // the proc has more operations, re-schedule\n          insert(proc, this.procs)\n        } else {\n          if (this.onended) this.onended({ proc, time: this.time })\n        }\n      }\n      this.time = nextTime\n    } else {\n      this.time += dur\n    }\n    return procs.length > 0\n  }\n\n  stopAll () {\n    this.procs.length = 0\n  }\n\n  // The stop function can stop a proccess by name or by object\n  stop (name) {\n    let proc\n    if (typeof proc === \"string\") {\n      proc = this.procsByName[name]\n      this.procsByName[name] = null\n    } else {\n      proc = name\n      name = null\n    }\n    if (this.onstop) this.onstop({ name, proc })\n\n    remove(proc, this.procs)\n  }\n}\n\n// ## VM commands\n\n// | Name | Description | Example |\n// |------|-------------|---------|\n// | **@fork** | Fork | `@fork, [0.5, \"@wait\", \"@kick\"]` |\n// | **@spawn** | Spawn | `\"melody\", \"@spawn\", [0.5, \"@wait\", \"@kick\"]` |\n// | **@stop** | Stop current process | `@stop` |\n// | **@stop-all** | Stop all processes | `@stop-all` |\nfunction createCommands (vm) {\n  return {\n    \"@loop\": proc => {\n      const { operations, error } = proc\n      const pattern = operations.pop()\n      if (isArray(pattern)) vm.fork(null, proc, [\"@forever\", pattern])\n      else error(\"@loop\", ERR_EXPECT_PATTERN, pattern)\n    },\n    \"@fork\": proc => {\n      const { operations, error } = proc\n      let pattern = operations.pop()\n\n      if (isArray(pattern)) {\n        vm.fork(null, proc, pattern)\n      } else {\n        error(\"@fork\", ERR_EXPECT_PATTERN, pattern)\n      }\n    },\n    \"@spawn\": proc => {\n      const { stack, operations, error } = proc\n      const name = stack.pop()\n      let pattern = operations.pop()\n      if (!isString(name)) {\n        error(\"@spawn\", ERR_EXPECT_STRING, name)\n      } else if (!isArray(pattern)) {\n        error(\"@spawn\", ERR_EXPECT_PATTERN, pattern)\n      } else {\n        vm.stop(name)\n        vm.fork(name, proc, [\"@forever\", pattern])\n      }\n    },\n    \"@stop-all\": proc => vm.stopAll(),\n    \"@stop\": ({ stack }) => vm.stop(stack.pop())\n  }\n}\n\n// ## Internal VM functions\n\n// remove a process process\nfunction remove (proc, procs) {\n  let i = procs.length - 1\n  while (i >= 0 && procs[i] !== proc) {\n    i--\n  }\n  // if found, remove it\n  if (i !== -1) procs.splice(i, 1)\n  return i !== -1\n}\n\n// insert a process into a stack ordered by time\n// (in fact, is inverse order because it\"s a stack)\nfunction insert (proc, procs) {\n  if (procs.length === 0) {\n    // no need to sort: just push it\n    procs.push(proc)\n  } else {\n    // procs are sorted on insertion\n    let i = procs.length - 1\n    let p = procs[i]\n    while (p && p.time <= proc.time) {\n      i--\n      p = procs[i]\n    }\n    procs.splice(i + 1, 0, proc)\n  }\n  return proc\n}\n\n// get time of the next process\nfunction at (procs) {\n  const len = procs.length\n  return len ? procs[len - 1].time : Infinity\n}\n\n// Given a commands object, expand the aliases\nfunction expandAliases (commands) {\n  Object.keys(commands).forEach(name => {\n    const op = commands[name]\n    if (isString(op)) commands[name] = commands[op]\n  })\n  return commands\n}\n","// # Gibberish Audio Driver\nimport { AudioDriver } from \"./driver\"\n\n// This driver uses Gibberish both for scheduling and sounds\n\n/**\n * Create a VM plugin to add the audio driver\n * @return {Function} a VM plugin\n */\nexport default function init (Gibberish, options = {}) {\n  if (!Gibberish.context) Gibberish.init()\n  const audio = new GibberishDriver(Gibberish, options.bpm || 120)\n  audio.addInstruments(createInstruments(Gibberish))\n  return audio\n}\n\nclass GibberishDriver extends AudioDriver {\n  constructor (Gibberish, bpm) {\n    super(bpm, Gibberish.context.sampleRate)\n    this.Gibberish = Gibberish\n  }\n\n  // Start a VM\n  start (vm) {\n    super.start(vm)\n    // convert bmp to beats per audio sample\n    const bpm2bpa = 1 / (60 * this.sampleRate)\n    // tick is binded to this\n    this.tick = () => vm.resume(this.bpm * bpm2bpa)\n    this.Gibberish.sequencers.push({ tick: this.tick })\n  }\n}\n\n// # Instruments\n\n// Create a trigger function for a percussion instrument\nconst perc = (inst, gain) => (ctx) => {\n  inst.amp = gain * ctx.get(\"amp\")\n  inst.note()\n}\n\n// Create a trigger function for a tuned percussion instrument\nconst pitched = (inst, gain) => (ctx) => {\n  inst.amp = gain * ctx.get(\"amp\")\n  inst.pitch = ctx.get(\"freq\")\n  inst.note()\n}\n\n// Create the basic instruments using Gibberish\nfunction createInstruments (Gibberish) {\n  // The actual instruments\n  const kick = new Gibberish.Kick({ decay: 0.2 }).connect()\n  const snare = new Gibberish.Snare({ snappy: 1.5 }).connect()\n  const hat = new Gibberish.Hat({ amp: 1.5 }).connect()\n  const conga = new Gibberish.Conga({ amp: 0.25, freq: 400 }).connect()\n  const tom = new Gibberish.Tom({ amp: 0.25, freq: 400 }).connect()\n  const pluck = new Gibberish.PolyKarplusStrong({maxVoices: 32}).connect()\n  const bass = new Gibberish.MonoSynth({\n    attack: 44,\n    decay: Gibberish.Time.beats(0.25),\n    filterMult: 0.25,\n    octave2: 0,\n    octave3: 0\n  }).connect()\n  const sampleRate = Gibberish.sampleRate\n\n  // The instrument trigger functions\n  return {\n    kick: perc(kick, 0.5),\n    snare: perc(snare, 0.25),\n    hat: perc(hat, 1),\n    conga: pitched(conga, 0.25),\n    tom: pitched(tom, 0.25),\n    pluck: (ctx) => {\n      const amp = ctx.get(\"amp\")\n      const freq = ctx.get(\"freq\")\n      if (freq > 0) {\n        // this is not in any way accurate, just a hack to make @set-dur do something semi-meaningful\n        pluck.damping = 1 - (-6 / Math.log(freq / sampleRate))\n        // pluck by default seem too quiet:\n        pluck.note(freq, amp * amp * 2)\n      }\n    },\n    bass: (ctx) => {\n      const velocity = ctx.get(\"amp\")\n      const freq = ctx.get(\"freq\")\n      if (freq > 0) bass.note(freq, velocity)\n    }\n  }\n}\n","// # Web Audio API Audio Driver\n/* global AudioContext */\nimport { AudioDriver, ERR_INST_MISSING } from \"./driver\"\n\nconst timeToBeats = (time, bpm) => time * bpm / 60\nconst beatsToTime = (beats, bpm) => beats * 60 / bpm\n\nexport default function init (context, options = {}) {\n  context = context || new AudioContext()\n  const audio = new WebAudioDriver(context, options.bpm || 120)\n  audio.addInstruments(createInstruments(context))\n  return audio\n}\n\n// ## Audio driver\nclass WebAudioDriver extends AudioDriver {\n  constructor (audioContext, bpm) {\n    super(bpm, audioContext.sampleRate)\n    this.ac = audioContext\n\n    // override the **@play** command to provide `when` paramter to trigger\n    this.commands[\"@play\"] = ({ time, context, error }) => {\n      const when = beatsToTime(time, this.bpm) + this.zero\n      const inst = context.get(\"voice\")\n      const trigger = this.instruments[inst]\n      if (!trigger) error(\"@play\", ERR_INST_MISSING(inst))\n      else trigger(context, when)\n    }\n  }\n\n  start (vm) {\n    super.start(vm)\n    const step = 0.1\n    this.zero = this.ac.currentTime\n    clock(this.ac, (time) => {\n      vm.resume(timeToBeats(step, this.bpm))\n    }, step)\n  }\n}\n\n// ## Scheduling\nfunction clock (ac, callback, time) {\n  const lookAhead = time || 0.1\n  const updateInterval = lookAhead / 3\n  let next = ac.currentTime + lookAhead\n  const tick = () => {\n    if (ac.currentTime + lookAhead >= next) {\n      callback(next)\n      next += lookAhead\n    }\n  }\n  tick()\n  return setInterval(tick, updateInterval)\n}\n\n// ## Instruments\n\n// The Web Audio API driver comes with a very simple sound generator\n// (mostly for testing)\nfunction synth (ac, time, freq, amp, decay) {\n  const osc = ac.createOscillator()\n  osc.frequency.value = freq || 200\n  osc.amp = ac.createGain()\n  osc.amp.gain.value = 0\n  osc.connect(osc.amp)\n  osc.amp.connect(ac.destination)\n  osc.start(time)\n  osc.amp.gain.setValueAtTime(0, time)\n  osc.amp.gain.linearRampToValueAtTime(amp * 0.5, time + 0.01)\n  osc.amp.gain.linearRampToValueAtTime(0, time + decay)\n  osc.stop(time + decay + 0.1)\n  return osc\n}\n\n// Create instruments\nconst createInstruments = (ac) => ({\n  kick: (ctx, time) => synth(ac, time, 100, 1, 0.2),\n  snare: (ctx, time) => synth(ac, time, 476, 0.6, 0.2),\n  hat: (ctx, time) => synth(ac, time, 4000, 0.2, 0.1),\n  conga: (ctx, time) => synth(ac, time, 4000, 0.2, 0.1),\n  tom: (ctx, time) => synth(ac, time, 200, 0.4, 0.4),\n  pluck: (ctx, time) => synth(ac, time, ctx.get(\"freq\"), ctx.get(\"amp\"), 0.5),\n  bass: (ctx, time) => synth(ac, time, 0.5 * ctx.get(\"freq\"), ctx.get(\"amp\"), 0.5),\n})\n","// ## Randomness\nimport { isArray } from \"../utils\"\nimport { ERR_EXPECT_PATTERN } from \"../vm\"\nconst { floor } = Math\n\n// | Name | Description | Example |\n// |------|-------------|---------|\n// | **@random** | Generate a random number between 0 and 1 | `[\"@random\", \"amp\", \"@set\"]` |\n// | **@rand** | Alias for @random | |\n// | **@srandom** | Generate a random number between -1 and 1 | `[\"@srandom\", \"phase\", \"@set\"]` |\n// | **@srand** | Alias for @srandom | |\n// | **@randi** | Generate a random integer between 0 and n | `[60, \"@randi\", \"midi\", \"@set\"]` |\n// | **@pick** | Pick a random element from a list | `[\"@pick\", [1, 2, 3, 4]]` |\n// | **@shuffle** | Shuffle a list | `\"@shuffle\", [1, 2, 3]` |\n// | **@chance** | Probabilistic execution | `probability, \"@chance\", executed-if-true, executed-if-false` |\nexport default function random ({ random } = {}) {\n  // allow to use a custom random function\n  const rnd = random || Math.random\n  // a function that generates integer random from 0 to n\n  const irnd = n => floor(rnd() * n)\n\n  const shuffle = a => {\n    var j, x, i\n    for (i = a.length; i; i--) {\n      j = floor(random() * i)\n      x = a[i - 1]\n      a[i - 1] = a[j]\n      a[j] = x\n    }\n  }\n\n  return {\n    \"@random\": ({ stack }) => stack.push(rnd()),\n    \"@rand\": \"@random\",\n    \"@srandom\": ({ stack }) => stack.push(rnd() * 2 - 1),\n    \"@srand\": \"@srandom\",\n    \"@randi\": ({ stack }) => stack.push(irnd(stack.pop())),\n    \"@pick\": proc => {\n      const { operations, error } = proc\n      const pattern = operations.pop()\n      if (!isArray(pattern)) {\n        operations.push(pattern)\n        error(\"Can't pick an element if is not an array\", pattern)\n      } else {\n        const i = irnd(pattern.length)\n        operations.push(pattern[i])\n      }\n    },\n    \"@chance\": ({ stack, operations }) => {\n      const prob = stack.pop()\n      const pattern = operations.pop()\n      if (rnd() < prob) {\n        // Skip item after\n        operations.pop()\n        // Push the pattern\n        operations.push(pattern)\n      }\n    },\n    \"@shuffle\": ({ stack, operations, error }) => {\n      const pattern = operations.pop()\n      if (!isArray(pattern)) error(\"@shuffle\", ERR_EXPECT_PATTERN, pattern)\n      else operations.push(shuffle(pattern))\n    }\n  }\n}\n","// # Debug operations\nimport { peek } from \"../utils\"\n\n// | Name | Description | Example |\n// |------|-------------|---------|\n// | **@print** | Print the last value of the stack | `10,\"@print\"` |\n// | **@log** | Log the name with the last value of the stack | `\"@random\", \"amp\", \"@log\"` |\nexport default function debug ({ log } = {}) {\n  log = log || console.log.bind(console)\n\n  return {\n    \"@print\": proc => {\n      const { stack } = proc\n      const last = stack.length ? peek(stack) : \"<Empty Stack>\"\n      log(\"@print\", last, \"(id, time)\", proc.id, proc.time)\n    },\n    \"@log\": proc => {\n      const { stack } = proc\n      const name = stack.pop()\n      const last = stack.length ? peek(stack) : \"<Empty Stack>\"\n      log(\"@log\", name, last, \"(id, time)\", proc.id, proc.time)\n    },\n    \"@debug\": proc => {\n      const { stack } = proc\n      log(\"@debug\", stack, proc.id, proc.time)\n    }\n  }\n}\n","// # Compatibility plugin\n\nimport { isArray } from \"../utils\"\nimport { ERR_EXPECT_PATTERN } from \"../vm\"\n\n// This plugin adds language compatibility to the previous version\n\n// Given an instrument name, returns a command that play that instrument\nconst voice = name => ({ operations }) => {\n  operations.push([name, \"voice\", \"@let\", \"@play\"])\n}\nconst voiceNote = (name, p1, p2) => ({ stack, operations }) => {\n  operations.push(p2\n    ? [stack.pop(), p2, \"@let\", stack.pop(), p1, \"@let\",\n      name, \"voice\", \"@let\", \"@play\"]\n    : [stack.pop(), p1, \"@let\",\n      name, \"voice\", \"@let\", \"@play\"])\n}\n\nexport default function init () {\n  return {\n    // get and set for freq and amp\n    \"@set-freq\": ({ context, stack }) => context.set(\"freq\", stack.pop()),\n    \"@set-amp\": ({ context, stack }) => context.set(\"amp\", stack.pop()),\n    \"@get-freq\": ({ stack, context }) => stack.push(context.get(\"freq\")),\n    \"@get-amp\": ({ stack, context }) => stack.push(context.get(\"amp\")),\n\n    // I think reverse is not very useful in this context\n    // because: [\"@iter\", [\"@reverse\", [1, 2, 3]]] doesn\"t work, for example\n    \"@reverse\": ({ operations, error }) => {\n      const pattern = operations.pop()\n      if (!isArray(pattern)) error(\"@reverse\", ERR_EXPECT_PATTERN, pattern)\n      else operations.push(pattern.slice().reverse())\n    },\n    // I think @map is not a good name\n    \"@map\": \"@linear\",\n\n    // Instrument names\n    \"@pluck\": voice(\"pluck\"),\n    \"@pluck-note\": voiceNote(\"pluck\", \"freq\", \"amp\"),\n    \"@bass\": voice(\"bass\"),\n    \"@bass-note\": voiceNote(\"bass\", \"freq\", \"amp\"),\n    \"@hat\": voice(\"hat\"),\n    \"@hat-note\": voiceNote(\"hat\", \"amp\"),\n    \"@kick\": voice(\"kick\"),\n    \"@kick-note\": voiceNote(\"kick\", \"amp\"),\n    \"@snare\": voice(\"snare\"),\n    \"@snare-note\": voiceNote(\"snare\", \"amp\"),\n    \"@conga\": voice(\"conga\"),\n    \"@conga-note\": voiceNote(\"conga\", \"amp\"),\n    \"@clave\": voice(\"clave\"),\n    \"@clave-note\": voiceNote(\"clave\", \"amp\"),\n    \"@tom\": voice(\"tom\"),\n    \"@tom-note\": voiceNote(\"tom\", \"amp\"),\n  }\n}\n","// # Audio Scheduler Virtual Machine\nimport { VM } from \"./vm\"\nimport gibberish from \"./audio/gibberish\"\nimport waa from \"./audio/waa\"\nimport stdlib from \"./ext/stdlib\"\nimport random from \"./ext/random\"\nimport debug from \"./ext/debug\"\nimport compatibility from \"./ext/compatibility\"\n\n// ## Architecture Overview\n\n// The main purpose of the virtual machine is to run processes concurrently.\n// It holds a `commands` object (that maps instruction names to functions)\n// and schedules a collection of `processes`. Each **process** has an values `stack`\n// and `operations` stack (to be executed).\n\n// ## API\nexport function initGibberish (Gibberish, options) {\n  return init(gibberish, Gibberish, options)\n}\n\nexport function initWebAudio (context, options) {\n  return init(waa, context, options)\n}\n\n// the init function creates a vm controlled by Gibberish\nexport function init (driver, audio, options = {}) {\n  const { plugins } = options\n  // Create the virtual machine\n  const vm = new VM(options)\n  // Install the audio driver\n  driver(audio, options).start(vm)\n\n  // Include all the commands\n  vm.addCommands(stdlib)\n  vm.addCommands(random(options))\n  vm.addCommands(debug(options))\n  vm.addCommands(compatibility(options))\n  // Add the plugins if any\n  if (plugins) plugins.forEach(cmds => vm.addCommands(cmds))\n\n  return vm\n}\n","// # TimeVM utilities\n\n// copy values from one or more sources to a target\n// see: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\nexport const assign = Object.assign\n\n// test if an object is an array\nexport const isArray = Array.isArray\n\n// test if  is a string\nexport const isString = x => typeof x === \"string\"\n\n// test if  is a function\nexport const isFn = x => typeof x === \"function\"\n\n// test if  is defined\nexport const isDef = x => typeof x !== \"undefined\"\n\n// get last element from an array\nexport const last = a => a[a.length - 1]\n// take the next element of stack without remove it\nexport const peek = last\n","// ## Context\n\n// A context is a hierarchical structure to store values with scope\nexport default class Context {\n  constructor (parent) {\n    if (parent instanceof Context) this.parent = parent\n    else if (parent) this.local = Object.assign({}, parent)\n  }\n\n  // Create a child\n  child (local) {\n    const c = new Context(this)\n    c.local = Object.assign({}, local)\n    return c\n  }\n  // get a value from a context\n  get (id) {\n    let target = this\n    while (target.value(id) === undefined && target.parent) {\n      target = target.parent\n    }\n    return target.value(id)\n  }\n\n  // set a value from a context\n  set (id, value) {\n    let target = this\n    while (target.value(id) === undefined && target.parent) {\n      target = target.parent\n    }\n    target.let(id, value)\n  }\n  // get a value from the local scope of a context\n  value (id) {\n    return this.local ? this.local[id] : undefined\n  }\n\n  // set a value into the local scope of a context\n  let (id, value) {\n    if (!this.local) this.local = {}\n    this.local[id] = value\n  }\n}\n","// # Audio Driver\n\nexport const ERR_INST_MISSING = name => `Instrument \"${name}\" not found.`\n\n// The audio driver has two tasks:\n// 1. Control the time by calling `resume` on the VM\n// 2. Create and play instruments\n\nexport class AudioDriver {\n  constructor (bpm, sampleRate) {\n    if (!bpm) throw Error(\"AudioDriver bpm is required\")\n    if (!sampleRate) throw Error(\"AudioDriver sampleRate is required\")\n    this.bpm = bpm\n    this.sampleRate = sampleRate\n    this.instruments = {}\n    this.commands = initCommands(this)\n  }\n\n  addInstruments (instruments) {\n    Object.assign(this.instruments, instruments)\n    return this.instruments\n  }\n\n  start (vm) {\n    if (this.vm) throw Error(\"Can't attach the same audio driver to different VM\")\n    if (vm.audio) throw Error(\"The given VM has an audio driver already\")\n    this.vm = vm\n    vm.audio = this\n    vm.addContext({ freq: 440, amp: 0.5 })\n    vm.addCommands(this.commands)\n    // make `addInstruments` accessible\n    vm.addInstruments = this.addInstruments.bind(this)\n  }\n}\n\n// ## Audio driver commands\n\nconst initCommands = driver => ({\n  // **@play**: Trigger a note. It uses the context to select the appropiate\n  // voice and parameters\n  // `\"@play\"`\n  \"@play\": ({ context, error }) => {\n    const instName = context.get(\"voice\")\n    const instrument = driver.instruments[instName]\n    if (instrument) {\n      instrument(context)\n    } else {\n      error(ERR_INST_MISSING(instName))\n    }\n  },\n  // **@set-bpm**: Change the global tempo\n  // `120, \"@set-bpm\"`\n  \"@set-bpm\": ({ stack }) => {\n    const bpm = parseFloat(stack.pop(), 10)\n    if (bpm > 0) driver.bpm = bpm\n  },\n  \"@scale-tempo\": ({ stack }) => {\n    const factor = parseFloat(stack.pop(), 10)\n    if (factor) driver.bpm = driver.bpm * factor\n  }\n})\n","// # Standard library\nimport { isArray, isString, last } from \"../utils\"\nimport { ERR_EXPECT_PATTERN, ERR_EXPECT_STRING } from \"../vm\"\n\n// The standard library include basic (arithmetic, logic, etc.) commands\n\n// **wrap**\n// A modulo operation that handles negative n more appropriately\n// e.g. wrap(-1, 3) returns 2\n// see http://en.wikipedia.org/wiki/Modulo_operation\n// see also http://jsperf.com/modulo-for-negative-numbers\nconst wrap = (a, b) => (a % b + b) % b\n\n// **op1**\n// A generic stack operation that pops one value and pushes on result\nconst op1 = fn => ({ stack }) => {\n  stack.push(fn(stack.pop()))\n}\n\n// **op2**\n// A generic stack operation that pops two values and pushes one result\nconst op2 = fn => ({ stack }) => {\n  stack.push(fn(stack.pop(), stack.pop()))\n}\n\n// ## Commands\n// A commands object is a map from instrunction name to functions\nexport default {\n  // ### Arithmetic\n\n  // **@+**, **@add**: Add two values\n  // `[1, 2, \"@+\"]`\n  \"@+\": op2((b, a) => a + b),\n  \"@add\": \"@+\",\n\n  // **@-**, **@sub**: Subtract two values\n  // `[2, 1, \"@-\"]`\n  \"@-\": op2((b, a) => a - b),\n  \"@sub\": \"@-\",\n\n  // **@\\***, **@mul**: Multiply two values\n  // `[2, 4, \"@*\"]`\n  \"@*\": op2((b, a) => a * b),\n  \"@mul\": \"@*\",\n\n  // **@/**, **@div**: Divide two values\n  // `[4, 2, \"@/\"]`\n  \"@/\": op2((b, a) => b === 0 ? 0 : a / b),\n  \"@div\": \"@/\",\n\n  // **@%**, **@wrap**: Modulo for positive and negative numbers\n  // `[4, -2, \"@%\"]`\n  \"@%\": op2((b, a) => b === 0 ? 0 : wrap(a, b)),\n  \"@wrap\": \"@%\",\n\n  // **@mod**: Standard modulo operation\n  // `[4, 2, \"@mod\"]`\n  \"@mod\": op2((b, a) => b === 0 ? 0 : a % b),\n\n  // **@neg**: The negative of a value\n  // `[4, \"@neg\"]`\n  \"@neg\": op1(a => -a),\n\n  // ### Logic\n\n  // **@cond**: Conditional execution\n  // `[true, \"@cond\", [<success pattern>], [<fail pattern>]]`\n  \"@cond\": ({ stack, operations }) => {\n    const test = stack.pop()\n    // this is the pattern to execute if the test passes\n    const success = operations.pop()\n    // the next pattern is the \"else\" part\n    if (test) {\n      // remove the \"else\" part\n      operations.pop()\n      operations.push(success)\n    }\n  },\n\n  // **@>**: Greater than\n  \"@>\": op2((b, a) => a > b),\n  // **@>=**: Greater or equal than\n  \"@>=\": op2((b, a) => a >= b),\n  // **@<**: Less than\n  \"@<\": op2((b, a) => a < b),\n  // **@<=**: Less or equal than\n  \"@<=\": op2((b, a) => a <= b),\n  // **@==**: Is equal\n  \"@==\": op2((b, a) => a === b),\n  // **@!=**: Is not equal\n  \"@!=\": op2((b, a) => a !== b),\n  \"@!\": op1(a => !a),\n  // **@!**: Logic not\n  \"@not\": \"@!\",\n  // **@&&**, **@and**: Logic and\n  \"@&&\": op2((b, a) => a && b),\n  \"@and\": \"@&&\",\n  // **@||**, **@or**: Logic or\n  \"@||\": op2((b, a) => a || b),\n  \"@or\": \"@||\",\n\n  // ### Processes\n\n  // Operations related to interact with the current process\n\n  // **@let**: Assign a value to the local context\n  // `440,\"freq\",\"@let\"` |\n  \"@let\": ({ stack, context }) => context.let(stack.pop(), stack.pop()),\n\n  // **@set**: Assign a value to the global context\n  \"@set\": ({ stack, context }) => context.set(stack.pop(), stack.pop()),\n\n  // **@get**: Push the value of a variable into the stack\n  \"@get\": ({ stack, context }) => stack.push(context.get(stack.pop())),\n\n  // **@wait**: Wait an amount of time (in beats)\n  // `1,\"@wait\"`\n  \"@wait\": proc => proc.wait(Math.abs(Number(proc.stack.pop()))),\n\n  // **@sync**: Wait until next beat\n  \"@sync\": proc => proc.wait(Math.floor(proc.time) + 1 - proc.time),\n\n  // **@scale-rate**: Change the current rate by a factor\n  // `1.5, \"@scale-rate\"`\n  \"@scale-rate\": proc => {\n    const factor = parseFloat(proc.stack.pop(), 10)\n    if (factor > 0) proc.rate *= factor\n  },\n  \"@with-rate\": ({ stack, operations, error }) => {\n    const factor = parseFloat(stack.pop(), 10)\n    const pattern = operations.pop()\n    if (!isArray(pattern)) error(\"@with-rate\", ERR_EXPECT_PATTERN, pattern)\n    operations.push([\n      factor,\n      \"@scale-rate\",\n      pattern,\n      1 / factor,\n      \"@scale-rate\"\n    ])\n  },\n\n  // ### Execute and repeat\n\n  //  **@dup**: Duplicate item (so you can use it twice)\n  // `10,\"@dup\"`\n  \"@dup\": ({ stack }) => stack.push(last(stack)),\n\n  //  **@execute**: Execute an instruction\n  // `10,\"dup\",\"@execute\"`\n  \"@execute\": ({ operations, error }) => {\n    const instr = operations.pop()\n    if (isString(instr)) operations.push(\"@instr\")\n    else error(\"@execute\", ERR_EXPECT_STRING, instr)\n  },\n  //  **@**: Alias of @execute\n  // `10,\"dup\",\"@\"`\n  \"@\": \"@execute\",\n\n  //  **@repeat**: Repeat\n  // `4, \"@repeat\", [\"@kick\", 0.5, \"@wait\"]`\n  \"@repeat\": ({ stack, operations, error }) => {\n    const repetitions = stack.pop()\n    const pattern = last(operations)\n    if (!isArray(pattern)) error(\"@repeat\", ERR_EXPECT_PATTERN, pattern)\n    else {\n      for (let i = 1; i < repetitions; i++) {\n        operations.push(pattern)\n      }\n    }\n  },\n\n  //  **@forever**: Repeat forever\n  // `\"@forever\", [\"@kick\", 0.5, \"@wait\"]`\n  \"@forever\": ({ operations, error }) => {\n    const pattern = last(operations)\n    if (isArray(pattern) && pattern.length) {\n      operations.push(\"@forever\")\n      operations.push(pattern)\n    } else error(\"@forever\", ERR_EXPECT_PATTERN, pattern)\n  },\n\n  // ### Iteration and lists\n\n  //  **@iter**: Iterate a pattern\n  // `[[\"@iter\", [0.3, 1]], \"amp\", \"@set\"]`\n  \"@iter\": ({ operations, error }) => {\n    const pattern = operations.pop()\n    if (!isArray(pattern) || !pattern.length) {\n      error(\"@iter\", ERR_EXPECT_PATTERN, pattern)\n    } else {\n      // Rotates the pattern and plays the first item only each time\n      // remove \"1st\" item, schedule, then push to back:\n      const first = pattern.splice(0, 1)\n      operations.push(first)\n      pattern.push(first)\n    }\n  },\n  //  **@rotate**: Rotate a pattern\n  \"@rotate\": ({ stack, operations, error }) => {\n    const pattern = operations.pop()\n    let rot = stack.pop()\n    if (isArray(pattern) && pattern.length > 0) {\n      // ensure rot is valid between -args.length to +args.length\n      rot = rot % pattern.length\n      var copy = pattern.splice(0)\n      // rotate in-place\n      pattern.push.apply(pattern, copy.slice(rot))\n      pattern.push.apply(pattern, copy.slice(0, rot))\n      // schedule a shallow copy:\n      operations.push(copy)\n    } else {\n      error(\"@rotate\", ERR_EXPECT_PATTERN, pattern)\n    }\n  },\n\n  // ### Utilities\n\n  // **@mtof**: midi to frequency\n  // [60, '@mtof']\n  \"@mtof\": ({ stack }) => {\n    const midi = stack.pop()\n    const freq = 440 * Math.pow(2, (+midi - 69) / 12)\n    stack.push(freq)\n  },\n\n  // **@linear**: convert a value between two linear scales\n  // [value, fromLow, fromHi, toLow, toHi, \"@linear\"]\n  \"@linear\": ({ stack }) => {\n    const ohi = stack.pop()\n    const olo = stack.pop()\n    const ihi = stack.pop()\n    const ilo = stack.pop()\n    const v = stack.pop()\n\n    if (ihi === ilo) {\n      stack.push(olo)\n    } else {\n      stack.push(olo + (ohi - olo) * ((v - ilo) / (ihi - ilo)))\n    }\n  }\n}\n"],"names":["defer","fn","data","createCommands","vm","operations","proc","error","pattern","pop","isArray","fork","ERR_EXPECT_PATTERN","stack","name","isString","stop","ERR_EXPECT_STRING","stopAll","remove","procs","i","length","splice","insert","push","p","time","at","len","Infinity","expandAliases","commands","keys","forEach","op","init","Gibberish","options","context","audio","GibberishDriver","bpm","addInstruments","createInstruments","kick","Kick","decay","connect","snare","Snare","snappy","hat","Hat","amp","conga","Conga","freq","tom","Tom","pluck","PolyKarplusStrong","maxVoices","bass","MonoSynth","Time","beats","sampleRate","perc","pitched","ctx","get","damping","Math","log","note","velocity","AudioContext","WebAudioDriver","clock","ac","callback","lookAhead","updateInterval","next","currentTime","tick","setInterval","synth","osc","createOscillator","frequency","value","createGain","gain","destination","start","setValueAtTime","linearRampToValueAtTime","random","rnd","irnd","floor","n","shuffle","j","x","a","prob","debug","console","bind","peek","id","set","slice","reverse","voice","voiceNote","initGibberish","gibberish","initWebAudio","waa","driver","plugins","VM","addCommands","stdlib","compatibility","cmds","Array","isFn","last","Context","parent","this","local","Object","assign","c","target","undefined","let","isCommand","o","isProgram","procId","Process","program","rate","instr","cmd","limit","step","Error","msg","obj","procsByName","onfork","onstop","onended","delay","dur","nextTime","resume","ERR_INST_MISSING","AudioDriver","instruments","initCommands","addContext","instName","instrument","parseFloat","factor","bpm2bpa","_this2","sequencers","inst","pitch","timeToBeats","beatsToTime","audioContext","when","_this","zero","trigger","wrap","b","op1","op2","test","success","wait","abs","Number","repetitions","first","rot","copy","apply","midi","pow","ohi","olo","ihi","ilo","v","p1","p2"],"mappings":"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"}
{"version":3,"file":"ash-vm.js","sources":["../src/scheduler.js","../src/commands.js","../src/stdlib/random.js","../src/stdlib/index.js","../src/vm.js","../src/audio/gibberish.js","../src/index.js","../src/context.js","../src/process.js","../src/events.js","../src/utils.js","../src/stdlib/core.js","../src/stdlib/errors.js","../src/stdlib/audio.js","../src/stdlib/iterables.js","../src/stdlib/execution.js","../src/stdlib/process.js","../src/stdlib/schedule.js","../src/stdlib/context.js","../src/stdlib/debug.js","../src/stdlib/utilities.js","../src/audio-driver.js"],"sourcesContent":["// # Scheduler\nimport Process from \"./process\"\nimport Events from \"./events\"\n\n// The purpose of the Scheduler is to run processes concurrently.\nexport default class Scheduler {\n  constructor (options = {}) {\n    this.procs = [] // the procs are inverse ordered by time\n    this.procsByName = {} // a map of names to procs\n    this.time = 0\n    this.events = new Events()\n    if (options.events) this.events.register(options.events)\n  }\n\n  // Create a new process\n  fork (name, parent, program, delay = 0, rate) {\n    const time = this.time + delay\n    // if has parent and no rate, try to use it\"s rate\n    if (!rate && parent) rate = parent.rate\n    // if has parent try to use it\"s context\n    const context = parent ? parent.context || parent : undefined\n    // create the new process and insert into the process stack\n    const proc = new Process(program, context, time, rate)\n    insert(proc, this.procs)\n    // if has name, register it\n    if (name) this.procsByName[name] = proc\n    this.events.emit(\"fork\", proc)\n    return proc\n  }\n\n  // run the vm for the given amount of time (Infinity if not specified)\n  resume (commands, dur = Infinity, limit = 10000) {\n    const { procs } = this\n    if (procs.length > 0) {\n      const nextTime = this.time + dur\n      while (--limit > 0 && at(procs) < nextTime) {\n        const proc = procs.pop()\n        if (proc.resume(commands, nextTime)) {\n          // the proc has more operations, re-schedule\n          insert(proc, this.procs)\n        } else {\n          this.events.emit(\"ended\", { proc, time: this.time })\n        }\n      }\n      this.time = nextTime\n    } else {\n      this.time += dur\n    }\n    return procs.length > 0\n  }\n\n  stopAll () {\n    this.procs.length = 0\n  }\n\n  // The stop function can stop a proccess by name or by object\n  stop (name) {\n    let proc\n    if (typeof proc === \"string\") {\n      proc = this.procsByName[name]\n      this.procsByName[name] = null\n    } else {\n      proc = name\n      name = null\n    }\n\n    this.events.emit(\"stop\", { proc })\n\n    remove(proc, this.procs)\n  }\n}\n\n// **~~private~~**\n\n// remove a process process\nfunction remove (proc, procs) {\n  let i = procs.length - 1\n  while (i >= 0 && procs[i] !== proc) {\n    i--\n  }\n  // if found, remove it\n  if (i !== -1) procs.splice(i, 1)\n  return i !== -1\n}\n\n// insert a process into a stack ordered by time\n// (in fact, is inverse order because it\"s a stack)\nfunction insert (proc, procs) {\n  if (procs.length === 0) {\n    // no need to sort: just push it\n    procs.push(proc)\n  } else {\n    // procs are sorted on insertion\n    let i = procs.length - 1\n    let p = procs[i]\n    while (p && p.time <= proc.time) {\n      i--\n      p = procs[i]\n    }\n    procs.splice(i + 1, 0, proc)\n  }\n  return proc\n}\n\n// get time of the next process\nfunction at (procs) {\n  const len = procs.length\n  return len ? procs[len - 1].time : Infinity\n}\n","// # Commands\nimport { isArray } from \"./utils\"\n// test if the given operation is an instruction name\nconst isCommand = o => typeof o === \"string\" && o[0] === \"@\"\n\n// The Commands resolves a `@command` string into a functions\nexport default class Commands {\n  constructor (commands = []) {\n    this.operators = []\n    this.add(commands)\n  }\n\n  // Add commands to this one\n  // commands can be functions or maps\n  add (commands) {\n    if (isArray(commands)) {\n      let len = commands.length\n      while (len--) this.add(commands[len])\n    } else {\n      this.operators.push(toOperator(commands))\n    }\n    return this\n  }\n\n  // Given a command, return its operation\n  resolve (command) {\n    const { operators } = this\n    let len = operators.length\n    while (len--) {\n      const compiled = operators[len](command)\n      if (compiled) return compiled\n    }\n  }\n}\n\n// Compile a program: convert all @commands into functions\n// This allows to:\n// 1. Detect syntax errors in an early stage\n// 2. Improve performance\nexport function compile (program, commands, strict = false) {\n  return program.map(instruction => {\n    if (isArray(instruction)) {\n      return compile(instruction, commands, strict)\n    } if (isCommand(instruction)) {\n      const fn = commands.resolve(instruction)\n      if (fn) return fn\n      else if (strict) throw Error(\"Command not found: \" + instruction)\n    } else {\n      return instruction\n    }\n  })\n}\n\n// #### ~~private~~\n\n// An operator is a function that given a @command, returns a compiled function\nfunction toOperator (obj) {\n  if (typeof obj === \"function\") return obj\n  else if (typeof obj === \"object\") return mapToOperator(obj)\n  else throw Error(\"Invalid operator: \" + obj)\n}\n\n// Convert a map into a function\nfunction mapToOperator (map) {\n  return function (cmd) {\n    const op = map[cmd]\n    if (typeof op === \"string\") return map[op]\n    else return op\n  }\n}\n","// ## Random\nimport { isArray } from \"../utils\"\nimport { ERR_EXPECT_PATTERN } from \"./errors\"\nconst { floor } = Math\n\n// A collection of commands related to randomness\n\n// #### Commands\nexport default function random ({ random } = {}) {\n  // allow to use a custom random function\n  const rnd = random || Math.random\n  // a function that generates integer random from 0 to n\n  const irnd = n => floor(rnd() * n)\n\n  const shuffle = a => {\n    var j, x, i\n    for (i = a.length; i; i--) {\n      j = floor(random() * i)\n      x = a[i - 1]\n      a[i - 1] = a[j]\n      a[j] = x\n    }\n  }\n\n  return {\n    // **@random**: Generate a random number between 0 and 1\n    // `[\"@random\", \"amp\", \"@set\"]`\n    \"@random\": ({ stack }) => stack.push(rnd()),\n\n    // **@rand**: Alias for @random\n    \"@rand\": \"@random\",\n\n    // **@srandom**: Generate a random number between -1 and 1\n    // `[\"@srandom\", \"phase\", \"@set\"]`\n    \"@srandom\": ({ stack }) => stack.push(rnd() * 2 - 1),\n\n    // **@srand**: Alias for @srandom\n    \"@srand\": \"@srandom\",\n\n    // **@randi**: Generate a random integer between 0 and n\n    // `[40, \"@randi\", 20, \"@+\", \"@mtof\", \"freq\", \"@set\"]`\n    \"@randi\": ({ stack }) => stack.push(irnd(stack.pop())),\n\n    // **@pick**: pick a random element from a list\n    // `[\"@list\", [1, 2, 3, 4], \"@pick\", \"amp\", \"@set\"]`\n    \"@pick\": ({ stack, error }) => {\n      const list = stack.pop()\n      if (!isArray(list)) {\n        error(\"Can't pick an element if is not an array\", list)\n      } else {\n        const i = irnd(list.length)\n        stack.push(list[i])\n      }\n    },\n\n    // **@chance* *: Probabilistic execution\n    // [probability, \"@chance\", executed-if-true, executed-if-false]\n    // `[0.5, \"@chance\", [440, \"freq\", \"@set\"], [\"@rand\", \"amp\", \"@set\"]]`\n    \"@chance\": ({ stack, operations }) => {\n      const prob = stack.pop()\n      const ifTrue = operations.pop()\n      if (rnd() < prob) {\n        // Skip the 'false branch'\n        operations.pop()\n        // Set the 'true branch' as the next operation\n        operations.push(ifTrue)\n      } else {\n        // The 'false branch' is currenty the next operation\n        // so there's no need to do anything\n      }\n    },\n\n    // **@shuffle**: Shuffle a list\n    // `[\"@list\", [1, 2, 3], \"@shuffle\", \"@iter\"]`\n    \"@shuffle\": ({ stack, error }) => {\n      const pattern = stack.pop()\n      if (!isArray(pattern)) error(\"@shuffle\", ERR_EXPECT_PATTERN, pattern)\n      else stack.push(shuffle(pattern))\n    }\n  }\n}\n","// # Standard library\nimport Commands from \"../commands\"\nimport core from \"./core\"\nimport audio from \"./audio\"\nimport iterables from \"./iterables\"\nimport execution from \"./execution\"\nimport process from \"./process\"\nimport schedule from \"./schedule\"\nimport context from \"./context\"\nimport random from \"./random\"\nimport debug from \"./debug\"\nimport utilities from \"./utilities\"\n\n// The standard lib include all the modules\nexport default function stdlib (driver, scheduler, options = {}) {\n  return new Commands([\n    core,\n    iterables,\n    execution,\n    process,\n    context,\n    audio(driver),\n    schedule(scheduler),\n    random(options),\n    debug(options),\n    utilities,\n  ])\n}\n","// # VM\nimport Scheduler from \"./scheduler\"\nimport stdlib from \"./stdlib\"\nimport { compile } from \"./commands\"\n\n// ## VM\nexport default class VM {\n  constructor (driver, options = {}) {\n    this.context = {}\n    this.driver = driver\n    this.scheduler = new Scheduler(options)\n    this.commands = stdlib(this.driver, this.scheduler, options)\n\n    if (driver) {\n      this.addToContext(driver.defaultContext())\n      this.commands.add(createCommands(driver.getInstruments()))\n      driver.start(this)\n    }\n    if (options.commands) this.addCommands(options.commands)\n  }\n\n  addInstruments (instruments, params = []) {\n    this.driver.addInstruments(instruments)\n    this.commands.add(createCommands(instruments))\n  }\n\n  // Run a program\n  run (program, sync = true) {\n    const { scheduler } = this\n    // if there are no processes, no need to sync\n    if (sync && scheduler.procs.length) program = [\"@sync\", program]\n    // improve performance? I think so, but should benchmark\n    const compiled = compile(program, this.commands, true)\n    return scheduler.fork(null, this.context, compiled)\n  }\n\n  resume (dur, limit) {\n    return this.scheduler.resume(this.commands, dur, limit)\n  }\n\n  addCommands (commands) {\n    this.commands.add(commands)\n    return this\n  }\n\n  // Add to the initial context\n  addToContext (context) {\n    Object.assign(this.context, context)\n    return this.context\n  }\n}\n\nfunction createCommands (instruments) {\n  return Object.keys(instruments).reduce((commands, name) => {\n    commands[\"@\" + name] = ({ context }) => instruments[name](context)\n    return instruments\n  }, {})\n}\n","// # Gibberish Audio Driver\nimport AudioDriver from \"../audio-driver\"\n\n// This driver uses Gibberish both for scheduling and sounds\n\nexport default class GibberishDriver extends AudioDriver {\n  constructor (Gibberish, { bpm = 100 } = {}) {\n    if (!Gibberish.context) Gibberish.init()\n    super(bpm, Gibberish.context.sampleRate)\n    this.Gibberish = Gibberish\n    this.instruments = createInstruments(Gibberish)\n    console.log(\"MIERDA\", this.instruments)\n  }\n\n  // Start a VM\n  start (scheduler) {\n    super.start(scheduler)\n    // convert bmp to beats per audio sample\n    const bpm2bpa = 1 / (60 * this.sampleRate)\n    // tick is binded to this\n    const tick = () => {\n      scheduler.resume(this.bpm * bpm2bpa)\n    }\n    this.Gibberish.sequencers.push({ tick })\n  }\n}\n\n// # Instruments\n\n// Create a trigger function for a percussion instrument\nconst perc = (inst, gain) => (ctx) => {\n  inst.amp = gain * ctx.get(\"amp\")\n  inst.note()\n}\n\n// Create a trigger function for a tuned percussion instrument\nconst pitched = (inst, gain) => (ctx) => {\n  inst.amp = gain * ctx.get(\"amp\")\n  inst.pitch = ctx.get(\"freq\")\n  inst.note()\n}\n\n// Create the basic instruments using Gibberish\nfunction createInstruments (Gibberish) {\n  // The actual instruments\n  const kick = new Gibberish.Kick({ decay: 0.2 }).connect()\n  const snare = new Gibberish.Snare({ snappy: 1.5 }).connect()\n  const hat = new Gibberish.Hat({ amp: 1.5 }).connect()\n  const conga = new Gibberish.Conga({ amp: 0.25, freq: 400 }).connect()\n  const tom = new Gibberish.Tom({ amp: 0.25, freq: 400 }).connect()\n  const pluck = new Gibberish.PolyKarplusStrong({maxVoices: 32}).connect()\n  const bass = new Gibberish.MonoSynth({\n    attack: 44,\n    decay: Gibberish.Time.beats(0.25),\n    filterMult: 0.25,\n    octave2: 0,\n    octave3: 0\n  }).connect()\n  const sampleRate = Gibberish.sampleRate\n\n  // The instrument trigger functions\n  return {\n    kick: perc(kick, 0.5),\n    snare: perc(snare, 0.25),\n    hat: perc(hat, 1),\n    conga: pitched(conga, 0.25),\n    tom: pitched(tom, 0.25),\n    pluck: (ctx) => {\n      const amp = ctx.get(\"amp\")\n      const freq = ctx.get(\"freq\")\n      if (freq > 0) {\n        // this is not in any way accurate, just a hack to make @set-dur do something semi-meaningful\n        pluck.damping = 1 - (-6 / Math.log(freq / sampleRate))\n        // pluck by default seem too quiet:\n        pluck.note(freq, amp * amp * 2)\n      }\n    },\n    bass: (ctx) => {\n      const velocity = ctx.get(\"amp\")\n      const freq = ctx.get(\"freq\")\n      if (freq > 0) bass.note(freq, velocity)\n    }\n  }\n}\n","// # Audio Scheduler Virtual Machine\nimport VM from \"./vm\"\nimport GibDriver from \"./audio/gibberish\"\n// import waa from \"./audio/waa\"\n\n// ## Architecture overview\n\n// **Glossary**\n// - **Command**: a string that starts with `@` mapped to a function\n// - **Program**: a list of commands and values\n\n// **Classes**\n// - **Process**: execute programs (by inserting values into stack and executing the command function)\n// - **Scheduler**: run processes concurrently\n// - **Commands**: translate commands to functions\n// - **AudioDriver**: controls the scheduler. Create instruments.\n// - **VM**: holds all above and provide API functions\n\n// ## API\n// Create a VM with Gibberish audio driver\nexport function initGibberish (Gibberish, options) {\n  const driver = new GibDriver(Gibberish, options)\n  return new VM(driver, options)\n}\n\n// Create a VM with WAA audio driver\nexport function initWebAudio (context, options) {\n}\n","// # Context\n\n// A context is a hierarchical structure to store values with different\n// scopes. Every process has it's own context.\nexport default class Context {\n  // Every context has a parent. The parent can be another context\n  // or an object\n  constructor (parent) {\n    if (parent instanceof Context) this.parent = parent\n    else if (parent) this.local = Object.assign({}, parent)\n  }\n\n  // Create a child context with the given locals\n  child (local) {\n    const c = new Context(this)\n    if (local) c.local = Object.assign({}, local)\n    return c\n  }\n  // get a value from a context\n  get (id) {\n    let target = this\n    while (target.value(id) === undefined && target.parent) {\n      target = target.parent\n    }\n    return target.value(id)\n  }\n\n  // set a value from a context\n  set (id, value) {\n    let target = this\n    while (target.value(id) === undefined && target.parent) {\n      target = target.parent\n    }\n    target.let(id, value)\n  }\n\n  // get a value from the local scope of a context\n  value (id) {\n    return this.local ? this.local[id] : undefined\n  }\n\n  // set a value into the local scope of a context\n  let (id, value) {\n    if (!this.local) this.local = {}\n    this.local[id] = value\n  }\n}\n","// # Process\nimport Context from \"./context\"\n\n// #### Utilities\n// test if the given operation is an instruction name\nconst isCommand = o => typeof o === \"string\" && o[0] === \"@\"\n// test if the given operation is a program\nconst isProgram = Array.isArray\n// Give unique ids to process\nlet procId = 1\n\n// #### Error messages\n\n// The given instruction name is not in the commands object\nconst ERR_INSTR_NOT_FOUND = \"Instruction not recognized.\"\n// The max loop cycles tests\nconst ERR_LIMIT_REACHED = \"Limit reached. Probably an infinity loop.\"\n\n// ## Process\n\n// Processes are the principal computation unit. The main characteristic of\n// processes in this VM is that it models the concept of time\nexport default class Process {\n  constructor (program, context, time, rate) {\n    this.id = \"proc-\" + procId++\n    // a stack of values\n    this.stack = []\n    // the operations are also stored in a stack (reverse order)\n    this.operations = program ? [program] : []\n    // the context is used to store variables with scope\n    this.context = new Context(context)\n    // the current time\n    this.time = typeof time === \"number\" ? time : 0\n    // how fast time passes\n    this.rate = typeof rate === \"number\" ? rate : 1\n    // bind error to this, to allow destructuring it in commands\n    this.error = this.error.bind(this)\n  }\n\n  // wait an amount of time\n  wait (time) {\n    this.time += this.rate * time\n  }\n\n  // The process is agnostic about the commands to interpret\n  step (commands) {\n    const { operations } = this\n    if (operations.length) {\n      const instr = operations.pop()\n      if (instr === null || instr === undefined) {\n        // ignore\n      } else if (typeof instr === \"function\") {\n        instr(this)\n      } else if (isProgram(instr)) {\n        // if it\"s program, and since the operations are stored into an stack,\n        // we need add to the program operations in reverse order\n        for (let i = instr.length - 1; i >= 0; i--) {\n          operations.push(instr[i])\n        }\n      } else if (isCommand(instr)) {\n        const cmd = commands.resolve(instr)\n        if (typeof cmd === \"function\") cmd(this)\n        else this.error(\"step > \", ERR_INSTR_NOT_FOUND, instr)\n      } else {\n        // if it\"s a value, push it into the stack\n        this.stack.push(instr)\n      }\n    }\n  }\n\n  // the `resume` function run all the operations until time is reached\n  resume (commands, time = Infinity, limit = 10000) {\n    const { operations } = this\n    while (--limit > 0 && this.time < time && operations.length) {\n      this.step(commands)\n    }\n    if (limit === 0) throw Error(ERR_LIMIT_REACHED)\n    return operations.length > 0\n  }\n\n  // an utility function to write errors\n  error (instr, msg, obj) {\n    console.error(instr, msg, obj, \"id\", this.id, \"time\", this.time)\n  }\n}\n","\nconst get = (all, type) => all[type] || (all[type] = [])\n\nexport default class Events {\n  constructor () {\n    this.all = {}\n  }\n  register (events) {\n    Object.keys(events).forEach(type => this.on(type, events[type]))\n  }\n  on (type, handler) {\n    get(this.all, type).push(handler)\n  }\n  emit (type, event) {\n    get(this.all, type).map(handler => handler(event))\n    get(this.all, \"*\").map(handler => handler(type, event))\n  }\n}\n","// # Utilities\n\n// A collection of shared utility functions\n\n// copy values from one or more sources to a target\n// see: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\nexport const assign = Object.assign\n\n// test if an object is an array\nexport const isArray = Array.isArray\n\n// test if an object is a string\nexport const isString = x => typeof x === \"string\"\n\n// test if an object is a function\nexport const isFn = x => typeof x === \"function\"\n\n// test if an object is a number\nexport const isNum = x => typeof x === \"number\"\n\n// test if an object is defined\nexport const isDef = x => typeof x !== \"undefined\"\n\n// get last element from an array\nexport const last = a => a[a.length - 1]\n\n// get the next element of stack without remove it\nexport const peek = last\n","// # Core\n\n// **wrap**: A modulo operation that handles negative n more appropriately\n// e.g. wrap(-1, 3) returns 2\n// see http://en.wikipedia.org/wiki/Modulo_operation\n// see also http://jsperf.com/modulo-for-negative-numbers\nexport const wrap = (a, b) => (a % b + b) % b\n\n// **op1**: A generic stack operation that pops one value and pushes on result\nexport const op1 = fn => ({ stack }) => {\n  stack.push(fn(stack.pop()))\n}\n\n// **op2**: A generic stack operation that pops two values and pushes one result\nexport const op2 = fn => ({ stack }) => {\n  stack.push(fn(stack.pop(), stack.pop()))\n}\n\n// The core of stdlib commands. It include arithmetic, logic,\n// execution and repetition\n\nexport default {\n  // ## Arithmetic\n  // Arithmetic operation commands\n\n  // **@+**, **@add**: Add two values\n  // `[1, 2, \"@+\"]`\n  \"@+\": op2((b, a) => a + b),\n  \"@add\": \"@+\",\n\n  // **@-**, **@sub**: Subtract two values\n  // `[2, 1, \"@-\"]`\n  \"@-\": op2((b, a) => a - b),\n  \"@sub\": \"@-\",\n\n  // **@\\***, **@mul**: Multiply two values\n  // `[2, 4, \"@*\"]`\n  \"@*\": op2((b, a) => a * b),\n  \"@mul\": \"@*\",\n\n  // **@/**, **@div**: Divide two values\n  // `[4, 2, \"@/\"]`\n  \"@/\": op2((b, a) => b === 0 ? 0 : a / b),\n  \"@div\": \"@/\",\n\n  // **@%**, **@wrap**: Modulo for positive and negative numbers\n  // `[4, -2, \"@%\"]`\n  \"@%\": op2((b, a) => b === 0 ? 0 : wrap(a, b)),\n  \"@wrap\": \"@%\",\n\n  // **@mod**: Standard modulo operation\n  // `[4, 2, \"@mod\"]`\n  \"@mod\": op2((b, a) => b === 0 ? 0 : a % b),\n\n  // **@neg**: The negative of a value\n  // `[4, \"@neg\"]`\n  \"@neg\": op1(a => -a),\n\n  // ## Logic\n  // Logic commands, including conditional execution\n\n  // **@cond**: Conditional execution\n  // `[true, \"@cond\", [<success pattern>], [<fail pattern>]]`\n  \"@cond\": ({ stack, operations }) => {\n    const test = stack.pop()\n    // this is the pattern to execute if the test passes\n    const success = operations.pop()\n    // the next pattern is the \"else\" part\n    if (test) {\n      // remove the \"else\" part\n      operations.pop()\n      operations.push(success)\n    }\n  },\n\n  // **@>**: Greater than\n  \"@>\": op2((b, a) => a > b),\n\n  // **@>=**: Greater or equal than\n  \"@>=\": op2((b, a) => a >= b),\n\n  // **@<**: Less than\n  \"@<\": op2((b, a) => a < b),\n\n  // **@<=**: Less or equal than\n  \"@<=\": op2((b, a) => a <= b),\n\n  // **@==**: Is equal\n  \"@==\": op2((b, a) => a === b),\n\n  // **@!=**: Is not equal\n  \"@!=\": op2((b, a) => a !== b),\n  \"@!\": op1(a => !a),\n\n  // **@!**: Logic not\n  \"@not\": \"@!\",\n\n  // **@&&**, **@and**: Logic and\n  \"@&&\": op2((b, a) => a && b),\n  \"@and\": \"@&&\",\n\n  // **@||**, **@or**: Logic or\n  \"@||\": op2((b, a) => a || b),\n  \"@or\": \"@||\",\n}\n","// # Errors\n\n// A shared errors messages\nexport const ERR_EXPECT_PATTERN = \"Expected a pattern, but found:\"\nexport const ERR_EXPECT_LIST = \"Expected a iterable list, but found:\"\nexport const ERR_EXPECT_STRING = \"Expected a string, but found:\"\nexport const ERR_INST_MISSING = \"Instrument not found:\"\nexport const ERR_EXPECT_NUM = \"Expected a number, but found:\"\n","// # Audio\nimport { ERR_INST_MISSING } from \"./errors\"\n\n// Audio related commands\n\nexport default driver => ({\n  // **@play**: Trigger a note. It uses the context to select the appropiate\n  // voice and parameters\n  // `\"@play\"`\n  \"@play\": ({ context, error }) => {\n    const instName = context.get(\"voice\")\n    const instrument = driver.instruments[instName]\n    if (instrument) {\n      instrument(context)\n    } else {\n      error(\"@play\", ERR_INST_MISSING, instName)\n    }\n  },\n  // **@set-bpm**: Change the global tempo\n  // `120, \"@set-bpm\"`\n  \"@set-bpm\": ({ stack }) => {\n    const bpm = parseFloat(stack.pop(), 10)\n    if (bpm > 0) driver.bpm = bpm\n  },\n  \"@scale-tempo\": ({ stack }) => {\n    const factor = parseFloat(stack.pop(), 10)\n    if (factor) driver.bpm = driver.bpm * factor\n  }\n})\n","// ## Iterables\nimport { isArray, isNum } from \"../utils\"\nimport { ERR_EXPECT_LIST, ERR_EXPECT_NUM } from \"./errors\"\n\n// Commands to work with iterables\nexport default {\n  // **@list**: Store a list into the stack to allow other operations\n  // use or change the list\n  // `[\"@list\", [1, 2, 3]]`\n  \"@quote\": ({ stack, operations, error }) => {\n    const list = operations.pop()\n    if (!isArray(list)) error(\"@list\", ERR_EXPECT_LIST, list)\n    else stack.push(list)\n  },\n  \"@q\": \"@quote\",\n\n  //  **@iter**: Iterate a list\n  // `[\"@list\", [1, 2, 3], \"@iter\", \"amp\", \"@set\"]`\n  \"@iter\": ({ stack, error }) => {\n    const list = stack.pop()\n    if (!isArray(list)) {\n      error(\"@iter\", ERR_EXPECT_LIST, list)\n    } else {\n      // Add the next element into the stack\n      const next = list.shift()\n      stack.push(next)\n      // rotate (and mutate) the pattern\n      list.push(next)\n    }\n  },\n\n  //  **@reverse**: Reverse a list\n  // `[\"@list\", [1, 2, 3], \"@reverse\"]`\n  \"@reverse\": ({ stack, error }) => {\n    const list = stack.pop()\n    if (!isArray(list)) error(\"@reverse\", ERR_EXPECT_LIST, list)\n    else stack.push(list.slice().reverse())\n  },\n\n  //  **@rotate**: Rotate a pattern\n  // `[\"@list\", [1, 2, 3, 4], 2, \"@rotate\"]`\n  \"@rotate\": ({ stack, error }) => {\n    const rotations = stack.pop()\n    const list = stack.pop()\n\n    if (!isArray(list)) {\n      error(\"@rotate\", ERR_EXPECT_LIST, list)\n    } else if (!isNum(rotations)) {\n      error(\"@rotate\", ERR_EXPECT_NUM, rotations)\n    } else {\n      // ensure rot is valid between -args.length to +args.length\n      const rot = rotations % list.length\n      // FIXME: find a more performant way to do rotation\n      var copy = [].concat(list.slice(rot)).concat(list.slice(0, rot))\n      stack.push(copy)\n    }\n  },\n}\n","// # Execution\nimport { last, isString, isArray } from \"../utils\"\nimport { ERR_EXPECT_PATTERN, ERR_EXPECT_STRING } from \"./errors\"\n\n// Basic execution operations\nexport default {\n  //  **@dup**: Duplicate item (so you can use it twice)\n  // `10,\"@dup\"`\n  \"@dup\": ({ stack }) => stack.push(last(stack)),\n\n  //  **@execute**: Execute an instruction\n  // `10, 20, \"add\", \"@execute\"`\n  \"@execute\": ({ operations, error }) => {\n    const instr = operations.pop()\n    if (isString(instr)) operations.push(\"@\" + instr)\n    else error(\"@execute\", ERR_EXPECT_STRING, instr)\n  },\n  //  **@**: Alias of @execute\n  // `10,\"dup\",\"@\"`\n  \"@\": \"@execute\",\n\n  //  **@repeat**: Repeat\n  // `4, \"@repeat\", [\"@kick\", 0.5, \"@wait\"]`\n  \"@repeat\": ({ stack, operations, error }) => {\n    const repetitions = stack.pop()\n    const pattern = last(operations)\n    if (!isArray(pattern)) error(\"@repeat\", ERR_EXPECT_PATTERN, pattern)\n    else {\n      for (let i = 1; i < repetitions; i++) {\n        operations.push(pattern)\n      }\n    }\n  },\n\n  //  **@forever**: Repeat forever\n  // `\"@forever\", [\"@kick\", 0.5, \"@wait\"]`\n  \"@forever\": ({ operations, error }) => {\n    const pattern = last(operations)\n    if (isArray(pattern) && pattern.length) {\n      operations.push(\"@forever\")\n      operations.push(pattern)\n    } else error(\"@forever\", ERR_EXPECT_PATTERN, pattern)\n  },\n}\n","// # Process\nimport { isArray } from \"../utils\"\nimport { ERR_EXPECT_PATTERN } from \"./errors\"\n\n// Commands to control the current process\nexport default {\n  // **@wait**: Wait an amount of time (in beats)\n  // `1,\"@wait\"`\n  \"@wait\": proc => proc.wait(Math.abs(Number(proc.stack.pop()))),\n\n  // **@sync**: Wait until next beat\n  \"@sync\": proc => proc.wait(Math.floor(proc.time) + 1 - proc.time),\n\n  // **@scale-rate**: Change the current rate by a factor\n  // `[1.5, \"@scale-rate\"]`\n  \"@scale-rate\": proc => {\n    const factor = parseFloat(proc.stack.pop(), 10)\n    if (factor > 0) proc.rate *= factor\n  },\n\n  // **@with-rate**:\n  \"@with-rate\": ({ stack, operations, error }) => {\n    const factor = parseFloat(stack.pop(), 10)\n    const pattern = operations.pop()\n    if (!isArray(pattern)) error(\"@with-rate\", ERR_EXPECT_PATTERN, pattern)\n    operations.push([\n      factor,\n      \"@scale-rate\",\n      pattern,\n      1 / factor,\n      \"@scale-rate\"\n    ])\n  },\n\n}\n","// ## Schedule\nimport { isArray, isString } from \"../utils\"\nimport { ERR_EXPECT_PATTERN, ERR_EXPECT_STRING } from \"./errors\"\n\n// Commands related to process scheduling\nexport default (scheduler) => ({\n  // **@loop**: a special fork that repeats a pattern forever\n  // `['@loop', [...]]`\n  \"@loop\": proc => {\n    const { operations, error } = proc\n    const pattern = operations.pop()\n    if (isArray(pattern)) scheduler.fork(null, proc, [\"@forever\", pattern])\n    else error(\"@loop\", ERR_EXPECT_PATTERN, pattern)\n  },\n\n  // **fork**: start a new (child) process. The child process uses the context of\n  // the parent process\n  \"@fork\": proc => {\n    const { operations, error } = proc\n    let pattern = operations.pop()\n\n    if (isArray(pattern)) {\n      scheduler.fork(null, proc, pattern)\n    } else {\n      error(\"@fork\", ERR_EXPECT_PATTERN, pattern)\n    }\n  },\n\n  // **@spawn**: start a new process with a name. Replace the old process with the\n  // same name if any.\n  \"@spawn\": proc => {\n    const { stack, operations, error } = proc\n    const name = stack.pop()\n    let pattern = operations.pop()\n    if (!isString(name)) {\n      error(\"@spawn\", ERR_EXPECT_STRING, name)\n    } else if (!isArray(pattern)) {\n      error(\"@spawn\", ERR_EXPECT_PATTERN, pattern)\n    } else {\n      scheduler.stop(name)\n      scheduler.fork(name, proc, [\"@forever\", pattern])\n    }\n  },\n\n  // **@stop-all**: stop all processes\n  \"@stop-all\": proc => scheduler.stopAll(),\n\n  // **@stop**: stop the current process\n  \"@stop\": ({ stack }) => scheduler.stop(stack.pop())\n})\n","// # Context\n// Commands to use the context\n\n// **@let**: Assign a value to the local context\n// `[440, \"freq\", \"@let\"]`\nconst letFn = ({ stack, context }) => context.let(stack.pop(), stack.pop())\n\n// **@set**: Assign a value to the global context\n// `[0.8, \"amp\", \"@set\"]\nconst setFn = ({ stack, context }) => context.set(stack.pop(), stack.pop())\n\n// **@get**: Get a value from the context and push it into the stack\n// `[\"freq\", \"@get\", 2, \"@*\"]`\nconst getFn = ({ stack, context }) => stack.push(context.get(stack.pop()))\n\n// **@let-_name_**: Asign a value to the local context with the given _name_\n// `[440, \"@let-freq\"]\nconst letName = (name) => ({ stack, context }) => context.let(name, stack.pop())\n\n// **@set-_name_**: Asign a value to the global context with the given _name_\n// `[440, \"@set-freq\"]\nconst setName = (name) => ({ stack, context }) => context.set(name, stack.pop())\n\n// **@get-_name_**: Get the _name_ value from the context and push into the stack\n// `[\"@get-freq\", 2, \"@*\"]\nconst getName = (name) => ({ stack, context }) => stack.push(context.get(name))\n\nexport default (cmd) =>\n  cmd === \"@let\" ? letFn\n  : cmd === \"@set\" ? setFn\n  : cmd === \"@get\" ? getFn\n  : /^@let-.+/.exec(cmd) ? letName(cmd.slice(5))\n  : /^@set-.+/.exec(cmd) ? setName(cmd.slice(5))\n  : /^@get-.+/.exec(cmd) ? getName(cmd.slice(5))\n  : undefined\n","// # Debug operations\nimport { peek } from \"../utils\"\n\n// | Name | Description | Example |\n// |------|-------------|---------|\n// | **@print** | Print the last value of the stack | `10,\"@print\"` |\n// | **@log** | Log the name with the last value of the stack | `\"@random\", \"amp\", \"@log\"` |\nexport default ({ log }) => {\n  log = log || console.log.bind(console)\n\n  return {\n    \"@print\": proc => {\n      const { stack } = proc\n      const last = stack.length ? peek(stack) : \"<Empty Stack>\"\n      log(\"@print\", last, \"(id, time)\", proc.id, proc.time)\n    },\n    \"@log\": proc => {\n      const { stack } = proc\n      const name = stack.pop()\n      const last = stack.length ? peek(stack) : \"<Empty Stack>\"\n      log(\"@log\", name, last, \"(id, time)\", proc.id, proc.time)\n    },\n    \"@debug\": proc => {\n      const { stack } = proc\n      log(\"@debug\", stack, proc.id, proc.time)\n    }\n  }\n}\n","// # Utilities\n// Utility commands\n\nexport default {\n  // **@mtof**: midi to frequency\n  // [60, '@mtof']\n  \"@mtof\": ({ stack }) => {\n    const midi = stack.pop()\n    const freq = 440 * Math.pow(2, (+midi - 69) / 12)\n    stack.push(freq)\n  },\n\n  // **@linear**: convert a value between two linear scales\n  // [value, fromLow, fromHi, toLow, toHi, \"@linear\"]\n  \"@linear\": ({ stack }) => {\n    const ohi = stack.pop()\n    const olo = stack.pop()\n    const ihi = stack.pop()\n    const ilo = stack.pop()\n    const v = stack.pop()\n\n    if (ihi === ilo) {\n      stack.push(olo)\n    } else {\n      stack.push(olo + (ohi - olo) * ((v - ilo) / (ihi - ilo)))\n    }\n  },\n}\n","// # Audio Driver\n\n// The audio driver has two tasks:\n// 1. Control the time by calling `resume` on the VM\n// 2. Create and play instruments\n\nexport default class AudioDriver {\n  constructor (bpm, sampleRate) {\n    if (!bpm) throw Error(\"AudioDriver bpm is required\")\n    if (!sampleRate) throw Error(\"AudioDriver sampleRate is required\")\n    this.bpm = bpm\n    this.sampleRate = sampleRate\n    this.instruments = {}\n  }\n\n  addInstruments (instruments) {\n    console.log(\"ADD INSTRUMENTS\", instruments)\n    Object.assign(this.instruments, instruments)\n    return this.instruments\n  }\n\n  getInstruments () {\n    return this.instruments\n  }\n\n  defaultContext () {\n    return { freq: 440, amp: 0.5 }\n  }\n\n  start (scheduler) {\n    if (this.scheduler) throw Error(\"Can't attach an audio driver twice\")\n    if (scheduler.audio) throw Error(\"The given scheduler has an audio driver already\")\n    this.scheduler = scheduler\n    scheduler.audio = this\n  }\n}\n"],"names":["remove","proc","procs","i","length","splice","insert","push","p","time","at","len","Infinity","compile","program","commands","strict","map","isArray","instruction","isCommand","fn","resolve","Error","toOperator","obj","mapToOperator","cmd","op","random","rnd","Math","irnd","floor","n","shuffle","j","x","a","stack","pop","error","list","operations","prob","ifTrue","pattern","ERR_EXPECT_PATTERN","stdlib","driver","scheduler","options","Commands","core","iterables","execution","process","context","audio","schedule","debug","utilities","createCommands","instruments","Object","keys","reduce","name","createInstruments","Gibberish","kick","Kick","decay","connect","snare","Snare","snappy","hat","Hat","amp","conga","Conga","freq","tom","Tom","pluck","PolyKarplusStrong","maxVoices","bass","MonoSynth","Time","beats","sampleRate","perc","pitched","ctx","get","damping","log","note","velocity","initGibberish","VM","GibDriver","initWebAudio","Context","parent","this","local","assign","c","id","target","undefined","value","let","o","isProgram","Array","procId","Process","rate","bind","instr","limit","step","msg","all","type","Events","events","forEach","_this","on","handler","event","Scheduler","procsByName","register","delay","emit","dur","nextTime","resume","isString","isNum","last","peek","operators","add","command","compiled","wrap","b","op1","op2","test","success","ERR_EXPECT_LIST","instName","instrument","bpm","parseFloat","factor","next","shift","slice","reverse","rotations","rot","copy","concat","repetitions","wait","abs","Number","fork","stop","stopAll","letFn","setFn","set","getFn","letName","setName","getName","exec","console","midi","pow","ohi","olo","ihi","ilo","v","addToContext","defaultContext","getInstruments","start","addCommands","addInstruments","sync","AudioDriver","GibberishDriver","init","bpm2bpa","tick","_this2","sequencers","inst","gain","pitch"],"mappings":"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"}
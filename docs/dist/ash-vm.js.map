{"version":3,"file":"ash-vm.js","sources":["../../lib/process.js","../../lib/commands.js","../../lib/vm.js","../../lib/audio/gibberish/index.js","../../lib/audio/waa/index.js","../../lib/ext/random.js","../../lib/ext/debug.js","../../lib/ext/compatibility.js","../../lib/index.js","../../lib/utils.js"],"sourcesContent":["// # Process\n\n// defer a function\nfunction defer (fn, data) {\n  setTimeout(() => { fn(data) }, 0)\n}\n\nconst isCommand = o => typeof o === \"string\" && o[0] === \"@\"\nconst isProgram = Array.isArray\nlet procId = 1\nconst ERR_INSTR_NOT_FOUND = \"Instruction not recognized.\"\nconst ERR_LIMIT_REACHED = \"Limit reached. Probably an infinity loop.\"\n\n// Processes are the principal computation unit. It departures from typical\n// processes in that it model the concept of time\nexport class Process {\n  constructor (program, context, time, rate) {\n    this.id = \"proc-\" + procId++\n    // a stack of values\n    this.stack = []\n    // the operations are stored in a stack (in reverse order)\n    this.operations = program ? [program] : []\n    // the context is used to store variables with scope\n    this.context = new Context(context)\n    // the current time\n    this.time = typeof time === \"number\" ? time : 0\n    // how fast time passes\n    this.rate = typeof rate === \"number\" ? rate : 1\n    // bind error to allow destructuring in commands\n    this.error = this.error.bind(this)\n  }\n\n  // wait an amount of time\n  wait (time) {\n    this.time += this.rate * time\n  }\n\n  // The process is agnostic about the commands to be use\n  step (commands) {\n    const { operations } = this\n    if (operations.length) {\n      const instr = operations.pop()\n      if (instr === null || instr === undefined) {\n        // ignore\n      } else if (typeof instr === \"function\") {\n        // it runs the functions but outside the loop\n        defer(instr, this.time)\n      } else if (isProgram(instr)) {\n        // if it\"s program, and since the operations are stored into an stack,\n        // we need add to the program operations in reverse order\n        for (let i = instr.length - 1; i >= 0; i--) {\n          operations.push(instr[i])\n        }\n      } else if (isCommand(instr)) {\n        const cmd = commands[instr]\n        if (typeof cmd === \"function\") cmd(this)\n        else this.error(\"step > \", ERR_INSTR_NOT_FOUND, instr)\n      } else {\n        // if it\"s a value, push it into the stack\n        this.stack.push(instr)\n      }\n    }\n  }\n\n  // the `resume` function run all the operations until time is reached\n  resume (commands, time = Infinity, limit = 10000) {\n    const { operations } = this\n    while (--limit > 0 && this.time < time && operations.length) {\n      this.step(commands)\n    }\n    if (limit === 0) throw Error(ERR_LIMIT_REACHED)\n    return operations.length > 0\n  }\n\n  // an utility function to write errors\n  error (instr, msg, obj) {\n    console.error(instr, msg, obj, \"id\", this.id, \"time\", this.time)\n  }\n}\n\n// ## Context\n\n// A context is a hierarchical structure to store values with scope\nexport class Context {\n  constructor (parent) {\n    if (parent instanceof Context) this.parent = parent\n    else if (parent) this.local = Object.assign({}, parent)\n  }\n\n  // Create a child\n  child (local) {\n    const c = new Context(this)\n    c.local = Object.assign({}, local)\n    return c\n  }\n  // get a value from a context\n  get (id) {\n    let target = this\n    while (target.value(id) === undefined && target.parent) {\n      target = target.parent\n    }\n    return target.value(id)\n  }\n\n  // set a value from a context\n  set (id, value) {\n    let target = this\n    while (target.value(id) === undefined && target.parent) {\n      target = target.parent\n    }\n    target.let(id, value)\n  }\n  // get a value from the local scope of a context\n  value (id) {\n    return this.local ? this.local[id] : undefined\n  }\n\n  // set a value into the local scope of a context\n  let (id, value) {\n    if (!this.local) this.local = {}\n    this.local[id] = value\n  }\n}\n","// # Commands\nimport { isArray, isString, last, wrap } from \"./utils\"\n\n// **Error messages**\nexport const ERR_EXPECT_PATTERN = \"Expected a pattern, but found:\"\nexport const ERR_EXPECT_STRING = \"Expected a string, but found:\"\n\n// **Utilities**\n\n// A generic stack operation that pops one value and pushes on result\nconst op1 = fn => ({ stack }) => {\n  stack.push(fn(stack.pop()))\n}\n\n// A generic stack operation that pops two values and pushes one result\nconst op2 = fn => ({ stack }) => {\n  stack.push(fn(stack.pop(), stack.pop()))\n}\n\n// A commands object is a map from instrunction name to functions\nexport default {\n  // ## Arithmetic\n  // | Name | Description | Example |\n  // |------|-------------|---------|\n  // | **@+**, **@add** | Add two values | `[1, 2, \"@+\"]` |\n  // | **@-**, **@sub** | Subtract two values | `[2, 1, \"@-\"]` |\n  // | **@\\***, **@mul** | Multiply two values | `[2, 4, \"@*\"]` |\n  // | **@/**, **@div** | Divide two values | `[4, 2, \"@*\"]` |\n  // | **@%**, **@wrap** | Modulo for positive and negative numbers | `[4, -2, \"@%\"]` |\n  // | **@mod* | Standard modulo operation | `[4, 2, \"@mod\"]` |\n  // | **@neg* | The negative of a value | `[4, \"@neg\"]` |\n  // [1, 2, \"@+\"]\n  \"@+\": op2((b, a) => a + b),\n  // [1, 2, \"@add\"]\n  \"@add\": \"@+\",\n  // [2, 1, \"@-\"]\n  \"@-\": op2((b, a) => a - b),\n  // [2, 1, \"@sub\"]\n  \"@sub\": \"@-\",\n  \"@*\": op2((b, a) => a * b),\n  \"@mul\": \"@*\",\n  \"@/\": op2((b, a) => b === 0 ? 0 : a / b),\n  \"@div\": \"@/\",\n  \"@%\": op2((b, a) => b === 0 ? 0 : wrap(a, b)),\n  \"@wrap\": \"@%\",\n  \"@mod\": op2((b, a) => b === 0 ? 0 : a % b),\n  \"@neg\": op1(a => -a),\n\n  // ## Logic\n  // **cond**: Conditional execution\n  // `[true, \"@cond\", [<success pattern>], [<fail pattern>]]`\n  \"@cond\": ({ stack, operations }) => {\n    const test = stack.pop()\n    // this is the pattern to execute if the test passes\n    const success = operations.pop()\n    // the next pattern is the \"else\" part\n    if (test) {\n      // remove the \"else\" part\n      operations.pop()\n      operations.push(success)\n    }\n  },\n  \"@>\": op2((b, a) => a > b),\n  \"@>=\": op2((b, a) => a >= b),\n  \"@<\": op2((b, a) => a < b),\n  \"@<=\": op2((b, a) => a <= b),\n  \"@==\": op2((b, a) => a === b),\n  \"@!=\": op2((b, a) => a !== b),\n  \"@!\": op1(a => !a),\n  \"@not\": \"@!\",\n  \"@&&\": op2((b, a) => a && b),\n  \"@and\": \"@&&\",\n  \"@||\": op2((b, a) => a || b),\n  \"@or\": \"@||\",\n\n  // ## Processes\n\n  // Operation related to interact with the current process\n\n  // | Name | Description | Example |\n  // |------|-------------|---------|\n  // | **@** | Alias of @execute | `10,\"dup\",\"@\"` |\n  // | **@let** | Assign a value to the local context | `10,\"repetitions\",\"@let\"` |\n  // | **@set** | Assign a value to the global context | `10,\"parts\",\"@set\"` |\n  // | **@get** | Push the value of a variable into the stack | `\"repetitions\",\"@get\"` |\n  // | **@wait** | Wait an amount of time | `1,\"@wait\"` |\n  // | **@sync** | Wait until next beat | `\"@sync\"` |\n  // | **@scale-rate** | Change the current rate by a factor | `1.5, \"@scale-rate\"` |\n\n  \"@let\": ({ stack, context }) => context.let(stack.pop(), stack.pop()),\n  \"@set\": ({ stack, context }) => context.set(stack.pop(), stack.pop()),\n  \"@get\": ({ stack, context }) => stack.push(context.get(stack.pop())),\n\n  \"@wait\": proc => proc.wait(Math.abs(Number(proc.stack.pop()))),\n  \"@sync\": proc => proc.wait(Math.floor(proc.time) + 1 - proc.time),\n\n  \"@scale-rate\": proc => {\n    const factor = parseFloat(proc.stack.pop(), 10)\n    if (factor > 0) proc.rate *= factor\n  },\n  \"@with-rate\": ({ stack, operations, error }) => {\n    const factor = parseFloat(stack.pop(), 10)\n    const pattern = operations.pop()\n    if (!isArray(pattern)) error(\"@with-rate\", ERR_EXPECT_PATTERN, pattern)\n    operations.push([\n      factor,\n      \"@scale-rate\",\n      pattern,\n      1 / factor,\n      \"@scale-rate\"\n    ])\n  },\n\n  // ## Execute and repeat\n\n  // | Name | Description | Example |\n  // |------|-------------|---------|\n  // | **@dup** | Duplicate item (so you can use it twice) | `10,\"@dup\"` |\n  // | **@execute** | Execute an instruction | `10,\"dup\",\"@execute\"` |\n  // | **@repeat** | Repeat | `4, \"@repeat\", [\"@kick\", 0.5, \"@wait\"]` |\n  // | **@forever** | Repeat forever | `\"@forever\", [\"@kick\", 0.5, \"@wait\"]` |\n  \"@dup\": ({ stack }) => stack.push(last(stack)),\n  \"@execute\": ({ operations, error }) => {\n    const instr = operations.pop()\n    if (isString(instr)) operations.push(\"@instr\")\n    else error(\"@execute\", ERR_EXPECT_STRING, instr)\n  },\n  \"@\": \"@execute\",\n  \"@repeat\": ({ stack, operations, error }) => {\n    const repetitions = stack.pop()\n    const pattern = last(operations)\n    if (!isArray(pattern)) error(\"@repeat\", ERR_EXPECT_PATTERN, pattern)\n    else {\n      for (let i = 1; i < repetitions; i++) {\n        operations.push(pattern)\n      }\n    }\n  },\n  \"@forever\": ({ operations, error }) => {\n    const pattern = last(operations)\n    if (isArray(pattern) && pattern.length) {\n      operations.push(\"@forever\")\n      operations.push(pattern)\n    } else error(\"@forever\", ERR_EXPECT_PATTERN, pattern)\n  },\n\n  // ## Iteration and lists\n  // | Name | Description | Example |\n  // |------|-------------|---------|\n  // | **@iter** | Iterate a pattern | `[[\"@iter\", [0.3, 1]], \"amp\", \"@set\"]` |\n  // | **@rotate** | Rotate a pattern | `[]` |\n  \"@iter\": ({ operations, error }) => {\n    const pattern = operations.pop()\n    if (!isArray(pattern) || !pattern.length) {\n      error(\"@iter\", ERR_EXPECT_PATTERN, pattern)\n    } else {\n      // Rotates the pattern and plays the first item only each time\n      // remove \"1st\" item, schedule, then push to back:\n      const first = pattern.splice(0, 1)\n      operations.push(first)\n      pattern.push(first)\n    }\n  },\n  \"@rotate\": ({ stack, operations, error }) => {\n    const pattern = operations.pop()\n    let rot = stack.pop()\n    if (isArray(pattern) && pattern.length > 0) {\n      // ensure rot is valid between -args.length to +args.length\n      rot = rot % pattern.length\n      var copy = pattern.splice(0)\n      // rotate in-place\n      pattern.push.apply(pattern, copy.slice(rot))\n      pattern.push.apply(pattern, copy.slice(0, rot))\n      // schedule a shallow copy:\n      operations.push(copy)\n    } else {\n      error(\"@rotate\", ERR_EXPECT_PATTERN, pattern)\n    }\n  },\n\n  // ## Utilities\n\n  // midi to frequency\n  // [60, '@mtof']\n  \"@mtof\": ({ stack }) => {\n    const midi = stack.pop()\n    const freq = 440 * Math.pow(2, (+midi - 69) / 12)\n    stack.push(freq)\n  },\n\n  // scale a value\n  // [value, fromLow, fromHi, toLow, toHi, \"@linear\"]\n  \"@linear\": ({ stack }) => {\n    const ohi = stack.pop()\n    const olo = stack.pop()\n    const ihi = stack.pop()\n    const ilo = stack.pop()\n    const v = stack.pop()\n\n    if (ihi === ilo) {\n      stack.push(olo)\n    } else {\n      stack.push(olo + (ohi - olo) * ((v - ilo) / (ihi - ilo)))\n    }\n  }\n}\n\n// Given a commands object, expand the aliases\nexport function expandAliases (commands) {\n  Object.keys(commands).forEach(name => {\n    const op = commands[name]\n    if (isString(op)) commands[name] = commands[op]\n  })\n  return commands\n}\n","// # VM\n\nimport { isArray, isString, isFn } from \"./utils\"\nimport { Process } from \"./process\"\nimport stdlib, {\n  expandAliases,\n  ERR_EXPECT_STRING,\n  ERR_EXPECT_PATTERN\n} from \"./commands\"\n\nconst assign = Object.assign\n\n// The purpose of the VM is to run processes concurrently. It also\n// mantains an extensible object of commands (operations mapped to functions)\n// that allows to add operations to the vm\n\n// TODO: probably is better to have functions and object instead of classes\n// will change in the future.\nexport class VM {\n  constructor (initialContext, options = {}) {\n    this.context = initialContext\n    this.procs = [] // the procs are inverse ordered by time\n    this.procsByName = {} // a map of names to procs\n    this.time = 0\n    this.commands = createCommands(this)\n    this.addCommands(stdlib)\n    this.onfork = options.onfork\n    this.onstop = options.onstop\n    this.onended = options.onended\n  }\n\n  // Run a program\n  run (program, sync = true) {\n    // if there are no processes, no need to sync\n    if (sync && this.procs.length) program = [\"@sync\", program]\n    return this.fork(null, this.context, program)\n  }\n\n  // Add more commands\n  addCommands (commands) {\n    if (isFn(commands)) commands = commands(this)\n    if (commands) assign(this.commands, expandAliases(commands))\n  }\n\n  // Create a new process\n  fork (name, parent, program, delay = 0, rate) {\n    const time = this.time + delay\n    // if has parent and no rate, try to use it\"s rate\n    if (!rate && parent) rate = parent.rate\n    // if has parent try to use it\"s context\n    const context = parent ? parent.context || parent : undefined\n    // create the new process and insert into the process stack\n    const proc = new Process(program, context, time, rate)\n    insert(proc, this.procs)\n    // if has name, register it\n    if (name) this.procsByName[name] = proc\n    if (this.onfork) this.onfork({ proc, name, parent, program, delay, rate })\n    return proc\n  }\n\n  // run the vm for the given amount of time (Infinity if not specified)\n  resume (dur = Infinity, limit = 10000) {\n    const { procs } = this\n    if (procs.length > 0) {\n      const nextTime = this.time + dur\n      while (--limit > 0 && at(procs) < nextTime) {\n        const proc = procs.pop()\n        if (proc.resume(this.commands, nextTime)) {\n          // the proc has more operations, re-schedule\n          insert(proc, this.procs)\n        } else {\n          if (this.onended) this.onended({ proc, time: this.time })\n        }\n      }\n      this.time = nextTime\n    } else {\n      this.time += dur\n    }\n    return procs.length > 0\n  }\n\n  stopAll () {\n    this.procs.length = 0\n  }\n\n  // The stop function can stop a proccess by name or by object\n  stop (name) {\n    let proc\n    if (typeof proc === \"string\") {\n      proc = this.procsByName[name]\n      this.procsByName[name] = null\n    } else {\n      proc = name\n      name = null\n    }\n    if (this.onstop) this.onstop({ name, proc })\n\n    remove(proc, this.procs)\n  }\n}\n\n// ## VM commands\n\n// | Name | Description | Example |\n// |------|-------------|---------|\n// | **@fork** | Fork | `@fork, [0.5, \"@wait\", \"@kick\"]` |\n// | **@spawn** | Spawn | `\"melody\", \"@spawn\", [0.5, \"@wait\", \"@kick\"]` |\n// | **@stop** | Stop current process | `@stop` |\n// | **@stop-all** | Stop all processes | `@stop-all` |\nfunction createCommands (vm) {\n  return {\n    \"@loop\": proc => {\n      const { operations, error } = proc\n      const pattern = operations.pop()\n      if (isArray(pattern)) vm.fork(null, proc, [\"@forever\", pattern])\n      else error(\"@loop\", ERR_EXPECT_PATTERN, pattern)\n    },\n    \"@fork\": proc => {\n      const { operations, error } = proc\n      let pattern = operations.pop()\n\n      if (isArray(pattern)) {\n        vm.fork(null, proc, pattern)\n      } else {\n        error(\"@fork\", ERR_EXPECT_PATTERN, pattern)\n      }\n    },\n    \"@spawn\": proc => {\n      const { stack, operations, error } = proc\n      const name = stack.pop()\n      let pattern = operations.pop()\n      if (!isString(name)) {\n        error(\"@spawn\", ERR_EXPECT_STRING, name)\n      } else if (!isArray(pattern)) {\n        error(\"@spawn\", ERR_EXPECT_PATTERN, pattern)\n      } else {\n        vm.stop(name)\n        vm.fork(name, proc, [\"@forever\", pattern])\n      }\n    },\n    \"@stop-all\": proc => vm.stopAll(),\n    \"@stop\": ({ stack }) => vm.stop(stack.pop())\n  }\n}\n\n// ## Internal VM functions\n\n// remove a process process\nfunction remove (proc, procs) {\n  let i = procs.length - 1\n  while (i >= 0 && procs[i] !== proc) {\n    i--\n  }\n  // if found, remove it\n  if (i !== -1) procs.splice(i, 1)\n  return i !== -1\n}\n\n// insert a process into a stack ordered by time\n// (in fact, is inverse order because it\"s a stack)\nfunction insert (proc, procs) {\n  if (procs.length === 0) {\n    // no need to sort: just push it\n    procs.push(proc)\n  } else {\n    // procs are sorted on insertion\n    let i = procs.length - 1\n    let p = procs[i]\n    while (p && p.time <= proc.time) {\n      i--\n      p = procs[i]\n    }\n    procs.splice(i + 1, 0, proc)\n  }\n  return proc\n}\n\n// get time of the next process\nfunction at (procs) {\n  const len = procs.length\n  return len ? procs[len - 1].time : Infinity\n}\n","// # Gibberish audio audio\nimport { isDef } from \"../../utils\"\n\nconst ERR_INST_MISSING = name => `Instrument \"${name}\" not found.`\n\n// Create an object with instrument definitions.\n// The instruments are created lazy\nconst instruments = Gibberish => ({\n  kick: {\n    params: [\"amp\", \"pitch\", \"decay\", \"tone\"],\n    init: () => new Gibberish.Kick({ decay: 0.2 }).connect()\n  },\n  snare: {\n    params: [\"amp\", \"tune\", \"cutoff\", \"snappy\"],\n    init: () => new Gibberish.Snare({ snappy: 1.5 }).connect()\n  },\n  hat: {\n    params: [\"amp\", \"pitch\"],\n    init: () => new Gibberish.Hat({ amp: 1.5 }).connect()\n  },\n  conga: {\n    params: [\"amp\", \"pitch\"],\n    init: () => new Gibberish.Conga({ amp: 0.25, freq: 400 }).connect()\n  },\n  clave: {\n    params: [\"amp\", \"pitch\"],\n    init: () => new Gibberish.Clave({ amp: 1 }).connect()\n  },\n  tom: {\n    params: [\"amp\", \"pitch\"],\n    init: () => new Gibberish.Tom({ amp: 0.25, freq: 400 }).connect()\n  },\n  clap: {\n    params: [\"amp\"],\n    init: () => new Gibberish.Clap({ amp: 0.5 }).connect()\n  },\n  cowbell: {\n    params: [\"amp\", \"pitch\"],\n    init: () => new Gibberish.Cowbell({ amp: 0.5 }).connect()\n  },\n  pluck: {\n    params: [\"freq\", \"amp\", \"blend\", \"damping\", \"velocity\"],\n    init: () => new Gibberish.PolyKarplusStrong({ maxVoices: 32 }).connect(),\n    prepare: (inst, context) => {\n      const freq = context.get(\"freq\")\n      if (freq > 0) {\n        inst.freq = freq\n        inst.damping = 1 - (-6) / Math.log(freq / Gibberish.sampleRate)\n      }\n      const amp = context.get(\"amp\")\n      if (amp) inst.amp = amp * amp * 0.5\n      const blend = context.get(\"blend\")\n      if (blend) inst.blend = blend\n    }\n  },\n  bass: {\n    params: [\"freq\", \"amp\", \"resonance\"],\n    init: () => new Gibberish.MonoSynth({\n      attack: 44,\n      decay: Gibberish.Time.beats(0.25),\n      filterMult: 0.25,\n      octave2: 0,\n      octave3: 0\n    }).connect()\n  }\n})\n\n// ## Audio commands\n\n// | Name | Description | Example |\n// |------|-------------|---------|\n// | **@get-bpm** | Get the global tempo value | `\"@pick\", [1.25, 1.5, 0.75], \"@get-bpm\", \"@*\", \"@set-bpm\"` |\n// | **@set-bpm** | Change the global tempo | `120, \"@set-bpm\"` |\n// | **@play-note** | Trigger a note with params | `{ inst: \"pluck\", amp: 0.5}, \"@note-params\"` |\n// | **@play** | Trigger a note | `\"@note\"` |\nconst initCommands = audio => ({\n  \"@play\": ({ context, error }) => {\n    const err = play(context, audio)\n    if (err) error(\"@play\", err)\n  },\n  \"@play-note\": ({ stack, context, error }) => {\n    const props = stack.pop()\n    const err = play(context.child(props), audio)\n    if (err) error(\"@play-note\", err)\n  },\n  \"@set-bpm\": ({ stack }) => {\n    const bpm = parseFloat(stack.pop(), 10)\n    if (bpm > 0) audio.bpm = bpm\n  },\n  \"@scale-tempo\": ({ stack }) => {\n    const factor = parseFloat(stack.pop(), 10)\n    if (factor) audio.bpm *= factor\n  }\n})\n\nexport default function init (Gibberish, options = {}) {\n  const audio = initAudioDriver(Gibberish, options)\n  audio.instruments = initInstruments(instruments(Gibberish))\n  audio.commands = initCommands(audio)\n  Gibberish.sequencers.push(sequencer(audio))\n\n  return function (vm) {\n    // Add the vm to the list of VMs\n    audio.vms.push(vm)\n    // Set the audio property to the audio driver\n    vm.audio = audio\n    return audio.commands\n  }\n}\n\n// Prepare the instruments object. Replace the params with prepare\nfunction initInstruments (instruments) {\n  Object.keys(instruments).forEach(name => {\n    const inst = instruments[name]\n    if (!inst.prepare) {\n      const params = inst.params || []\n      inst.prepare = (inst, context) => {\n        params.forEach(param => {\n          let value = context.get(param)\n          if (isDef(value)) {\n            inst[param] = value\n          }\n        })\n      }\n    }\n  })\n  return instruments\n}\n\nfunction sequencer (audio) {\n  const { vms, bpm2bpa } = audio\n  return {\n    tick () {\n      const len = audio.vms.length\n      const dur = audio.bpm * bpm2bpa\n      if (len === 1) {\n        vms[0].resume(dur)\n      } else if (len > 1) {\n        for (let i = 0; i < len; i++) {\n          vms[i].resume(dur)\n        }\n      }\n    }\n  }\n}\n\n// Trigger an instrument\nconst play = (context, audio) => {\n  const { instruments } = audio\n  const instName = context.get(\"inst\")\n  const instrument = instruments[instName]\n  if (!instrument) return ERR_INST_MISSING(instName)\n  if (!instrument.instance) instrument.instance = instrument.init()\n\n  const inst = instrument.instance\n  instrument.prepare(inst, context)\n  inst.freq ? inst.note(inst.freq) : inst.note()\n}\n\n// Init the audio driver\nfunction initAudioDriver (Gibberish, { bpm = 100 }) {\n  if (!Gibberish.context) Gibberish.init()\n  return {\n    Gibberish,\n    bpm: bpm,\n    sampleRate: Gibberish.context.sampleRate,\n    bpm2bpa: 1 / (60 * Gibberish.context.sampleRate),\n    vms: []\n  }\n}\n","/* global AudioContext */\nconst timeToBeats = (time, bpm) => time * bpm / 60\nconst beatsToTime = (beats, bpm) => beats * 60 / bpm\n\nconst ERR_INSTRUMENT_NOT_FOUND = \"Instrument not found: \"\n\nexport default function waa (options = {}) {\n  const ac = options.context || new AudioContext()\n  const driver = {\n    paused: false,\n    bpm: options.bpm || 120,\n    instruments: {\n      pluck: (time, ctx) => synth(ac, time, ctx.get(\"freq\"), ctx.get(\"amp\"), 0.5),\n      hat: (time, ctx) => synth(ac, time, 4000, 0.2, 0.1),\n      kick: (time, ctx) => synth(ac, time, 100, 1, 0.2),\n      snare: (time, ctx) => synth(ac, time, 476, 0.6, 0.2),\n      tom: (time, ctx) => synth(ac, time, 200, 0.4, 0.4),\n    }\n  }\n\n  driver.stop = () => clearInterval(driver.seq)\n\n  const step = 0.1\n  const dur = timeToBeats(step, driver.bpm)\n  return function (vm) {\n    const zero = ac.currentTime\n    clock(ac, time => {\n      vm.resume(dur)\n    }, step)\n    vm.audio = driver\n    return {\n      \"@play\": ({ time, context, error }) => {\n        const when = beatsToTime(time, driver.bpm) + zero\n        const inst = context.get(\"inst\")\n        const trigger = driver.instruments[inst]\n        if (!trigger) error(\"@play\", ERR_INSTRUMENT_NOT_FOUND, inst)\n        else trigger(when, context)\n      }\n    }\n  }\n}\n\nfunction clock (ac, callback, time) {\n  const lookAhead = time || 0.1\n  const updateInterval = lookAhead / 3\n  let next = ac.currentTime + lookAhead\n  const tick = () => {\n    if (ac.currentTime + lookAhead >= next) {\n      callback(next)\n      next += lookAhead\n    }\n  }\n  tick()\n  return setInterval(tick, updateInterval)\n}\n\n// A minimalistic synth (mostly for testing)\nfunction synth (ac, time, freq, amp, decay) {\n  const osc = ac.createOscillator()\n  osc.frequency.value = freq || 200\n  osc.amp = ac.createGain()\n  osc.amp.gain.value = 0\n  osc.connect(osc.amp)\n  osc.amp.connect(ac.destination)\n  osc.start(time)\n  osc.amp.gain.setValueAtTime(0, time)\n  osc.amp.gain.linearRampToValueAtTime(amp * 0.5, time + 0.01)\n  osc.amp.gain.linearRampToValueAtTime(0, time + decay)\n  osc.stop(time + decay + 0.1)\n  return osc\n}\n","// ## Randomness\nimport { isArray } from \"../utils\"\nimport { ERR_EXPECT_PATTERN } from \"../commands\"\nconst { floor } = Math\n\n// | Name | Description | Example |\n// |------|-------------|---------|\n// | **@random** | Generate a random number between 0 and 1 | `[\"@random\", \"amp\", \"@set\"]` |\n// | **@rand** | Alias for @random | |\n// | **@srandom** | Generate a random number between -1 and 1 | `[\"@srandom\", \"phase\", \"@set\"]` |\n// | **@srand** | Alias for @srandom | |\n// | **@randi** | Generate a random integer between 0 and n | `[60, \"@randi\", \"midi\", \"@set\"]` |\n// | **@pick** | Pick a random element from a list | `[\"@pick\", [1, 2, 3, 4]]` |\n// | **@shuffle** | Shuffle a list | `\"@shuffle\", [1, 2, 3]` |\n// | **@chance** | Probabilistic execution | `probability, \"@chance\", executed-if-true, executed-if-false` |\nexport default function random ({ random } = {}) {\n  // allow to use a custom random function\n  const rnd = random || Math.random\n  // a function that generates integer random from 0 to n\n  const irnd = n => floor(rnd() * n)\n\n  const shuffle = a => {\n    var j, x, i\n    for (i = a.length; i; i--) {\n      j = floor(random() * i)\n      x = a[i - 1]\n      a[i - 1] = a[j]\n      a[j] = x\n    }\n  }\n\n  return {\n    \"@random\": ({ stack }) => stack.push(rnd()),\n    \"@rand\": \"@random\",\n    \"@srandom\": ({ stack }) => stack.push(rnd() * 2 - 1),\n    \"@srand\": \"@srandom\",\n    \"@randi\": ({ stack }) => stack.push(irnd(stack.pop())),\n    \"@pick\": proc => {\n      const { operations, error } = proc\n      const pattern = operations.pop()\n      if (!isArray(pattern)) {\n        operations.push(pattern)\n        error(\"Can't pick an element if is not an array\", pattern)\n      } else {\n        const i = irnd(pattern.length)\n        operations.push(pattern[i])\n      }\n    },\n    \"@chance\": ({ stack, operations }) => {\n      const prob = stack.pop()\n      const pattern = operations.pop()\n      if (rnd() < prob) {\n        // Skip item after\n        operations.pop()\n        // Push the pattern\n        operations.push(pattern)\n      }\n    },\n    \"@shuffle\": ({ stack, operations, error }) => {\n      const pattern = operations.pop()\n      if (!isArray(pattern)) error(\"@shuffle\", ERR_EXPECT_PATTERN, pattern)\n      else operations.push(shuffle(pattern))\n    }\n  }\n}\n","// # Debug operations\nimport { peek } from \"../utils\"\n\n// | Name | Description | Example |\n// |------|-------------|---------|\n// | **@print** | Print the last value of the stack | `10,\"@print\"` |\n// | **@log** | Log the name with the last value of the stack | `\"@random\", \"amp\", \"@log\"` |\nexport default function debug ({ log } = {}) {\n  log = log || console.log.bind(console)\n\n  return {\n    \"@print\": proc => {\n      const { stack } = proc\n      const last = stack.length ? peek(stack) : \"<Empty Stack>\"\n      log(\"@print\", last, \"(id, time)\", proc.id, proc.time)\n    },\n    \"@log\": proc => {\n      const { stack } = proc\n      const name = stack.pop()\n      const last = stack.length ? peek(stack) : \"<Empty Stack>\"\n      log(\"@log\", name, last, \"(id, time)\", proc.id, proc.time)\n    },\n    \"@debug\": proc => {\n      const { stack } = proc\n      log(\"@debug\", stack, proc.id, proc.time)\n    }\n  }\n}\n","// # Compatibility plugin\n\nimport { isArray } from \"../utils\"\nimport { ERR_EXPECT_PATTERN } from \"../commands\"\n\n// This plugin adds language compatibility to the previous version\n\n// Given an instrument name, returns a command that play that instrument\nconst inst = name => ({ operations }) => {\n  operations.push([name, \"inst\", \"@let\", \"@play\"])\n}\nconst instNote = (name, p1, p2) => ({ stack, operations }) => {\n  operations.push(p2\n    ? [stack.pop(), p2, \"@let\", stack.pop(), p1, \"@let\",\n      name, \"inst\", \"@let\", \"@play\"]\n    : [stack.pop(), p1, \"@let\",\n      name, \"inst\", \"@let\", \"@play\"])\n}\n\nexport default function init () {\n  return {\n    // get and set for freq and amp\n    \"@set-freq\": ({ context, stack }) => context.set(\"freq\", stack.pop()),\n    \"@set-amp\": ({ context, stack }) => context.set(\"amp\", stack.pop()),\n    \"@get-freq\": ({ stack, context }) => stack.push(context.get(\"freq\")),\n    \"@get-amp\": ({ stack, context }) => stack.push(context.get(\"amp\")),\n\n    // I think reverse is not very useful in this context\n    // because: [\"@iter\", [\"@reverse\", [1, 2, 3]]] doesn\"t work, for example\n    \"@reverse\": ({ operations, error }) => {\n      const pattern = operations.pop()\n      if (!isArray(pattern)) error(\"@reverse\", ERR_EXPECT_PATTERN, pattern)\n      else operations.push(pattern.slice().reverse())\n    },\n    // I think @map is not a good name\n    \"@map\": \"@linear\",\n\n    // Instrument names\n    \"@pluck\": inst(\"pluck\"),\n    \"@pluck-note\": instNote(\"pluck\", \"freq\", \"amp\"),\n    \"@bass\": inst(\"bass\"),\n    \"@bass-note\": instNote(\"bass\", \"freq\", \"amp\"),\n    \"@hat\": inst(\"hat\"),\n    \"@hat-note\": instNote(\"hat\", \"amp\"),\n    \"@kick\": inst(\"kick\"),\n    \"@kick-note\": instNote(\"kick\", \"amp\"),\n    \"@snare\": inst(\"snare\"),\n    \"@snare-note\": instNote(\"snare\", \"amp\"),\n    \"@conga\": inst(\"conga\"),\n    \"@conga-note\": instNote(\"conga\", \"amp\"),\n    \"@clave\": inst(\"clave\"),\n    \"@clave-note\": instNote(\"clave\", \"amp\"),\n    \"@tom\": inst(\"tom\"),\n    \"@tom-note\": instNote(\"tom\", \"amp\"),\n  }\n}\n","// # Audio Scheduler Virtual Machine\nimport { VM } from './vm'\nimport gibberish from './audio/gibberish'\nimport waa from './audio/waa'\nimport random from './ext/random'\nimport debug from './ext/debug'\nimport compatibility from './ext/compatibility'\n\n// ## Architecture Overview\n\n// The main purpose of the virtual machine is to run processes concurrently.\n// It holds a `commands` object (that maps instruction names to functions)\n// and schedules a collection of `processes`. Each **process** has an values `stack`\n// and `operations` stack (to be executed).\n\n// ## API\nexport function initGibberish (Gibberish, options = {}) {\n  return init(gibberish(Gibberish, options), options)\n}\n\nexport function initWebAudio (Tone, options = {}) {\n  return init(waa(Tone, options), options)\n}\n\n// the init function creates a vm controlled by Gibberish\nexport function init (driver, options = {}) {\n  const { plugins } = options\n  // Create the virtual machine\n  const vm = new VM({ amp: 0.5, freq: 440 }, options)\n  // Use the audio driver\n  vm.addCommands(driver)\n  // Include all the command extensions\n  vm.addCommands(random(options))\n  vm.addCommands(debug(options))\n  vm.addCommands(compatibility(options))\n  // Add the plugins if any\n  if (plugins) plugins.forEach(cmds => vm.addCommands(cmds))\n\n  return vm\n}\n","// # TimeVM utilities\n\n// copy values from one or more sources to a target\n// see: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\nexport const assign = Object.assign\n\n// test if an object is an array\nexport const isArray = Array.isArray\n\n// test if  is a string\nexport const isString = x => typeof x === 'string'\n\n// test if  is a function\nexport const isFn = x => typeof x === 'function'\n\n// test if  is defined\nexport const isDef = x => typeof x !== 'undefined'\n\n// get last element from an array\nexport const last = a => a[a.length - 1]\n// take the next element of stack without remove it\nexport const peek = last\n\n// A modulo operation that handles negative n more appropriately\n// e.g. wrap(-1, 3) returns 2\n// see http://en.wikipedia.org/wiki/Modulo_operation\n// see also http://jsperf.com/modulo-for-negative-numbers\nexport const wrap = (a, b) => (a % b + b) % b\n"],"names":["defer","fn","data","expandAliases","commands","keys","forEach","op","name","isString","createCommands","vm","operations","proc","error","pattern","pop","isArray","fork","ERR_EXPECT_PATTERN","stack","stop","ERR_EXPECT_STRING","stopAll","remove","procs","i","length","splice","insert","push","p","time","at","len","Infinity","init","Gibberish","options","audio","initAudioDriver","instruments","initInstruments","initCommands","sequencers","sequencer","vms","inst","prepare","params","context","value","get","param","isDef","bpm2bpa","dur","bpm","resume","sampleRate","waa","ac","AudioContext","driver","ctx","synth","clearInterval","seq","timeToBeats","zero","currentTime","when","beatsToTime","trigger","ERR_INSTRUMENT_NOT_FOUND","clock","callback","lookAhead","updateInterval","next","tick","setInterval","freq","amp","decay","osc","createOscillator","frequency","createGain","gain","connect","destination","start","setValueAtTime","linearRampToValueAtTime","random","rnd","Math","irnd","floor","n","shuffle","j","x","a","prob","debug","log","console","bind","peek","id","set","slice","reverse","instNote","initGibberish","gibberish","initWebAudio","Tone","plugins","VM","addCommands","compatibility","cmds","Array","isFn","last","wrap","b","isCommand","o","isProgram","procId","Process","program","rate","Context","this","instr","undefined","cmd","limit","step","Error","msg","obj","parent","local","Object","assign","c","target","let","op1","op2","test","success","wait","abs","Number","factor","parseFloat","repetitions","first","rot","copy","apply","midi","pow","ohi","olo","ihi","ilo","v","initialContext","procsByName","stdlib","onfork","onstop","onended","delay","nextTime","ERR_INST_MISSING","Kick","Snare","snappy","Hat","Conga","Clave","Tom","Clap","Cowbell","PolyKarplusStrong","maxVoices","damping","blend","MonoSynth","Time","beats","err","play","props","child","instName","instrument","instance","note","p1","p2"],"mappings":"gMAGA,SAASA,GAAOC,EAAIC,cACP,aAAWA,IAAS,GC4MjC,QAAgBC,GAAeC,iBACtBC,KAAKD,GAAUE,QAAQ,eACtBC,GAAKH,EAASI,EAChBC,GAASF,KAAKH,EAASI,GAAQJ,EAASG,MAEvCH,ECxGT,QAASM,GAAgBC,kBAEZ,eACCC,GAAsBC,EAAtBD,WAAYE,EAAUD,EAAVC,MACdC,EAAUH,EAAWI,KACvBC,GAAQF,GAAUJ,EAAGO,KAAK,KAAML,GAAO,WAAYE,IAClDD,EAAM,QAASK,EAAoBJ,YAEjC,eACCH,GAAsBC,EAAtBD,WAAYE,EAAUD,EAAVC,MAChBC,EAAUH,EAAWI,KAErBC,GAAQF,KACPG,KAAK,KAAML,EAAME,KAEd,QAASI,EAAoBJ,aAG7B,eACAK,GAA6BP,EAA7BO,MAAOR,EAAsBC,EAAtBD,WAAYE,EAAUD,EAAVC,MACrBN,EAAOY,EAAMJ,MACfD,EAAUH,EAAWI,KACpBP,GAASD,GAEFS,EAAQF,MAGfM,KAAKb,KACLU,KAAKV,EAAMK,GAAO,WAAYE,OAH3B,SAAUI,EAAoBJ,KAF9B,SAAUO,EAAmBd,gBAQ1B,kBAAQG,GAAGY,mBACf,eAAGH,KAAAA,YAAYT,GAAGU,KAAKD,EAAMJ,SAO1C,QAASQ,GAAQX,EAAMY,UACjBC,GAAID,EAAME,OAAS,EAChBD,GAAK,GAAKD,EAAMC,KAAOb,aAI1Ba,MAAO,GAAGD,EAAMG,OAAOF,EAAG,GACvBA,KAAO,EAKhB,QAASG,GAAQhB,EAAMY,MACA,IAAjBA,EAAME,SAEFG,KAAKjB,OACN,QAEDa,GAAID,EAAME,OAAS,EACnBI,EAAIN,EAAMC,GACPK,GAAKA,EAAEC,MAAQnB,EAAKmB,YAErBP,EAAMC,KAENE,OAAOF,EAAI,EAAG,EAAGb,SAElBA,GAIT,QAASoB,GAAIR,MACLS,GAAMT,EAAME,aACXO,GAAMT,EAAMS,EAAM,GAAGF,KAAOG,EAAAA,ECrFrC,QAAwBC,GAAMC,MAAWC,6DACjCC,EAAQC,EAAgBH,EAAWC,YACnCG,YAAcC,EAAgBD,EAAYJ,MAC1CjC,SAAWuC,EAAaJ,KACpBK,WAAWd,KAAKe,EAAUN,IAE7B,SAAU5B,YAETmC,IAAIhB,KAAKnB,KAEZ4B,MAAQA,EACJA,EAAMnC,UAKjB,QAASsC,GAAiBD,iBACjBpC,KAAKoC,GAAanC,QAAQ,eACzByC,GAAON,EAAYjC,OACpBuC,EAAKC,QAAS,IACXC,GAASF,EAAKE,aACfD,QAAU,SAACD,EAAMG,KACb5C,QAAQ,eACT6C,GAAQD,EAAQE,IAAIC,EACpBC,GAAMH,OACHE,GAASF,SAMjBV,EAGT,QAASI,GAAWN,MACVO,GAAiBP,EAAjBO,IAAKS,EAAYhB,EAAZgB,kCAGHrB,GAAMK,EAAMO,IAAInB,OAChB6B,EAAMjB,EAAMkB,IAAMF,KACZ,IAARrB,IACE,GAAGwB,OAAOF,OACT,IAAItB,EAAM,MACV,GAAIR,GAAI,EAAGA,EAAIQ,EAAKR,MACnBA,GAAGgC,OAAOF,KAqBxB,QAAShB,GAAiBH,aAAaoB,IAAAA,aAAM,YACtCpB,GAAUa,SAASb,EAAUD,wBAG3BqB,aACOpB,EAAUa,QAAQS,mBACrB,GAAK,GAAKtB,EAAUa,QAAQS,oBChKzC,QAAwBC,QAAKtB,6DACrBuB,EAAKvB,EAAQY,SAAW,GAAIY,cAC5BC,WACI,MACHzB,EAAQmB,KAAO,uBAEX,SAACzB,EAAMgC,SAAQC,GAAMJ,EAAI7B,EAAMgC,EAAIZ,IAAI,QAASY,EAAIZ,IAAI,OAAQ,SAClE,SAACpB,EAAMgC,SAAQC,GAAMJ,EAAI7B,EAAM,IAAM,GAAK,UACzC,SAACA,EAAMgC,SAAQC,GAAMJ,EAAI7B,EAAM,IAAK,EAAG,WACtC,SAACA,EAAMgC,SAAQC,GAAMJ,EAAI7B,EAAM,IAAK,GAAK,SAC3C,SAACA,EAAMgC,SAAQC,GAAMJ,EAAI7B,EAAM,IAAK,GAAK,SAI3CX,KAAO,iBAAM6C,eAAcH,EAAOI,SAGnCX,GAAMY,EADC,GACiBL,EAAON,WAC9B,UAAU9C,MACT0D,GAAOR,EAAGS,qBACVT,EAAI,cACLH,OAAOF,IALD,MAORjB,MAAQwB,WAEA,eAAG/B,KAAAA,KAAMkB,IAAAA,QAASpC,IAAAA,MACnByD,EAAOC,EAAYxC,EAAM+B,EAAON,KAAOY,EACvCtB,EAAOG,EAAQE,IAAI,QACnBqB,EAAUV,EAAOtB,YAAYM,EAC9B0B,GACAA,EAAQF,EAAMrB,GADLpC,EAAM,QAAS4D,EAA0B3B,MAO/D,QAAS4B,GAAOd,EAAIe,EAAU5C,MACtB6C,GAAY7C,GAAQ,GACpB8C,EAAiBD,EAAY,EAC/BE,EAAOlB,EAAGS,YAAcO,EACtBG,EAAO,WACPnB,EAAGS,YAAcO,GAAaE,MACvBA,MACDF,eAILI,YAAYD,EAAMF,GAI3B,QAASb,GAAOJ,EAAI7B,EAAMkD,EAAMC,EAAKC,MAC7BC,GAAMxB,EAAGyB,4BACXC,UAAUpC,MAAQ+B,GAAQ,MAC1BC,IAAMtB,EAAG2B,eACTL,IAAIM,KAAKtC,MAAQ,IACjBuC,QAAQL,EAAIF,OACZA,IAAIO,QAAQ7B,EAAG8B,eACfC,MAAM5D,KACNmD,IAAIM,KAAKI,eAAe,EAAG7D,KAC3BmD,IAAIM,KAAKK,wBAA8B,GAANX,EAAWnD,EAAO,OACnDmD,IAAIM,KAAKK,wBAAwB,EAAG9D,EAAOoD,KAC3C/D,KAAKW,EAAOoD,EAAQ,IACjBC,ECtDT,QAAwBU,qEAAUA,IAAAA,OAE1BC,EAAMD,GAAUE,KAAKF,OAErBG,EAAO,kBAAKC,GAAMH,IAAQI,IAE1BC,EAAU,eACVC,GAAGC,EAAG7E,MACLA,EAAI8E,EAAE7E,OAAQD,EAAGA,MAChByE,EAAMJ,IAAWrE,KACjB8E,EAAE9E,EAAI,KACRA,EAAI,GAAK8E,EAAEF,KACXA,GAAKC,oBAKE,qBAAGnF,MAAkBU,KAAKkE,cAC5B,qBACG,qBAAG5E,MAAkBU,KAAa,EAARkE,IAAY,aACxC,oBACA,eAAG5E,KAAAA,YAAYA,GAAMU,KAAKoE,EAAK9E,EAAMJ,iBACtC,eACCJ,GAAsBC,EAAtBD,WAAYE,EAAUD,EAAVC,MACdC,EAAUH,EAAWI,SACtBC,EAAQF,GAGN,IACCW,GAAIwE,EAAKnF,EAAQY,UACZG,KAAKf,EAAQW,WAJbI,KAAKf,KACV,2CAA4CA,cAM3C,eAAGK,KAAAA,MAAOR,IAAAA,WACb6F,EAAOrF,EAAMJ,MACbD,EAAUH,EAAWI,KACvBgF,KAAQS,MAECzF,QAEAc,KAAKf,gBAGR,eAAUH,MAAPQ,QAAOR,YAAYE,IAAAA,MAC1BC,EAAUH,EAAWI,KACtBC,GAAQF,GACRH,EAAWkB,KAAKuE,EAAQtF,IADND,EAAM,WAAYK,EAAoBJ,KCrDpD,QAAS2F,qEAASC,IAAAA,aACzBA,GAAOC,QAAQD,IAAIE,KAAKD,mBAGlB,eACAxF,GAAUP,EAAVO,QAEJ,SADSA,EAAMO,OAASmF,EAAK1F,GAAS,gBACtB,aAAcP,EAAKkG,GAAIlG,EAAKmB,cAE1C,eACEZ,GAAUP,EAAVO,QAGJ,OAFSA,EAAMJ,MACNI,EAAMO,OAASmF,EAAK1F,GAAS,gBAClB,aAAcP,EAAKkG,GAAIlG,EAAKmB,gBAE5C,cAEJ,SADcnB,EAAVO,MACaP,EAAKkG,GAAIlG,EAAKmB,QCLzC,QAAwBI,wBAGP,eAAGc,KAAAA,QAAS9B,IAAAA,YAAY8B,GAAQ8D,IAAI,OAAQ5F,EAAMJ,mBACnD,eAAGkC,KAAAA,QAAS9B,IAAAA,YAAY8B,GAAQ8D,IAAI,MAAO5F,EAAMJ,oBAChD,eAAGI,KAAAA,MAAO8B,IAAAA,cAAc9B,GAAMU,KAAKoB,EAAQE,IAAI,qBAChD,eAAGhC,KAAAA,MAAO8B,IAAAA,cAAc9B,GAAMU,KAAKoB,EAAQE,IAAI,oBAI/C,eAAGxC,KAAAA,WAAYE,IAAAA,MACnBC,EAAUH,EAAWI,KACtBC,GAAQF,GACRH,EAAWkB,KAAKf,EAAQkG,QAAQC,WADdpG,EAAM,WAAYK,EAAoBJ,WAIvD,mBAGEgC,EAAK,uBACAoE,EAAS,QAAS,OAAQ,eAChCpE,EAAK,qBACAoE,EAAS,OAAQ,OAAQ,cAC/BpE,EAAK,mBACAoE,EAAS,MAAO,eACpBpE,EAAK,qBACAoE,EAAS,OAAQ,gBACrBpE,EAAK,uBACAoE,EAAS,QAAS,gBACvBpE,EAAK,uBACAoE,EAAS,QAAS,gBACvBpE,EAAK,uBACAoE,EAAS,QAAS,cACzBpE,EAAK,mBACAoE,EAAS,MAAO,QCpDjC,QAegBC,GAAe/E,MAAWC,mEACjCF,GAAKiF,EAAUhF,EAAWC,GAAUA,GAG7C,QAAgBgF,GAAcC,MAAMjF,mEAC3BF,GAAKwB,EAAI2D,EAAMjF,GAAUA,GAIlC,QAAgBF,GAAM2B,MAAQzB,6DACpBkF,EAAYlF,EAAZkF,QAEF7G,EAAK,GAAI8G,IAAKtC,IAAK,GAAKD,KAAM,KAAO5C,YAExCoF,YAAY3D,KAEZ2D,YAAY3B,EAAOzD,MACnBoF,YAAYhB,EAAMpE,MAClBoF,YAAYC,EAAcrF,IAEzBkF,GAASA,EAAQlH,QAAQ,kBAAQK,GAAG+G,YAAYE,KAE7CjH,EC/BT,GAAaM,GAAU4G,MAAM5G,QAGhBR,EAAW,kBAAkB,gBAAN8F,IAGvBuB,EAAO,kBAAkB,kBAANvB,IAGnBjD,EAAQ,kBAAkB,UAANiD,GAGpBwB,EAAO,kBAAKvB,GAAEA,EAAE7E,OAAS,IAEzBmF,EAAOiB,EAMPC,EAAO,SAACxB,EAAGyB,UAAOzB,EAAIyB,EAAIA,GAAKA,uVTpBtCC,EAAY,kBAAkB,gBAANC,IAA2B,MAATA,EAAE,IAC5CC,EAAYP,MAAM5G,QACpBoH,EAAS,EAMAC,wBACEC,EAASrF,EAASlB,EAAMwG,kBAC9BzB,GAAK,QAAUsB,SAEfjH,cAEAR,WAAa2H,GAAWA,WAExBrF,QAAU,GAAIuF,GAAQvF,QAEtBlB,KAAuB,gBAATA,GAAoBA,EAAO,OAEzCwG,KAAuB,gBAATA,GAAoBA,EAAO,OAEzC1H,MAAQ4H,KAAK5H,MAAM+F,KAAK6B,6CAIzB1G,QACCA,MAAQ0G,KAAKF,KAAOxG,+BAIrB5B,MACIQ,GAAe8H,KAAf9H,cACJA,EAAWe,OAAQ,IACfgH,GAAQ/H,EAAWI,SACX,OAAV2H,GAA4BC,SAAVD,OAEf,IAAqB,kBAAVA,KAEVA,EAAOD,KAAK1G,UACb,IAAIoG,EAAUO,OAGd,GAAIjH,GAAIiH,EAAMhH,OAAS,EAAGD,GAAK,EAAGA,MAC1BI,KAAK6G,EAAMjH,QAEnB,IAAIwG,EAAUS,GAAQ,IACrBE,GAAMzI,EAASuI,EACF,mBAARE,GAAoBA,EAAIH,MAC9BA,KAAK5H,MAAM,UA9CI,8BA8C4B6H,aAG3CvH,MAAMU,KAAK6G,mCAMdvI,UAAU4B,0DAAOG,EAAAA,EAAU2G,yDAAQ,IACjClI,EAAe8H,KAAf9H,aACCkI,EAAQ,GAAKJ,KAAK1G,KAAOA,GAAQpB,EAAWe,aAC9CoH,KAAK3I,MAEE,IAAV0I,EAAa,KAAME,OA3DD,mDA4DfpI,GAAWe,OAAS,gCAItBgH,EAAOM,EAAKC,WACTpI,MAAM6H,EAAOM,EAAKC,EAAK,KAAMR,KAAK3B,GAAI,OAAQ2B,KAAK1G,eAOlDyG,wBACEU,aACPA,YAAkBV,GAASC,KAAKS,OAASA,EACpCA,IAAQT,KAAKU,MAAQC,OAAOC,UAAWH,4CAI3CC,MACCG,GAAI,GAAId,GAAQC,eACpBU,MAAQC,OAAOC,UAAWF,GACrBG,8BAGJxC,UACCyC,GAASd,KACeE,SAArBY,EAAOrG,MAAM4D,IAAqByC,EAAOL,UACrCK,EAAOL,aAEXK,GAAOrG,MAAM4D,+BAIjBA,EAAI5D,UACHqG,GAASd,KACeE,SAArBY,EAAOrG,MAAM4D,IAAqByC,EAAOL,UACrCK,EAAOL,SAEXM,IAAI1C,EAAI5D,iCAGV4D,SACE2B,MAAKU,MAAQV,KAAKU,MAAMrC,GAAM6B,mCAIlC7B,EAAI5D,GACFuF,KAAKU,QAAOV,KAAKU,eACjBA,MAAMrC,GAAM5D,WCpHRhC,EAAqB,iCACrBG,EAAoB,gCAK3BoI,EAAM,kBAAM,gBAAGtI,KAAAA,QACbU,KAAK7B,EAAGmB,EAAMJ,UAIhB2I,EAAM,kBAAM,gBAAGvI,KAAAA,QACbU,KAAK7B,EAAGmB,EAAMJ,MAAOI,EAAMJ,kBAgB3B2I,EAAI,SAAC1B,EAAGzB,SAAMA,GAAIyB,WAEhB,UAEF0B,EAAI,SAAC1B,EAAGzB,SAAMA,GAAIyB,WAEhB,UACF0B,EAAI,SAAC1B,EAAGzB,SAAMA,GAAIyB,WAChB,UACF0B,EAAI,SAAC1B,EAAGzB,SAAY,KAANyB,EAAU,EAAIzB,EAAIyB,WAC9B,UACF0B,EAAI,SAAC1B,EAAGzB,SAAY,KAANyB,EAAU,EAAID,EAAKxB,EAAGyB,aACjC,YACD0B,EAAI,SAAC1B,EAAGzB,SAAY,KAANyB,EAAU,EAAIzB,EAAIyB,WAChCyB,EAAI,mBAAMlD,YAKT,eAAGpF,KAAAA,MAAOR,IAAAA,WACXgJ,EAAOxI,EAAMJ,MAEb6I,EAAUjJ,EAAWI,KAEvB4I,OAES5I,QACAc,KAAK+H,UAGdF,EAAI,SAAC1B,EAAGzB,SAAMA,GAAIyB,UACjB0B,EAAI,SAAC1B,EAAGzB,SAAMA,IAAKyB,SACpB0B,EAAI,SAAC1B,EAAGzB,SAAMA,GAAIyB,UACjB0B,EAAI,SAAC1B,EAAGzB,SAAMA,IAAKyB,UACnB0B,EAAI,SAAC1B,EAAGzB,SAAMA,KAAMyB,UACpB0B,EAAI,SAAC1B,EAAGzB,SAAMA,KAAMyB,SACrByB,EAAI,mBAAMlD,WACR,WACDmD,EAAI,SAAC1B,EAAGzB,SAAMA,IAAKyB,WAClB,YACD0B,EAAI,SAAC1B,EAAGzB,SAAMA,IAAKyB,UACnB,aAgBC,eAAG7G,KAAAA,eAAO8B,QAAsBuG,IAAIrI,EAAMJ,MAAOI,EAAMJ,eACvD,eAAGI,KAAAA,eAAO8B,QAAsB8D,IAAI5F,EAAMJ,MAAOI,EAAMJ,eACvD,eAAGI,KAAAA,MAAO8B,IAAAA,cAAc9B,GAAMU,KAAKoB,EAAQE,IAAIhC,EAAMJ,iBAEpD,kBAAQH,GAAKiJ,KAAK7D,KAAK8D,IAAIC,OAAOnJ,EAAKO,MAAMJ,kBAC7C,kBAAQH,GAAKiJ,KAAK7D,KAAKE,MAAMtF,EAAKmB,MAAQ,EAAInB,EAAKmB,qBAE7C,eACPiI,GAASC,WAAWrJ,EAAKO,MAAMJ,MAAO,GACxCiJ,GAAS,IAAGpJ,EAAK2H,MAAQyB,iBAEjB,eAAG7I,KAAAA,MAAOR,IAAAA,WAAYE,IAAAA,MAC5BmJ,EAASC,WAAW9I,EAAMJ,MAAO,IACjCD,EAAUH,EAAWI,KACtBC,GAAQF,IAAUD,EAAM,aAAcK,EAAoBJ,KACpDe,MACTmI,EACA,cACAlJ,EACA,EAAIkJ,EACJ,wBAYI,eAAG7I,KAAAA,YAAYA,GAAMU,KAAKiG,EAAK3G,gBAC3B,eAAGR,KAAAA,WAAYE,IAAAA,MACnB6H,EAAQ/H,EAAWI,KACrBP,GAASkI,GAAQ/H,EAAWkB,KAAK,UAChChB,EAAM,WAAYQ,EAAmBqH,QAEvC,qBACM,eAAGvH,KAAAA,MAAOR,IAAAA,WAAYE,IAAAA,MACzBqJ,EAAc/I,EAAMJ,MACpBD,EAAUgH,EAAKnH,MAChBK,EAAQF,OAEN,GAAIW,GAAI,EAAGA,EAAIyI,EAAazI,MACpBI,KAAKf,OAHGD,GAAM,UAAWK,EAAoBJ,eAOlD,eAAGH,KAAAA,WAAYE,IAAAA,MACnBC,EAAUgH,EAAKnH,EACjBK,GAAQF,IAAYA,EAAQY,UACnBG,KAAK,cACLA,KAAKf,IACXD,EAAM,WAAYK,EAAoBJ,YAQtC,eAAGH,KAAAA,WAAYE,IAAAA,MAChBC,EAAUH,EAAWI,SACtBC,EAAQF,IAAaA,EAAQY,OAE3B,IAGCyI,GAAQrJ,EAAQa,OAAO,EAAG,KACrBE,KAAKsI,KACRtI,KAAKsI,UANP,QAASjJ,EAAoBJ,cAS5B,eAAGK,KAAAA,MAAOR,IAAAA,WAAYE,IAAAA,MACzBC,EAAUH,EAAWI,MACvBqJ,EAAMjJ,EAAMJ,SACZC,EAAQF,IAAYA,EAAQY,OAAS,EAAG,IAE9BZ,EAAQY,UAChB2I,GAAOvJ,EAAQa,OAAO,KAElBE,KAAKyI,MAAMxJ,EAASuJ,EAAKrD,MAAMoD,MAC/BvI,KAAKyI,MAAMxJ,EAASuJ,EAAKrD,MAAM,EAAGoD,MAE/BvI,KAAKwI,UAEV,UAAWnJ,EAAoBJ,YAQhC,eAAGK,KAAAA,MACJoJ,EAAOpJ,EAAMJ,MACbkE,EAAO,IAAMe,KAAKwE,IAAI,IAAKD,EAAO,IAAM,MACxC1I,KAAKoD,cAKF,eAAG9D,KAAAA,MACNsJ,EAAMtJ,EAAMJ,MACZ2J,EAAMvJ,EAAMJ,MACZ4J,EAAMxJ,EAAMJ,MACZ6J,EAAMzJ,EAAMJ,MACZ8J,EAAI1J,EAAMJ,KAEZ4J,KAAQC,IACJ/I,KAAK6I,KAEL7I,KAAK6I,GAAsBG,EAAID,IAAQD,EAAMC,IAAjCH,EAAMC,MChMxBrB,EAASD,OAAOC,OAQT7B,wBACEsD,MAAgBzI,4EACtBY,QAAU6H,OACVtJ,cACAuJ,oBACAhJ,KAAO,OACP5B,SAAWM,EAAegI,WAC1BhB,YAAYuD,QACZC,OAAS5I,EAAQ4I,YACjBC,OAAS7I,EAAQ6I,YACjBC,QAAU9I,EAAQ8I,8CAIpB7C,uEAESG,KAAKjH,MAAME,SAAQ4G,GAAW,QAASA,IAC5CG,KAAKxH,KAAK,KAAMwH,KAAKxF,QAASqF,uCAI1BnI,GACP0H,EAAK1H,KAAWA,EAAWA,EAASsI,OACpCtI,GAAUkJ,EAAOZ,KAAKtI,SAAUD,EAAcC,iCAI9CI,EAAM2I,EAAQZ,MAAS8C,0DAAQ,EAAG7C,eAChCxG,EAAO0G,KAAK1G,KAAOqJ,GAEpB7C,GAAQW,IAAQX,EAAOW,EAAOX,SAE7BtF,GAAUiG,EAASA,EAAOjG,SAAWiG,EAASP,OAE9C/H,EAAO,GAAIyH,GAAQC,EAASrF,EAASlB,EAAMwG,YAC1C3H,EAAM6H,KAAKjH,OAEdjB,IAAMkI,KAAKsC,YAAYxK,GAAQK,GAC/B6H,KAAKwC,QAAQxC,KAAKwC,QAASrK,OAAML,OAAM2I,SAAQZ,UAAS8C,QAAO7C,SAC5D3H,sCAID2C,0DAAMrB,EAAAA,EAAU2G,yDAAQ,IACtBrH,EAAUiH,KAAVjH,SACJA,EAAME,OAAS,EAAG,QACd2J,GAAW5C,KAAK1G,KAAOwB,IACpBsF,EAAQ,GAAK7G,EAAGR,GAAS6J,GAAU,IACpCzK,GAAOY,EAAMT,KACfH,GAAK6C,OAAOgF,KAAKtI,SAAUkL,KAEtBzK,EAAM6H,KAAKjH,OAEdiH,KAAK0C,SAAS1C,KAAK0C,SAAUvK,OAAMmB,KAAM0G,KAAK1G,YAGjDA,KAAOsJ,YAEPtJ,MAAQwB,QAER/B,GAAME,OAAS,yCAIjBF,MAAME,OAAS,+BAIhBnB,MACAK,SACgB,iBAATA,MACF6H,KAAKsC,YAAYxK,QACnBwK,YAAYxK,GAAQ,SAElBA,IACA,MAELkI,KAAKyC,QAAQzC,KAAKyC,QAAS3K,OAAMK,WAE9BA,EAAM6H,KAAKjH,gBC9FhB8J,EAAmB,iCAAuB/K,kBAI1CiC,EAAc,iCAEP,MAAO,QAAS,QAAS,aAC5B,iBAAM,IAAIJ,GAAUmJ,MAAOpG,MAAO,KAAOM,2BAGtC,MAAO,OAAQ,SAAU,eAC5B,iBAAM,IAAIrD,GAAUoJ,OAAQC,OAAQ,MAAOhG,yBAGxC,MAAO,cACV,iBAAM,IAAIrD,GAAUsJ,KAAMxG,IAAK,MAAOO,2BAGnC,MAAO,cACV,iBAAM,IAAIrD,GAAUuJ,OAAQzG,IAAK,IAAMD,KAAM,MAAOQ,2BAGjD,MAAO,cACV,iBAAM,IAAIrD,GAAUwJ,OAAQ1G,IAAK,IAAKO,yBAGnC,MAAO,cACV,iBAAM,IAAIrD,GAAUyJ,KAAM3G,IAAK,IAAMD,KAAM,MAAOQ,0BAG/C,YACH,iBAAM,IAAIrD,GAAU0J,MAAO5G,IAAK,KAAOO,6BAGpC,MAAO,cACV,iBAAM,IAAIrD,GAAU2J,SAAU7G,IAAK,KAAOO,2BAGvC,OAAQ,MAAO,QAAS,UAAW,iBACtC,iBAAM,IAAIrD,GAAU4J,mBAAoBC,UAAW,KAAMxG,mBACtD,SAAC3C,EAAMG,MACRgC,GAAOhC,EAAQE,IAAI,OACrB8B,GAAO,MACJA,KAAOA,IACPiH,QAAU,IAAM,EAAKlG,KAAKU,IAAIzB,EAAO7C,EAAUsB,gBAEhDwB,GAAMjC,EAAQE,IAAI,MACpB+B,KAAKpC,EAAKoC,IAAMA,EAAMA,EAAM,OAC1BiH,GAAQlJ,EAAQE,IAAI,QACtBgJ,KAAOrJ,EAAKqJ,MAAQA,mBAIjB,OAAQ,MAAO,kBAClB,iBAAM,IAAI/J,GAAUgK,kBAChB,SACDhK,EAAUiK,KAAKC,MAAM,gBAChB,YACH,UACA,IACR7G,cAYD/C,EAAe,2BACV,eAAGO,KAAAA,QAASpC,IAAAA,MACb0L,EAAMC,EAAKvJ,EAASX,EACtBiK,IAAK1L,EAAM,QAAS0L,iBAEZ,eAAGpL,KAAAA,MAAO8B,IAAAA,QAASpC,IAAAA,MACzB4L,EAAQtL,EAAMJ,MACdwL,EAAMC,EAAKvJ,EAAQyJ,MAAMD,GAAQnK,EACnCiK,IAAK1L,EAAM,aAAc0L,eAEnB,eAAGpL,KAAAA,MACPqC,EAAMyG,WAAW9I,EAAMJ,MAAO,GAChCyC,GAAM,IAAGlB,EAAMkB,IAAMA,mBAEX,eAAGrC,KAAAA,MACX6I,EAASC,WAAW9I,EAAMJ,MAAO,GACnCiJ,KAAQ1H,EAAMkB,KAAOwG,MAwDvBwC,EAAO,SAACvJ,EAASX,MACbE,GAAgBF,EAAhBE,YACFmK,EAAW1J,EAAQE,IAAI,QACvByJ,EAAapK,EAAYmK,OAC1BC,EAAY,MAAOtB,GAAiBqB,EACpCC,GAAWC,WAAUD,EAAWC,SAAWD,EAAWzK,WAErDW,GAAO8J,EAAWC,WACb9J,QAAQD,EAAMG,KACpBgC,KAAOnC,EAAKgK,KAAKhK,EAAKmC,MAAQnC,EAAKgK,QC3JpC3I,EAAc,SAACpC,EAAMyB,SAAQzB,GAAOyB,EAAM,IAC1Ce,EAAc,SAAC+H,EAAO9I,SAAgB,IAAR8I,EAAa9I,GAE3CiB,EAA2B,yBCDzByB,EAAUF,KAAVE,MEKFpD,EAAO,kBAAQ,eAAGnC,WACXkB,MAAMtB,EAAM,OAAQ,OAAQ,YAEnC2G,EAAW,SAAC3G,EAAMwM,EAAIC,SAAO,gBAAG7L,KAAAA,QAAOR,WAChCkB,KAAKmL,GACX7L,EAAMJ,MAAOiM,EAAI,OAAQ7L,EAAMJ,MAAOgM,EAAI,OAC3CxM,EAAM,OAAQ,OAAQ,UACrBY,EAAMJ,MAAOgM,EAAI,OAClBxM,EAAM,OAAQ,OAAQ"}